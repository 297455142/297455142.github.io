<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Angular上</title>
    <link href="/2023/07/19/Angular%E4%B8%8A/"/>
    <url>/2023/07/19/Angular%E4%B8%8A/</url>
    
    <content type="html"><![CDATA[<p><strong>设计原则</strong>：可维护性、可修改性、可扩展性</p><p>①YAGNI：不写不需要的代码。</p><p>②DRY：不要重复写自己的代码。</p><p>③OCP：开闭原则。对扩展开放，对修改封闭。</p><p>④Low Coupling，High Cohesion：高聚合、低耦合原则</p><p>⑤Dimeter Law：迪米特法则，也叫最少知识法则，一个对象&#x2F;组建只负责必须的少量功能。</p><p><strong>Angular框架是MVVM框架</strong>，该框架组成包括：数据绑定、组件式编程、路由和导航、状态保持、第三方组件库。</p><p><strong>区别</strong>：VUE适合中小型项目，Angular适合中大型项目。</p><h5 id="常用：canvas绘图、svg图标、本地存储localstorage和session"><a href="#常用：canvas绘图、svg图标、本地存储localstorage和session" class="headerlink" title="常用：canvas绘图、svg图标、本地存储localstorage和session"></a>常用：canvas绘图、svg图标、本地存储localstorage和session</h5><p><strong>性能优化</strong>：Web Worker</p><p><strong>双向通信</strong>：Websocket</p><h1 id="一、搭建Angular开发环境"><a href="#一、搭建Angular开发环境" class="headerlink" title="一、搭建Angular开发环境"></a>一、搭建Angular开发环境</h1><p>&#x2F;&#x2F;通常需要提前下载python和git</p><p>1、下载并安装脚手架工具</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> install -g @angular/cli<br></code></pre></td></tr></table></figure><p>2、运行脚手架工具创建空白项目</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">ng <span class="hljs-keyword">new</span> ProjectName<br></code></pre></td></tr></table></figure><p>3、进入空白项目并运行开发服务器</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">cd</span> ProjectNameng serve <span class="hljs-params">--open</span><br></code></pre></td></tr></table></figure><p>默认会在本地<a href="http://localhost:4200/">http://localhost:4200</a></p><p>4、客户端访问测试</p><h2 id="1-1-文件结构"><a href="#1-1-文件结构" class="headerlink" title="1.1 文件结构"></a>1.1 文件结构</h2><p>node_modules是第三方文件。</p><p>src文件夹存放项目的主要代码。</p><ul><li><p>index.html为项目的静态文件入口，其中&lt;html lang&#x3D;”en”&gt;代表网页的首选语言为英文，中文为zh。</p></li><li><p>main.ts为项目的主入口，其中含有引导启动模块：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">platformBrowserDynamic</span>().<span class="hljs-title function_">bootstrapModule</span>(<span class="hljs-title class_">AppModule</span>).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span>=&gt;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(err)); <br></code></pre></td></tr></table></figure></li><li><p>app文件夹中的app.module.ts为默认组件（唯一）。代码都放在app文件夹下。</p></li><li><p>style.css</p></li><li><p>assets文件夹下存放静态资源。</p></li></ul><hr><p>Model：模型</p><p>Module：模块</p><p>Modal：模态对话框</p><ul><li>angular.json：Angular项目的配置文件，其中index：.&#x2F;src&#x2F;index.html main:.&#x2F;src&#x2F;main.ts</li></ul><h2 id="1-2-模块和组件"><a href="#1-2-模块和组件" class="headerlink" title="1.2 模块和组件"></a>1.2 模块和组件</h2><p><strong>Module</strong>：一个抽象的容器，用于对组件进行分组。应用初始时只有一个主组件AppModule。<br><strong>组件Component</strong>：一段可以反复使用的页面片段，包括模板、脚本和样式。在Angular项目中，任何一个组件必须声明在模块中。</p><hr><p>① 组件如下：</p><ul><li>xxx.component.ts</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Component</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@angular/core&#x27;</span>; <br><span class="hljs-comment">//装饰器，用于指定class的用途，其中的都是元数据</span><br><span class="hljs-meta">@Component</span>(&#123;<br>    <span class="hljs-comment">// 组件的选择器</span><br>    <span class="hljs-attr">selector</span>:  <span class="hljs-string">&#x27;component01&#x27;</span>,<br>    <span class="hljs-comment">// 组件的模板</span><br>    <span class="hljs-attr">templateUrl</span>: <span class="hljs-string">&#x27;./test.component.html&#x27;</span>,<br>    <span class="hljs-comment">// 样式文件（数组）</span><br>    <span class="hljs-attr">styleUrls</span>: [<span class="hljs-string">&#x27;./test.component.scss&#x27;</span>]<br>&#125;)<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppComponent</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>xxx.component.html：组件的模板</p></li><li><p>xxx.component.cs：组件的样式</p></li><li><p>xxx.component.spec.ts：组件的测试文件</p></li></ul><p>② 在某个模块中注册组件class</p><p>在xxx.module.ts中进行组件的注册</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@NgModule</span>(&#123;<br>    <span class="hljs-comment">// 组件类名</span><br>    <span class="hljs-attr">declarations</span>: [<br>        <span class="hljs-title class_">AppComponent</span>, <br>    ],<br>&#125;)<br></code></pre></td></tr></table></figure><p>③ 使用组件：</p><p><strong>普通组件不能用在index.html中，只能用在app.component.html或其它普通组件中</strong></p><p>如在根组件app.component.html中使用该组件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">component01</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">component01</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>创建组件</strong>：ng g component 组件名</p><h1 id="二、数据绑定"><a href="#二、数据绑定" class="headerlink" title="二、数据绑定"></a>二、数据绑定</h1><h3 id="一、HTML绑定"><a href="#一、HTML绑定" class="headerlink" title="一、HTML绑定"></a>一、HTML绑定</h3><p>****：先在组件的导出类中声明变量，然后在html中使用。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html">export class MyComponent &#123;<br>    name = &quot;dingding&quot;;<br>&#125;<br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;&#123; name &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>ng表达式中可以</strong>：</p><p>1、算数运算：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;&#123;age+2&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2、三目运算和比较运算：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;&#123;age&gt;=18 ? &#x27;成年&#x27; : &#x27;未成年&#x27;&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>3、逻辑运算：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>在法定工作年龄吗：&#123;&#123;age&gt;=18 &amp;&amp; age&lt;60&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>4、调用函数</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>用户名长度：&#123;&#123;name.length&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>用户名大写：&#123;&#123;name.toUpperCase()&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>用户名下标为2的字符：&#123;&#123;name[2]&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>创建对象和JSON序列化不可以</strong>：NG表达式中禁止出现new关键字，JSON是undefined。</p><h3 id="二、属性绑定"><a href="#二、属性绑定" class="headerlink" title="二、属性绑定"></a>二、属性绑定</h3><p>1、直接在属性上用双花括号</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;&#123;&#123;name&#125;&#125;&quot;</span>&gt;</span>标题<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2、 使用[]做属性绑定 <strong>属性绑定时，通常赋值的是变量，若赋值为常量，字符串要放在’’里</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> [<span class="hljs-attr">titile</span>]=<span class="hljs-string">&quot;&#x27;名字是：&#x27;+name&quot;</span>&gt;</span>标题<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="三、指令绑定"><a href="#三、指令绑定" class="headerlink" title="三、指令绑定"></a>三、指令绑定</h3><p>1、循环绑定：<strong>*ngFor</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ANY</span> *<span class="hljs-attr">ngFor</span>=<span class="hljs-string">&quot;let 临时变量 of 数据&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">ANY</span> *<span class="hljs-attr">ngFor</span>=<span class="hljs-string">&quot;let 临时变量 of 数据; let i=index;&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">ANY</span> *<span class="hljs-attr">ngFor</span>=<span class="hljs-string">&quot;let 临时变量 of 数据; index as i&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2、选择绑定：<strong>*ngIf</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ANY</span> *<span class="hljs-attr">ngIf</span>=<span class="hljs-string">&quot;布尔表达式&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>若布尔表达式为false，则当前元素从DOM树上删除</strong></p><p>对于多种选择：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html">&lt;ANY*ngIf=&quot;布尔表达式; else ELSE块的编号&quot;&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">ANY</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">ng-template</span> #<span class="hljs-attr">ELSE</span>块的编号&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">ANY</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ANY</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ng-template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> *<span class="hljs-attr">ngIf</span>=<span class="hljs-string">&quot;age&gt;=18; else forChildren&quot;</span>&gt;</span>成年人<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">ng-template</span> #<span class="hljs-attr">forChildren</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>儿童<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ng-template</span>&gt;</span><br></code></pre></td></tr></table></figure><p>3、样式绑定：**[ngStyle]**</p><p>ngStyle绑定的值必须是一个对象，对象属性就是CSS样式名。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ANY</span> [<span class="hljs-attr">ngStyle</span>]=<span class="hljs-string">&quot;obj&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ANY</span>&gt;</span><br><br>export class MyComponent&#123;<br>myStyle = &#123;<br>backgroundColor: &#x27;green&#x27;,<br>color: &#x27;blue&#x27;,<br>&#x27;border-color&#x27;: &#x27;#252&#x27;<br>&#125;<br>&#125;<br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> [<span class="hljs-attr">ngStyle</span>]=<span class="hljs-string">&quot;myStyle&quot;</span>&gt;</span>提示<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure><p>4、样式绑定：**[ngClass]**</p><p>ngClass绑定的值必须是一个对象，对象属性就是CSS class名，属性值为true&#x2F;false，true的话该class就出现，否则该class不出现。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ANY</span> [<span class="hljs-attr">ngClass</span>]=<span class="hljs-string">&quot;obj&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ANY</span>&gt;</span><br><br>export class MyComponent&#123;<br>myClassObj = &#123;<br>btn: true,<br>&#x27;btn-danger&#x27;: false, //烤串法则<br>&#x27;btn-success&#x27;: true<br>&#125;<br>&#125;<br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> [<span class="hljs-attr">ngClass</span>]=<span class="hljs-string">&quot;myClassObj&quot;</span> (<span class="hljs-attr">click</span>)=<span class="hljs-string">&quot;loadMore()&quot;</span>&gt;</span>加载<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>烤串法则</strong>：带-的变量名用’’</p><p><strong>驼峰法则</strong>：变量名中用字母大写来代替-</p><h3 id="四、事件绑定"><a href="#四、事件绑定" class="headerlink" title="四、事件绑定"></a>四、事件绑定</h3><p>事件用()括起来，函数后必须有()。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html">export class MyComponent &#123;<br>name = &#x27;liee&#x27;;<br>printName()&#123;<br>console.log(this.name);<br>&#125;<br>&#125;<br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> (<span class="hljs-attr">click</span>)=<span class="hljs-string">&quot;printName()&quot;</span>&gt;</span>按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="五、特殊选择绑定"><a href="#五、特殊选择绑定" class="headerlink" title="五、特殊选择绑定"></a>五、特殊选择绑定</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ANY</span> [<span class="hljs-attr">ngSwitch</span>]=<span class="hljs-string">&quot;表达式&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">ANY</span> *<span class="hljs-attr">ngSwitchCase</span>=<span class="hljs-string">&quot;值1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ANY</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">ANY</span> *<span class="hljs-attr">ngSwitchCase</span>=<span class="hljs-string">&quot;值2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ANY</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">ANY</span> *<span class="hljs-attr">ngSwitchDefault</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ANY</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ANY</span>&gt;</span><br>//如果值为常量，则还需要加&#x27;&#x27;<br></code></pre></td></tr></table></figure><h5 id="Angular中指令分为三类"><a href="#Angular中指令分为三类" class="headerlink" title="Angular中指令分为三类"></a>Angular中指令分为三类</h5><ul><li><strong>组件指令</strong>： NG中Component继承自Directive，组件是一种特殊的指令。</li><li><strong>结构型指令</strong>：会影响DOM树结构，必须使用<em>开头，如</em>ngFor、*ngIf</li><li><strong>属性型指令</strong>：不会影响DOM树结构，只是影响元素外观或行为，必须用[]。</li></ul><p>### 六、双向数据绑定</p><p>M&#x3D;&gt;V模型变则视图变。</p><p>V&#x3D;&gt;M视图变则模型变。</p><p>用[(ngModel)]，<strong>使用前需要先导入模块</strong>。</p><p>监听数据变化事件用ngModelChange</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html">//需要先在app.modules.ts中导入<br>import &#123;FormsModule&#125; from &#x27;@angular/forms&#x27;<br>imports:[<br>BrowserModule,<br>FormsModule,<br>]<br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> [(<span class="hljs-attr">ngModel</span>)]=<span class="hljs-string">&quot;uname&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;请输入用户名&quot;</span> (<span class="hljs-attr">ngModelChange</span>)=<span class="hljs-string">&quot;nameChange()&quot;</span> &gt;</span><br></code></pre></td></tr></table></figure><h3 id="七、自定义指令"><a href="#七、自定义指令" class="headerlink" title="七、自定义指令"></a>七、自定义指令</h3><p>自定义指令都是作为元素属性来使用的，selector是：[指令名]</p><p><strong>ng g directive 指令名</strong></p><p>此时在app.module.ts中的declarations中会出现定义的指令，并且出现：指令名.directive.ts文件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html">//指令文件内<br>@Directive(&#123;<br>selector:&#x27;[Tranm]&#x27;<br>&#125;)<br>export class TranmDirective &#123;<br>constructor( el: ElementRef ) &#123;<br>el.nativeElement.style.background = &#x27;#fcc&#x27;<br>el.nativeElement.style.padding = &#x27;10px&#x27;<br>&#125;<br>&#125;<br>//模板中<br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">tranm</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>英语问题</title>
    <link href="/2022/09/26/%E8%8B%B1%E8%AF%AD%E9%97%AE%E9%A2%98/"/>
    <url>/2022/09/26/%E8%8B%B1%E8%AF%AD%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h2><p>Hello, interviewer. My name is Wang Boyang. Both undergraduate and graduate students studied in the School of Computer Science and Engineering, University of Electronic Science and Technology of China. The undergraduate major is digital media technology, and the graduate major is computer technology. Now I am a third-year graduate student. During my postgraduate study, I served as the laboratory director and led the team to complete the development of a series of projects. In terms of projects, I mainly participated in the 云上外场, 牙美乐, model management system and so on. In the 云上外场 project, I served as the team leader and realized the functions of <strong>data management, 3D scene simulation, 3D scene roaming interaction, camera video recording and playback</strong>, etc. </p><p>This project is a cooperation between our laboratory and Huawei. <strong>Its purpose is to provide a test platform for the development of Huawei 6G, and to show the operation of 6G devices in real time for Huawei customers in a variety of data charts, camera videos, 3D models and other ways</strong>, so as to introduce 6G to the world.</p><p>I am very glad to have the opportunity to participate in the interview of your company and communicate with you. Thank you.</p><h2 id="为什么加入蚂蚁"><a href="#为什么加入蚂蚁" class="headerlink" title="为什么加入蚂蚁"></a>为什么加入蚂蚁</h2><p>First, because <strong>ANT FINANCIAL SERVICES GROUP</strong> is so good. I think I can learn a lot if I join it. In addition, I am very interested in the business of<br>ANT FINANCIAL SERVICES GROUP, because financial business is popular.</p><h2 id="云上外场项目的目的是什么"><a href="#云上外场项目的目的是什么" class="headerlink" title="云上外场项目的目的是什么"></a>云上外场项目的目的是什么</h2><p>The purpose of this project is <strong>to show the testing process of 6G experiment to customers through various forms of presentation, so as to provide users with a real experience</strong>. Its main display forms include a variety of data charts, camera video and 3D model of the device. Through these contents, users can timely understand the contents of the experimental process, and at the same time with the help of the experimental simulation system to the equipment operation instructions.</p><h2 id="为什么选择前端"><a href="#为什么选择前端" class="headerlink" title="为什么选择前端"></a>为什么选择前端</h2><p>First of all, I was exposed to the front end position during my graduate study. In participating in the project of the laboratory, I was exposed to back-end development, algorithm development and front-end development. The front end gives me a sense of accomplishment more easily than the others. In my opinion, the front end involves interacting with the user，which means how beautiful and operational of  our pages is really affects the user’s experience.That’s what I’m interested in.<br>In addition, I know several seniors[sei ni en s] who are good at front-end development.They taught me how to learn the front end, and they told me about the front end development prospects.With their help, I gradually got used to front-end development and constantly improved my level.</p><h2 id="如何学习前端的"><a href="#如何学习前端的" class="headerlink" title="如何学习前端的"></a>如何学习前端的</h2><p>First, I developed a definitive view of the front end by reading some basic books such as Professional javascript for Web Developers and javascript: The Definitive Guide. At the same time, I will combine some teaching videos to learn and apply front-end knowledge. Next, I’ll take part in some projects on front-end development to practice. During this time I will encounter many problems and be exposed to many new concepts. In order to solve these problems, I will check some blogs, such as CSDN, or find some related projects on Github.</p><h2 id="学习前端遇到过什么问题"><a href="#学习前端遇到过什么问题" class="headerlink" title="学习前端遇到过什么问题"></a>学习前端遇到过什么问题</h2><p>Here is an example. When adding virtual[ve chou] experiment environment to the web page, it will be slow to load in the web page due to the large experimental field. First we used Threejs and wanted to <strong>implement[in play ment</strong> dough[dou] video projection, and there were a lot of cracks in the 3D model. We discovered that this is because 3D models are built by stitching together pieces of dough[dou]. To solve this problem, we used CocosJs, which are commonly used to implement game surroundings. In addition, we found that during the development of some games, only the surrounding environment was loaded for the user. This is because the user’s field of view is limited. Therefore, we use a technology similar to lazy loading to load the environment around the user based on the location of the user.</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>31.下一个排列</title>
    <link href="/2022/09/06/31-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/"/>
    <url>/2022/09/06/31-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>整数数组的一个 排列  就是将其所有成员以序列或线性顺序排列。</p><p>例如，arr &#x3D; [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] 。<br>整数数组的 下一个排列 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 下一个排列 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。</p><p>例如，arr &#x3D; [1,2,3] 的下一个排列是 [1,3,2] 。<br>类似地，arr &#x3D; [2,3,1] 的下一个排列是 [3,1,2] 。<br>而 arr &#x3D; [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1] 不存在一个字典序更大的排列。<br>给你一个整数数组 nums ，找出 nums 的下一个排列。</p><p>必须 原地 修改，只允许使用额外常数空间。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>需要将左边较小数和右边较大数交换，同时较小数尽量靠右，较大数尽可能小。在交换后较大数右边按升序重新排列。<br>为找到最靠右的较小数，从最后一个往前看，不满足递增的第一个数就是较小数，然后从最后一个往前看，找第一个大于最小数的值。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">nextPermutation</span>(<span class="hljs-params">num</span>)&#123;<br>    <span class="hljs-keyword">let</span> i = nums.<span class="hljs-property">length</span>-<span class="hljs-number">2</span>, j = nums.<span class="hljs-property">length</span>-<span class="hljs-number">1</span>, k = nums.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(i&gt;=<span class="hljs-number">0</span>&amp;&amp;nums[i]&gt;=nums[j])&#123;<br>        i--;<br>        j--;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span> num.<span class="hljs-title function_">reverse</span>();<br>    &#125;<br>    [nums[i],nums[k]] = [nums[k], nums[i]];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> l = nums.<span class="hljs-property">length</span>-<span class="hljs-number">1</span>;j&lt;l;j++,l--)&#123;<br>        [nums[j],nums[l]] = [nums[i], nums[j]];<br>    &#125;<br>    <span class="hljs-keyword">return</span> nums;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>数组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>html浏览器知识</title>
    <link href="/2022/08/11/html%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9F%A5%E8%AF%86/"/>
    <url>/2022/08/11/html%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h2 id="★一、src和href区别"><a href="#★一、src和href区别" class="headerlink" title="★一、src和href区别"></a>★一、src和href区别</h2><p>src和href都是<strong>用来引用外部的资源</strong>，它们的区别如下：</p><ul><li><strong>src：</strong> 引入js，表示对资源的引用，本质是引入嵌入式内容，比如image、video等替换型元素，它指向的内容会嵌入到当前标签所在的位置，<strong>表示替换当前的元素</strong>，会直接展示。src会将其指向的资源下载并应⽤到⽂档内。当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执⾏完毕，所以⼀般js脚本会放在页面底部。</li><li><strong>href：</strong> 引入CSS时，表示超文本引用，本质是引入一些链接型元素。它指向一些网络资源，<strong>建立和当前元素或本文档的链接关系</strong>，不会直接展示。。当浏览器识别到它他指向的⽂件时，就会并⾏下载资源，不会停⽌对当前⽂档的处理。 常用在a、link等标签上。</li></ul><h2 id="★二、浏览器如何解析html、css、js（渲染过程）"><a href="#★二、浏览器如何解析html、css、js（渲染过程）" class="headerlink" title="★二、浏览器如何解析html、css、js（渲染过程）"></a>★二、浏览器如何解析html、css、js（渲染过程）</h2><p>这个过程被称为渲染流水线，包括构建DOM树、样式计算、布局阶段、分层、绘制、分块、光栅化和合成。</p><h3 id="2-1-浏览器渲染"><a href="#2-1-浏览器渲染" class="headerlink" title="2.1 浏览器渲染"></a>2.1 浏览器渲染</h3><ol><li>构建DOM树：浏览器获取HTML文件，然后对文件进行解析，形成DOM树。</li><li>样式计算：解析css，把CSS转换为浏览器能够理解的结构。生成Style Rules ，解析的顺序是浏览器的样式 -&gt; 用户自定义的样式 -&gt;页面的link标签等引进来的样式 -&gt; 写在style标签里面的内联样式。</li><li>合成渲染树：将DOM树与样式规则合成为渲染树，在RENDER树中，会把DOM树中没有的元素给去除，比如head标签以及里面的内容，以及display:none的元素也会被去除。</li><li>布局阶段：为DOM树上的每个可见元素分配其在屏幕上的坐标（几何位置）。</li><li>分层：对布局进行分层，按图层进行绘制。</li><li>为每个图层生成绘制列表，并将其提交到合成线程。</li><li>栅格化：通过渲染引擎中的合成线程来完成绘制操作，借助GPU进行绘制。</li></ol><p>（CSS加载不会阻塞html解析，但是会阻塞渲染，另外CSS加载会阻塞JS代码。）<br>这可能也是浏览器的一种优化机制。因为加载css的时候，可能会修改下面DOM节点的样式，如果css加载不阻塞DOM树渲染的话，那么当css加载完之后，DOM树可能又得重新重绘或者回流了，这就造成了一些没有必要的损耗。<br>所以干脆就先把DOM树的结构先解析完，把可以做的工作做完，然后等css加载完之后，在根据最终的样式来渲染DOM树，这种做法性能方面确实会比较好一点。</p><ol start="8"><li>合成和显示：浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上。</li></ol><h3 id="2-2-JS"><a href="#2-2-JS" class="headerlink" title="2.2 JS"></a>2.2 JS</h3><p>主要是通过DOM API和CSSOM API来操作DOM树和CSS规则树。</p><h1 id="★三、一个浏览器标签页包括多少进程和线程"><a href="#★三、一个浏览器标签页包括多少进程和线程" class="headerlink" title="★三、一个浏览器标签页包括多少进程和线程"></a>★三、一个浏览器标签页包括多少进程和线程</h1><p>浏览器包括1个浏览器主进程，1个GPU进程，1个网络进程，多个渲染进程和多个插件进程。例如：<br>打开2个标签页：1个浏览器主进程，1个GPU进程，1个网络进程，2个渲染进程。<br><strong>浏览器渲染进程</strong>：渲染线程（只有一个）、JS引擎线程（只有一个）、时间触发线程、定时器触发线程（setTimeout和setInterval）、异步http请求线程（多个）。</p><h1 id="四、为什么JS引擎执行时渲染线程要被挂起"><a href="#四、为什么JS引擎执行时渲染线程要被挂起" class="headerlink" title="四、为什么JS引擎执行时渲染线程要被挂起"></a>四、为什么JS引擎执行时渲染线程要被挂起</h1><p>因为JS是可以操作DOM的，而如果在修改这些元素的同时渲染界面，即当这两个线程不是互斥的时候，那么渲染线程前后获得的元素数据就可能不一致。所以JavaScript引擎执行时渲染线程会被挂起，渲染更新会被保存在一个队列中等到JS引擎线程空闲时立即被执行。</p><h1 id="★五、CDN是什么（共享缓存）"><a href="#★五、CDN是什么（共享缓存）" class="headerlink" title="★五、CDN是什么（共享缓存）"></a>★五、CDN是什么（共享缓存）</h1><h2 id="5-1-CDN的概念"><a href="#5-1-CDN的概念" class="headerlink" title="5.1 CDN的概念"></a>5.1 CDN的概念</h2><p>CDN（<strong>内容分发网络</strong>）指一种通过互联网互相连接的电脑网络系统，利用最靠近每位用户的服务器，更快、更可靠地将音乐、图片、视频、应用程序及其他文件发送给用户，来提供高性能、可扩展性及低成本的网络内容传递给用户。<br>典型的CDN系统由下面三个部分组成：</p><ul><li><strong>分发服务系统：</strong> 最基本的工作单元就是Cache缓存设备，cache（边缘cache）负责直接响应最终用户的访问请求，把缓存在本地的内容快速地提供给用户。同时cache还负责与源站点进行内容同步，把更新的内容以及本地没有的内容从源站点获取并保存在本地。Cache设备的数量、规模、总服务能力是衡量一个CDN系统服务能力的最基本的指标。</li><li><strong>负载均衡系统：</strong> 主要功能是负责对所有发起服务请求的用户进行访问调度，确定提供给用户的最终实际访问地址。两级调度体系分为全局负载均衡（GSLB）和本地负载均衡（SLB）。<strong>全局负载均衡</strong>主要根据用户就近性原则，通过对每个服务节点进行“最优”判断，确定向用户提供服务的cache的物理位置。<strong>本地负载均衡</strong>主要负责节点内部的设备负载均衡</li><li><strong>运营管理系统：</strong> 运营管理系统分为运营管理和网络管理子系统，负责处理业务层面的与外界系统交互所必须的收集、整理、交付工作，包含客户管理、产品管理、计费管理、统计分析等功能。</li></ul><h2 id="5-2-CDN的作用"><a href="#5-2-CDN的作用" class="headerlink" title="5.2 CDN的作用"></a>5.2 CDN的作用</h2><p>CDN一般会用来托管Web资源（包括文本、图片和脚本等），可供下载的资源（媒体文件、软件、文档等），应用程序（门户网站等）。使用CDN来加速这些资源的访问。<br>（1）在性能方面，引入CDN的作用在于：</p><ul><li>用户收到的内容来自最近的数据中心，延迟更低，内容加载更快</li><li>部分资源请求分配给了CDN，减少了服务器的负载<br>（2）在安全方面，CDN有助于防御DDoS、MITM等网络攻击：</li><li>针对DDoS：通过监控分析异常流量，限制其请求频率</li><li>针对MITM：从源服务器到 CDN 节点到 ISP（Internet Service Provider），全链路 HTTPS 通信<br>除此之外，CDN作为一种基础的云服务，同样具有资源托管、按需扩展（能够应对流量高峰）等方面的优势。</li></ul><h2 id="5-3-CDN的原理"><a href="#5-3-CDN的原理" class="headerlink" title="5.3 CDN的原理"></a>5.3 CDN的原理</h2><p>CDN和DNS有着密不可分的联系，先来看一下DNS的解析域名过程，在浏览器输入url 的解析过程如下：<br>（1） 检查浏览器缓存<br>（2）检查操作系统缓存，常见的如hosts文件<br>（3）检查路由器缓存<br>（4）如果前几步都没没找到，会向ISP(网络服务提供商)的LDNS服务器查询<br>（5）如果LDNS服务器没找到，会向根域名服务器(Root Server)请求解析，<br>     分为以下几步：</p><ul><li>根服务器返回顶级域名(TLD)服务器如.com，.cn，.org等的地址，该例子中会返回<code>.com</code>的地址</li><li>接着向顶级域名服务器发送请求，然后会返回次级域名(SLD)服务器的地址，本例子会返回<code>.test</code>的地址</li><li>接着向次级域名服务器发送请求，然后会返回通过域名查询到的目标IP，本例子会返回<code>www.test.com</code>的地址</li><li>Local DNS Server会缓存结果，并返回给用户，缓存在系统中</li></ul><p><strong>CDN的工作原理：</strong> </p><p><strong>（1）用户未使用CDN缓存资源的过程：</strong></p><ol><li>浏览器通过DNS对域名进行解析（就是上面的DNS解析过程），依次得到此域名对应的IP地址</li><li>浏览器根据得到的IP地址，向域名的服务主机发送数据请求</li><li>服务器向浏览器返回响应数据</li></ol><p><strong>（2）用户使用CDN缓存资源的过程：</strong></p><ol><li>对于点击的数据的URL，经过本地DNS系统的解析，发现该URL对应的是一个CDN专用的DNS服务器，DNS系统就会将域名解析权交给CNAME指向的CDN专用的DNS服务器。</li><li>CND专用DNS服务器将CND的全局负载均衡设备IP地址返回给用户</li><li>用户向CDN的全局负载均衡设备发起数据请求</li><li>CDN的全局负载均衡设备根据用户的IP地址，以及用户请求的内容URL，选择一台用户所属区域的区域负载均衡设备，告诉用户向这台设备发起请求</li><li>区域负载均衡设备选择一台合适的缓存服务器来提供服务，将该缓存服务器的IP地址返回给全局负载均衡设备</li><li>全局负载均衡设备把服务器的IP地址返回给用户</li><li>用户向该缓存服务器发起请求，缓存服务器响应用户的请求，将用户所需内容发送至用户终端。<br> 如果缓存服务器没有用户想要的内容，那么缓存服务器就会向它的上一级缓存服务器请求内容，以此类推，直到获取到需要的资源。最后如果还是没有，就会回到自己的服务器去获取资源。<br> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a4635b395fb64aaab8417f63e64291d4~tplv-k3u1fbpfcp-watermark.awebp" alt="img"> CNAME（意为：别名）：在域名解析中，实际上解析出来的指定域名对应的IP地址，或者该域名的一个CNAME，然后再根据这个CNAME来查找对应的IP地址。<h2 id="5-4-CDN的使用场景"><a href="#5-4-CDN的使用场景" class="headerlink" title="5.4 CDN的使用场景"></a>5.4 CDN的使用场景</h2></li></ol><ul><li><strong>使用第三方的CDN服务：</strong>如果想要开源一些项目，可以使用第三方的CDN服务</li><li><strong>使用CDN进行静态资源的缓存：</strong>将自己网站的静态资源放在CDN上，比如js、css、图片等。可以将整个项目放在CDN上，完成一键部署。</li><li><strong>直播传送：</strong>直播本质上是使用流媒体进行传送，CDN也是支持流媒体传送的，所以直播完全可以使用CDN来提高访问速度。CDN在处理流媒体的时候与处理普通静态文件有所不同，普通文件如果在边缘节点没有找到的话，就会去上一层接着寻找，但是流媒体本身数据量就非常大，如果使用回源的方式，必然会带来性能问题，所以流媒体一般采用的都是主动推送的方式来进行。</li></ul><h1 id="★六、浏览器缓存策略（强弱）"><a href="#★六、浏览器缓存策略（强弱）" class="headerlink" title="★六、浏览器缓存策略（强弱）"></a>★六、浏览器缓存策略（强弱）</h1><h2 id="6-1-强缓存"><a href="#6-1-强缓存" class="headerlink" title="6.1 强缓存"></a>6.1 强缓存</h2><p>使用强缓存策略时，如果缓存资源有效，则直接使用缓存资源，不必再向服务器发起请求。强缓存如果命中，<strong>返回state code为200</strong>，客户端就不会再给服务器发送请求，直接从本地获取资源。<strong>不经常更新的用强缓存</strong><br>强缓存策略可以通过两种方式来设置，分别是 http 头信息中的 Expires 属性和 Cache-Control 属性。<br><strong>Expires</strong>：服务器通过在响应头中添加 Expires 属性，来<strong>指定资源的过期时间</strong>。在过期时间以内，该资源可以被缓存使用，不必再向服务器发送请求。这个时间是一个<strong>绝对时间</strong>，它是服务器的时间，因此可能存在问题：客户端的时间和服务器端的时间不一致，或者用户可以对客户端时间进行修改的情况，这样就可能会影响缓存命中的结果。<br><strong>Cache-Control</strong>：优先级更高，有几个字段</p><ul><li>max-age&#x3D;：设置缓存的最大有效期，单位为秒；</li><li>s-maxage&#x3D;：优先级高于max-age&#x3D;，仅适用于共享缓存(CDN)代理服务器生效，优先级高于max-age或者Expires头；</li><li>public：设置了该字段值的资源表示可以被任何对象（包括：发送请求的客户端、代理服务器等等）缓存。这个字段值不常用，一般还是使用max-age&#x3D;来精确控制；</li><li>private：默认值，设置了该字段值的资源只能被用户浏览器缓存，不允许任何代理服务器缓存。在实际开发当中，对于一些含有用户信息的HTML，通常都要设置这个字段值，避免代理服务器(CDN)缓存；</li><li>no-cache：设置了该字段需要先和服务端确认返回的资源是否发生了变化，如果资源未发生变化，则直接使用缓存好的资源；</li><li>no-store：设置了该字段表示禁止任何缓存，每次都会向服务端发起新的请求，拉取最新的资源；</li><li>max-stale[&#x3D;]：设置了该字段表明客户端愿意接收已经过期的资源，但是不能超过给定的时间限制。</li></ul><h2 id="6-2-协商缓存"><a href="#6-2-协商缓存" class="headerlink" title="6.2 协商缓存"></a>6.2 协商缓存</h2><p> 如果没有命中强缓存，且设置了协商缓存，这时使用协商缓存。<strong>频繁更新的用协商缓存</strong><br> <strong>命中协商缓存的条件是</strong>：max-age过期或使用了no-store。<br> 使用协商缓存时，先向服务器发送一个请求，若资源未发生改变，则返回一个<strong>304</strong>状态，让浏览器使用本地缓存副本；若资源发生了修改，则返回修改后的资源。<br> 协商缓存通过设置HTTP头信息中的Etag和Last-Modified属性来设置。<br> <strong>Last-Modified</strong>：是一个时间戳，服务器通过在响应头中添加Last-Modified属性来指出<strong>资源最后一次修改的时间</strong>，服务器对比时间戳和资源在服务器上最后修改时间是否一致，无法感知文件本身的变化。<br> 当浏览器第一次请求某个URL时，服务器端的返回状态是200，内容是请求的资源，同时会有一个Last-Modified的属性标记此文件在服务器端最后被修改的时间。当浏览器下一次发起请求时，会在请求头中添加一个If-Modified-Since属性，属性值为上一次资源返回时的Last-Modified的值，判断该时间后文件是否被修改过。若没有被修改过，则返回304状态码，内容为空，让客户端使用本地的缓存；如果文件已经被修改了，则返回修改后的资源。<strong>缺点</strong>是Last-Modified只能精确到秒级，如果一些文件在1s内被修改多次，那文件已经改变但Last-Modified却没有改变，会造成缓存命中的不准确。<br> <strong>Etag</strong>：服务器在返回资源的时候，在头信息中添加Etag属性，它是<strong>资源生成的唯一标识符</strong>，当资源发生改变时，这个值也会发生改变。在下一次客户端请求资源的时候，浏览器会在请求头中添加一个If-None-Match属性，它的值是上次Etag的值，服务器把该值与资源在服务器的Etag值对比，若一致则把If-None-Match的值设置为false，返回304，代表资源无更新，继续使用缓存文件；不一致则重新返回资源文件，状态码为200，将If-None-Match的值设置为true。<br> <strong>协商缓存步骤</strong>：</p><ol><li>客户端请求一个页面（A）。</li><li>服务器返回页面A，并在给A加上一个Last-Modified&#x2F;ETag。</li><li>客户端展现该页面，并将页面连同Last-Modified&#x2F;ETag一起缓存。</li><li>客户再次请求页面A，请求资源时，并将上次请求时服务器返回的Last-Modified&#x2F;ETag一起传递给服务器，服务端和最新资源做对比。</li><li>服务器检查该Last-Modified或ETag，并判断出该页面自上次客户端请求之后是否被修改。如果资源没更改，服务器返回304和一个空的响应体，浏览器读取本地缓存。如果资源有更改，返回200，服务器返回最新的资源。</li></ol><h2 id="6-3-启发式缓存"><a href="#6-3-启发式缓存" class="headerlink" title="6.3 启发式缓存"></a>6.3 启发式缓存</h2><p>当既没有设置max-age相对时间，也没有设置exprires绝对时间的时候，浏览器依然会请求缓存的内容，下次并不会直接进入协商阶段，而是先进入启发式缓存阶段。<br>启发式缓存策略，它的计算方式为根据<strong>响应头中2个时间字段Date</strong> 和 <strong>Last-Modified之间的时间差值，取其值的10%作为缓存时间周期</strong>。<br>也就是说，当存有 Last-Modified字段的时候，即使是断网，且强缓存都失效后，也有一定时间是直接读取缓存文件的。<br>etag是没有这个阶段的。</p><h1 id="★七、浏览器本地存储（cookie、localstorage、sessionstorage）"><a href="#★七、浏览器本地存储（cookie、localstorage、sessionstorage）" class="headerlink" title="★七、浏览器本地存储（cookie、localstorage、sessionstorage）"></a>★七、浏览器本地存储（cookie、localstorage、sessionstorage）</h1><h2 id="7-1-Cookie"><a href="#7-1-Cookie" class="headerlink" title="7.1 Cookie"></a>7.1 Cookie</h2><p><strong>数据的生命周期</strong>：一般由服务器生成，可设置失效时间，如果在浏览器端生成的Cookie，默认是关闭浏览器后失效。<br><strong>存放数据大小</strong>：一般为4kb。<br><strong>与服务器端通信</strong>：每次都会携带在HTTP头中，如果使用Cookie保存过多数据会带来性能问题。<br>不建议用cookie进行存储，如果没有大量数据存储需求，可以使用localstorage和sessionstorage。对于不怎么改变的数据尽力使用localstorage存储，是否可以使用sessionstorage存储。</p><p>Cookie是保存在<strong>客户端</strong>的多组记录，在客户端以文件的形式存在，与服务器进行通信时Cookie通常保存会话的Session ID等信息。</p><p><strong>Cookie特性</strong>：</p><ul><li>Cookie一旦创建成功，名称就无法修改</li><li>Cookie是无法跨域名的，也就是说a域名和b域名下的cookie是无法共享的，这也是由Cookie的隐私安全性决定的，这样就能够阻止非法获取其他网站的Cookie</li><li>每个域名下Cookie的数量不能超过20个，每个Cookie的大小不能超过4kb</li><li>有安全问题，如果Cookie被拦截了，那就可获得session的所有信息，即使加密也于事无补，无需知道cookie的意义，只要转发cookie就能达到目的</li><li>Cookie在请求一个新的页面的时候都会被发送过去。</li></ul><p><strong>Cookie包含的信息</strong>：可以记录用户ID、密码、浏览过的网页、停留的时间等信息。当你再次来到此网站时，网站通过读取你的Cookies得知你的相关信息，做出相应动作，如省去登陆。一个网站只能读取它自己放置的信息，不能读取其他网站的cookie文件，因此cookie文件还保存了host属性，即网站的域名或ip。</p><p><strong>Cookie实现跨域共享</strong>：一是使用Nginx反向代理，二是在一个站点登陆后往其它网站写Cookie，服务端的Session存储到一个结点，Cookie存储sessionId.</p><p> <strong>Cookie使用场景</strong>：最常见的就是Cookie和Session结合使用，将sessionId存储到cookie中，每次发请求都会携带这个sessionId，这样服务器端就知道是谁发起的请求，从而响应相应的信息。可以用来统计页面的点击次数。</p><p><strong>Cookie优点</strong>：给用户更人性化的使用体验，如记住密码功能；弥补了HTTP无连接特性；为站点统计访问人数提供一个依据。</p><p><strong>Cookie缺点</strong>：无法解决多人共用一台电脑的问题，带来了不安全因素；Cookie文件容易被误删除；一人使用多台电脑；Cookies欺骗，修改host文件，可以非法访问目标站点的Cookie</p><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><pre><code class="hljs js">   <span class="hljs-comment">// 获取   document.cookie</span><br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-property">cookie</span>);<br><br>   <span class="hljs-comment">// 设置     </span><br><span class="hljs-comment">//document.cookie=&quot;name=value;domain=.domain.com;path=/;expires=;&quot;</span><br><br>   <span class="hljs-variable language_">document</span>.<span class="hljs-property">cookie</span>=<span class="hljs-string">&quot;name=张三&quot;</span>;<br>   <span class="hljs-variable language_">document</span>.<span class="hljs-property">cookie</span>=<span class="hljs-string">&quot;age=20&quot;</span>;<br>   <span class="hljs-comment">// 设置有效期</span><br>   <span class="hljs-comment">// document.cookie=&quot;name=张三;expires=Mon May 09 2022 10:32:51&quot;;</span><br><br>   <span class="hljs-comment">// 设置之前的时间  删除</span><br>   <span class="hljs-comment">// document.cookie=&quot;name=张三;expires=Mon May 08 2022 10:32:51&quot;;</span><br></code></pre></td></tr></table></figure><h2 id="7-2-LocalStorage"><a href="#7-2-LocalStorage" class="headerlink" title="7.2 LocalStorage"></a>7.2 LocalStorage</h2><p><strong>数据的生命周期</strong>：除非被清除，否则永远保存。<br><strong>存放数据大小</strong>：一般为5MB。<br><strong>与服务器端通信</strong>：仅在客户端（浏览器）中保存，不参与和服务器的通信。</p><p>LocalStorage是HTML5新引入的特性，由于有时我们存储的信息较大，Cookie不能满足我们的需求。<br><strong>LocalStorage优点</strong>：大小为5MB，可以存储更多信息；是持久存储，不会随着页面的关闭而消失，除非主动清理，否则会永久存在；仅存储在本地，不像Cookie那样每次HTTP请求都会被携带。</p><p><strong>LocalStorage缺点</strong>：存在浏览器兼容问题，IE8以下浏览器不支持；如果浏览器设置为隐私模式，就无法读取到LocalStorage；LocalStorage受到同源策略的限制，端口、协议、主机地址任一不相同就不会访问。</p><p><strong>LocalStorage常用API</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 保存数据到 localStorage</span><br><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;key&#x27;</span>, <span class="hljs-string">&#x27;value&#x27;</span>);<br><span class="hljs-comment">// 从 localStorage 获取数据</span><br><span class="hljs-keyword">let</span> data = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;key&#x27;</span>);<br><span class="hljs-comment">// 从 localStorage 删除保存的数据</span><br><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">removeItem</span>(<span class="hljs-string">&#x27;key&#x27;</span>);<br><span class="hljs-comment">// 从 localStorage 删除所有保存的数据</span><br><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">clear</span>();<br><span class="hljs-comment">// 获取某个索引的Key</span><br><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">key</span>(index)<br></code></pre></td></tr></table></figure><p><strong>LocalStorage使用场景</strong>：有些网站有换肤的功能，这时候就可以将换肤的信息存储在本地的LocalStorage中，当需要换肤的时候，直接操作LocalStorage即可；在网站中的用户浏览信息也会存储在LocalStorage中，还有网站的一些不常变动的个人信息等也可以存储在本地的LocalStorage中。</p><h2 id="7-3-SessionStorage"><a href="#7-3-SessionStorage" class="headerlink" title="7.3 SessionStorage"></a>7.3 SessionStorage</h2><p><strong>数据的生命周期</strong>：仅在当前会话下有效，关闭页面或浏览器后被清除。</p><p>SessionStorage也是HTML5才提出的解决方案，主要用于临时保存同一窗口（或标签页）的数据，刷新页面时不会删除，关闭窗口或标签页后会删除这些数据。<br><strong>同源策略</strong>：浏览器打开多个标签，在执行脚本的时候会判断这个脚本是属于哪个标签的，如果与该标签同源才会执行。<br><strong>SessionStorage与LocalStorage对比</strong>：都在本地进行数据存储；SessionStorage也有同源策略的限制，但是有更加严格的限制，只有在同一浏览器的同一窗口下才能够共享；二者都不能被爬虫爬取。</p><p><strong>SessionStorage的常用API</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 保存数据到 sessionStorage</span><br>sessionStorage.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;key&#x27;</span>, <span class="hljs-string">&#x27;value&#x27;</span>);<br><span class="hljs-comment">// 从 sessionStorage 获取数据</span><br><span class="hljs-keyword">let</span> data = sessionStorage.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;key&#x27;</span>);<br><span class="hljs-comment">// 从 sessionStorage 删除保存的数据</span><br>sessionStorage.<span class="hljs-title function_">removeItem</span>(<span class="hljs-string">&#x27;key&#x27;</span>);<br><span class="hljs-comment">// 从 sessionStorage 删除所有保存的数据</span><br>sessionStorage.<span class="hljs-title function_">clear</span>();<br><span class="hljs-comment">// 获取某个索引的Key</span><br>sessionStorage.<span class="hljs-title function_">key</span>(index)<br></code></pre></td></tr></table></figure><p><strong>SessionStorage使用场景</strong>：由于它具备时效性，可以用来存储一些网站游客登陆的信息及临时的浏览记录的信息，当关闭网站之后这些信息就随之消除了。</p><h1 id="八、Cookie的字段"><a href="#八、Cookie的字段" class="headerlink" title="八、Cookie的字段"></a>八、Cookie的字段</h1><ul><li><strong>Name</strong>：Cookie的名称。</li><li><strong>value</strong>：Cookie的值，对于认证cookie，value值包括web服务器所提供的访问令牌。</li><li><strong>domain</strong>：可以访问该cookie的域名。Cookie未遵循同源策略，允许一个子域可设置或获取其父域的Cookie，需要单点登陆时该特性非常有用，但增加了Cookie受到攻击的危害，例如攻击者可以借此会话攻击。因此浏览器中禁止在该属性中设置org、com等通用顶级域名和国家及地区顶级域下注册的二级域名。<br>非顶级域名，如二级域名或者三级域名，设置的cookie的domain只能为顶级域名或者二级域名或者三级域名本身，不能设置其他二级域名的cookie，否则cookie无法生成。<br>顶级域名只能设置domain为顶级域名，不能设置为二级域名或者三级域名，否则cookie无法生成。<br>二级域名能读取设置了domain为顶级域名或者自身的cookie，不能读取其他二级域名domain的cookie。所以要想cookie在多个二级域名中共享，需要设置domain为顶级域名，这样就可以在所有二级域名里面或者到这个cookie的值了。<br>顶级域名只能获取到domain设置为顶级域名的cookie，其他domain设置为二级域名的无法获取。</li><li><strong>path</strong>：可以访问cookie的页面路径。例如domain是abc.com,path是&#x2F;test，那么只有&#x2F;test路径下的页面可以读取此cookie。 </li><li><strong>expires&#x2F;max-size</strong>：cookie超时时间，若设置其值为一个时间，当到达时间后，此cookie失效。不设置的话默认值是session，意思是cookie会和session一起失效，当浏览器关闭后，此cookie失效。</li><li><strong>Size</strong>：cookie的大小。</li><li><strong>http</strong>：包含httponly属性，该属性用来设置cookie能否通过脚本访问，默认为空（可以）。该属性用于防止客户端脚本通过document.cookie属性访问cookie。若此属性为true，则只有在http请求头中会带有此cookie的信息，而不能通过document.cookie来访问此cookie。</li><li><strong>secure</strong>：设置是否使用HTTPS安全协议发送cookie，使用安全协议可以保护cookie在浏览器和web服务器之间的传输过程中不会被窃取和篡改。</li></ul><h1 id="★九、Cookie、LocalStorage、SessionStorage区别"><a href="#★九、Cookie、LocalStorage、SessionStorage区别" class="headerlink" title="★九、Cookie、LocalStorage、SessionStorage区别"></a>★九、Cookie、LocalStorage、SessionStorage区别</h1><ul><li><strong>cookie：</strong> 其实最开始是服务器端用于记录用户状态的一种方式，由服务器设置，在客户端存储，然后每次发起同源请求时，发送给服务器端。cookie 最多能存储 4 k 数据，它的生存时间由 expires 属性指定，并且 cookie 只能被同源的页面访问共享。</li><li><strong>sessionStorage：</strong> html5 提供的一种浏览器本地存储的方法，它借鉴了服务器端session的概念，代表的是一次会话中所保存的数据。它一般能够存储 5M或者更大的数据，它在当前窗口关闭后就失效了，并且sessionStorage只能被同一个窗口的同源页面所访问共享。</li><li><strong>localStorage：</strong> html5 提供的一种浏览器本地存储的方法，它一般也能够存储 5M 或者更大的数据。它和 sessionStorage 不同的是，除非手动删除它，否则它不会失效，并且 localStorage 也只能被同源页面所访问共享。</li></ul><p>上面几种方式都是存储少量数据的时候的存储方式，当需要在本地存储大量数据的时候，我们可以使用浏览器的 <strong>indexDB</strong>和<strong>websql</strong> 这是浏览器提供的一种本地的数据库存储机制。它不是关系型数据库，它内部采用对象仓库的形式存储数据，它更接近 NoSQL 数据库。还有<strong>Service Worker</strong>。</p><h1 id="十、前端存储的方式"><a href="#十、前端存储的方式" class="headerlink" title="十、前端存储的方式"></a>十、前端存储的方式</h1><ul><li>cookies： 在HTML5标准前本地储存的主要⽅式，优点是兼容性好，请求头⾃带cookie⽅便，缺点是⼤⼩只有4k，⾃动请求头加⼊cookie浪费流量，每个domain限制20个cookie，使⽤起来麻烦，需要⾃⾏封装；</li><li>localStorage：HTML5加⼊的以键值对(Key-Value)为标准的⽅式，优点是操作⽅便，永久性储存（除⾮⼿动删除），⼤⼩为5M，兼容IE8+ ；</li><li>sessionStorage：与localStorage基本类似，区别是sessionStorage当⻚⾯关闭后会被清理，⽽且与cookie、localStorage不同，他不能在所有同源窗⼝中共享，是会话级别的储存⽅式；</li><li>Web SQL：2010年被W3C废弃的本地数据库数据存储⽅案，但是主流浏览器（⽕狐除外）都已经有了相关的实现，web sql类似于SQLite，是真正意义上的关系型数据库，⽤sql进⾏操作，当我们⽤JavaScript时要进⾏转换，较为繁琐；</li><li>IndexedDB： 是被正式纳⼊HTML5标准的数据库储存⽅案，它是NoSQL数据库，⽤键值对进⾏储存，可以进⾏快速读取操作，⾮常适合web场景，同时⽤JavaScript进⾏操作会⾮常便。</li></ul><h1 id="十一、IndexedDB有什么特点"><a href="#十一、IndexedDB有什么特点" class="headerlink" title="十一、IndexedDB有什么特点"></a>十一、IndexedDB有什么特点</h1><p>它是一种在浏览器端存储数据的方式，是本地存储。</p><ul><li><strong>键值对储存</strong>：IndexedDB 内部采用对象仓库存放数据。所有类型的数据都可以直接存入，包括 JavaScript 对象。对象仓库中，数据以”键值对”的形式保存，每一个数据记录都有对应的主键，主键是独一无二的，不能有重复，否则会抛出一个错误。</li><li><strong>异步</strong>：IndexedDB 操作时不会锁死浏览器，用户依然可以进行其他操作，这与LocalStorage形成对比，后者的操作是同步的。异步设计是为了防止大量数据的读写，拖慢网页的表现。</li><li><strong>支持事务</strong>：IndexedDB 支持事务（transaction），这意味着一系列操作步骤之中，只要有一步失败，整个事务就都取消，数据库回滚到事务发生之前的状态，不存在只改写一部分数据的情况。</li><li><strong>同源限制：</strong> IndexedDB受到同源限制，每一个数据库对应创建它的域名。网页只能访问自身域名下的数据库，而不能访问跨域的数据库。</li><li><strong>储存空间大</strong>：IndexedDB 的储存空间比 LocalStorage 大得多，一般来说不少于 250MB，甚至没有上限。</li><li><strong>支持二进制储存</strong>：IndexedDB 不仅可以储存字符串，还可以储存二进制数据（ArrayBuffer 对象和 Blob 对象）。</li></ul><h1 id="十二、session和cookie区别"><a href="#十二、session和cookie区别" class="headerlink" title="十二、session和cookie区别"></a>十二、session和cookie区别</h1><ul><li>保存位置不同：cookie保存在浏览器端，session保存在服务端。</li><li>使用方式不同：cookie如果在浏览器端设置对应的时间，cookie保存在本地硬盘中，若没有过期就可以使用，过期就会删除，如果没有对cookie设置时间，则默认关闭浏览器后cookie就会被删除。session在发送的请求中如果sessionId，就会找到对应的session独享，如果不存在sessionId，服务器就会创建一个session对象，并且将sessionId返回给浏览器，可以将其放到cookie中进行传输，若浏览器不支持cookie就会通过encodeURL进行调用，然后放到url中。</li><li>存储内容不同：cookie只能存储字符串，session可以存放任何类型。</li><li>存储大小不同：cookie最多可以存放4k大小的内容，session没有限制。</li><li>安全性：session更高。</li><li>应用场景：cookie用来保存用户的登陆信息，如果删除cookie下次用户仍需重新登陆。session拿到的是我们的个人信息，一般可以存放个人的信息或购物车的信息。</li><li>弊端：cookie大小受限制，不安全，如果用户禁用cookie就无法使用cookie。如果过多的依赖session，当很多用户同时登陆的时候，此时服务器压力过大，sessionId存放在cookie中，此时如果一些浏览器不支持cookie，还需要改写代码将sessionId放到url中，也不安全。</li></ul><h1 id="十三、浏览器里的进程"><a href="#十三、浏览器里的进程" class="headerlink" title="十三、浏览器里的进程"></a>十三、浏览器里的进程</h1><p>浏览器包括一个浏览器主进程、一个GPU进程，多个渲染进程和多个插件进程。</p><ul><li><strong>浏览器进程</strong>：主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。</li><li><strong>渲染进程</strong>：核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。</li><li><strong>GPU 进程</strong>：其实， GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。</li><li><strong>网络进程</strong>：主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。</li><li><strong>插件进程</strong>：主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。<br>所以，<strong>打开一个网页，最少需要四个进程</strong>：1 个网络进程、1 个浏览器进程、1 个 GPU 进程以及 1 个渲染进程。如果打开的页面有运行插件的话，还需要再加上 1 个插件进程。<br>虽然多进程模型提升了浏览器的稳定性、流畅性和安全性，但同样不可避免地带来了一些问题：</li><li><strong>更高的资源占用</strong>：因为每个进程都会包含公共基础结构的副本（如 JavaScript 运行环境），这就意味着浏览器会消耗更多的内存资源。</li><li><strong>更复杂的体系架构</strong>：浏览器各模块之间耦合性高、扩展性差等问题，会导致现在的架构已经很难适应新的需求了。</li></ul><h1 id="十四、浏览器渲染进程的线程"><a href="#十四、浏览器渲染进程的线程" class="headerlink" title="十四、浏览器渲染进程的线程"></a>十四、浏览器渲染进程的线程</h1><ol><li><strong>GUI渲染线程</strong>：负责渲染浏览器页面，解析HTML、CSS，构建DOM树、构建CSSOM树、构建渲染树和绘制页面；当界面需要<strong>重绘</strong>或由于某种操作引发<strong>回流</strong>时，该线程就会执行。<br>注意：GUI渲染线程和JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起，GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。</li><li><strong>JS引擎线程</strong>：也称为JS内核，负责处理Javascript脚本程序，解析Javascript脚本，运行代码；JS引擎线程一直等待着任务队列中任务的到来，然后加以处理，一个Tab页中无论什么时候都只有一个JS引擎线程在运行JS程序；<br>注意：GUI渲染线程与JS引擎线程的互斥关系，所以如果JS执行的时间过长，会造成页面的渲染不连贯，导致页面渲染加载阻塞。</li><li><strong>时间触发线程</strong>：属于浏览器而不是JS引擎，用来控制事件循环；当JS引擎执行代码块如setTimeOut时（也可是来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件触发线程中；当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理；<br>注意：由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）；</li><li><strong>定时器触发进程</strong>：即setInterval与setTimeout所在线程；浏览器定时计数器并不是由JS引擎计数的，因为JS引擎是单线程的，如果处于阻塞线程状态就会影响记计时的准确性；因此使用单独线程来计时并触发定时器，计时完毕后，添加到事件队列中，等待JS引擎空闲后执行，所以定时器中的任务在设定的时间点不一定能够准时执行，定时器只是在指定时间点将任务添加到事件队列中；<br>注意：W3C在HTML标准中规定，定时器的定时时间不能小于4ms，如果是小于4ms，则默认为4ms。</li><li><strong>异步HTTP请求线程</strong>：XMLHttpRequest连接后通过浏览器新开一个线程请求；检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将回调函数放入事件队列中，等待JS引擎空闲后执行；</li></ol><h1 id="十五、Service-Worker"><a href="#十五、Service-Worker" class="headerlink" title="十五、Service Worker"></a>十五、Service Worker</h1><p>Service Worker 是运行在浏览器背后的<strong>独立线程</strong>，一般可以用来实现缓存功能。使用 Service Worker的话，传输协议必须为 <strong>HTTPS</strong>。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。</p><p>Service Worker 实现缓存功能一般分为三个步骤：首先需要先注册 Service Worker，然后监听到install事件以后就可以缓存需要的文件，那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。以下是这个步骤的实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// index.js</span><br><span class="hljs-keyword">if</span> (navigator.<span class="hljs-property">serviceWorker</span>) &#123;<br>  navigator.<span class="hljs-property">serviceWorker</span><br>    .<span class="hljs-title function_">register</span>(<span class="hljs-string">&#x27;sw.js&#x27;</span>)<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">registration</span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;service worker 注册成功&#x27;</span>)<br>    &#125;)<br>    .<span class="hljs-title function_">catch</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;servcie worker 注册失败&#x27;</span>)<br>    &#125;)<br>&#125;<br><span class="hljs-comment">// sw.js</span><br><span class="hljs-comment">// 监听 `install` 事件，回调中缓存所需文件</span><br>self.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;install&#x27;</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;<br>  e.<span class="hljs-title function_">waitUntil</span>(<br>    caches.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;my-cache&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">cache</span>) &#123;<br>      <span class="hljs-keyword">return</span> cache.<span class="hljs-title function_">addAll</span>([<span class="hljs-string">&#x27;./index.html&#x27;</span>, <span class="hljs-string">&#x27;./index.js&#x27;</span>])<br>    &#125;)<br>  )<br>&#125;)<br><span class="hljs-comment">// 拦截所有请求事件</span><br><span class="hljs-comment">// 如果缓存中已经有请求的数据就直接用缓存，否则去请求数据</span><br>self.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;fetch&#x27;</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;<br>  e.<span class="hljs-title function_">respondWith</span>(<br>    caches.<span class="hljs-title function_">match</span>(e.<span class="hljs-property">request</span>).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">response</span>) &#123;<br>      <span class="hljs-keyword">if</span> (response) &#123;<br>        <span class="hljs-keyword">return</span> response<br>      &#125;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;fetch source&#x27;</span>)<br>    &#125;)<br>  )<br>&#125;)<br></code></pre></td></tr></table></figure><p>打开页面，可以在开发者工具中的Application看到Service Worker已经启动了。在 Cache 中也可以发现所需的文件已被缓存。</p><p>它是一个服务器与浏览器之间的中间人角色，如果网站中注册了service worker那么它可以拦截当前网站所有的请求，进行判断（需要编写相应的判断程序），如果需要向服务器发起请求的就转给服务器，如果可以直接使用缓存的就直接返回缓存不再转给服务器。从而大大提高浏览体验。</p><p>它<strong>本质上也是浏览器缓存资源用的</strong>，是基于h5的web worker，不会阻碍当前js线程的执行。可以在F12开发者工具的Application中查看。<br>被Service worker缓存的文件，可以在network中看到size项为from Service Worker。也可以在Application的Cache Storage中查看缓存具体内容。</p><p> 它是<strong>基于HTTPS</strong>的，因为涉及到请求拦截。<br><strong>使用方式</strong>：</p><img src="/2022/08/11/html%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9F%A5%E8%AF%86/%E5%91%A8%E6%9C%9F.png" class=""> <p>①在代码中<strong>注册sw</strong>，通知浏览器为该页面分配一块内存，然后sw就会进入安装阶段。由于sw会监听和代理所有的请求，所以sw的作用域就显得额外的重要了，比如说我们只想监听我们专题页的所有请求，就在注册时指定路径。<br>②<strong>安装</strong>阶段installing：注册后，浏览器就会开始安装sw，可以通过事件监听。安装时，sw就开始缓存文件了，会检查所有文件的缓存状态，如果都已经缓存了，则安装成功，进入下一阶段。<br>③<strong>activated阶段</strong>：如果是第一次加载sw，在安装后，会直接进入activated阶段，如果sw进行更新，会比较复杂。<br>首先老的sw为A，新的sw版本为B。B进入install阶段，而A还处于工作状态，所以B进入waiting阶段。只有等到A被terminated后，B才能正常替换A的工作。<br><strong>terminated时机有几种方式</strong>：<br>1.关闭浏览器一段时间。<br>2.手动清除Service Worker。<br>3.在sw安装时直接跳过waiting阶段。<br>然后就进入了activated阶段，激活sw工作。<br>这个阶段可以做很多有意义的事情，比如更新存储在cache中的key和value。<br>④<strong>idle</strong>：空闲状态，一般不可见，这种说明sw的事情都处理完毕了，处于闲置状态了，浏览器会周期性的轮询，去释放处于idle的sw占用的资源。<br>⑤<strong>fetch</strong>：是sw最关键的阶段，用于拦截代理所有指定的请求，并进行对应的操作。所有的缓存部分，都是在这个阶段。<br><strong>策略</strong>：优先在cache中寻找资源，如果找不到再请求资源。</p><h1 id="十六、同源与跨域"><a href="#十六、同源与跨域" class="headerlink" title="十六、同源与跨域"></a>十六、同源与跨域</h1><p><strong>同源策略</strong>：限制了从同一个源加载的文档或脚本如何与另一个源的资源进行交互，这是一个浏览器用于隔离潜在恶意文件的重要安全机制，主要防止<strong>CSRF</strong>攻击。<br><strong>protocal协议、domain域名、port端口三者必须一致</strong>，即使两个不同的域名指向同一个ip地址，也不是同源。主要目的是为了保证用户的信息安全，它只是对 js 脚本的一种限制，并不是对浏览器的限制，对于一般的 img、或者script 脚本请求都不会有跨域的限制，这是因为这些操作都不会通过响应结果来进行可能出现安全问题的操作。</p><p><strong>同源政策主要限制了三个方面：</strong></p><ul><li>当前域下的 js 脚本不能够访问其他域下的 cookie、localStorage 和 indexDB。</li><li>当前域下的 js 脚本不能够操作访问操作其他域下的 DOM。</li><li>当前域下 ajax 无法发送跨域请求。</li></ul><h2 id="16-1-为什么会出现跨域问题"><a href="#16-1-为什么会出现跨域问题" class="headerlink" title="16.1 为什么会出现跨域问题"></a>16.1 为什么会出现跨域问题</h2><p>出于浏览器的同源策略限制，浏览器会拒绝跨域请求。严格来说，浏览器并不是拒绝所有的跨域请求，实际上拒绝的是跨域的读操作。<br><strong>浏览器的同源限制策略是这样执行的</strong>：</p><ul><li>通常浏览器允许进行跨域写操作，如链接，重定向；</li><li>通常浏览器允许跨域资源嵌入，如 img、script 标签；</li><li>通常浏览器不允许跨域读操作。<br><strong>什么情况视为跨域</strong>：非同源请求，同源是指如果两个页面拥有相同的协议、端口和主机，那么这个两个页面就属于同源。<br><strong>为什么会有跨域请求</strong>：工程服务化后，不同职责的服务分散在不同的工程中，往往这些工程的域名是不同的，但一个需求可能需要对应多个服务，这是便需要调用不同服务的接口，因此会出现跨域。</li></ul><h2 id="16-2-JSONP"><a href="#16-2-JSONP" class="headerlink" title="16.2 JSONP"></a>16.2 JSONP</h2><p>为了减轻web服务器负载，把js、css、img等静态资源分离到另一台独立域名的服务器上，在html页面中再通过相应的标签从不同域名下加载静态资源，而被浏览器允许。可以动态创建script，再请求一个带参网址实现跨域通信。<br><strong>jsonp</strong>的原理就是利用标签没有跨域限制，通过’script’标签src属性，发送带有callback参数的请求，服务端将接口返回数据拼凑到callback函数中，返回给浏览器，浏览器解析执行，拿到callback的函数返回的数据。script天生可以跨域，用它加载另一个域的JSON数据，加载完成后自动运行一个回调函数通知调用者。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> script = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;script&#x27;</span>);</span><br><span class="language-javascript">    script.<span class="hljs-property">type</span> = <span class="hljs-string">&#x27;text/javascript&#x27;</span>;</span><br><span class="language-javascript">    <span class="hljs-comment">// 传参一个回调函数名给后端，方便后端返回时执行这个在前端定义的回调函数</span></span><br><span class="language-javascript">    script.<span class="hljs-property">src</span> = <span class="hljs-string">&#x27;http://www.domain2.com:8080/login?user=admin&amp;callback=handleCallback&#x27;</span>;</span><br><span class="language-javascript">    <span class="hljs-variable language_">document</span>.<span class="hljs-property">head</span>.<span class="hljs-title function_">appendChild</span>(script);</span><br><span class="language-javascript">    <span class="hljs-comment">// 回调执行函数</span></span><br><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleCallback</span>(<span class="hljs-params">res</span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-title function_">alert</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(res));</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"> </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>服务端</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">handleCallback</span>(&#123;<span class="hljs-string">&quot;success&quot;</span>: <span class="hljs-literal">true</span>, <span class="hljs-string">&quot;user&quot;</span>: <span class="hljs-string">&quot;admin&quot;</span>&#125;)<br></code></pre></td></tr></table></figure><p><strong>Vue的axios实现</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">this</span>.<span class="hljs-property">$http</span> = axios;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">$http</span>.<span class="hljs-title function_">jsonp</span>(<span class="hljs-string">&#x27;http://www.domain2.com:8080/login&#x27;</span>, &#123;<br>    <span class="hljs-attr">params</span>: &#123;&#125;,<br>    <span class="hljs-attr">jsonp</span>: <span class="hljs-string">&#x27;handleCallback&#x27;</span><br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);<br>&#125;)<br></code></pre></td></tr></table></figure><p>后端node.js代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> querystring = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;querystring&#x27;</span>);<br><span class="hljs-keyword">var</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>);<br><span class="hljs-keyword">var</span> server = http.<span class="hljs-title function_">createServer</span>();<br>server.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;request&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) &#123;<br>    <span class="hljs-keyword">var</span> params = querystring.<span class="hljs-title function_">parse</span>(req.<span class="hljs-property">url</span>.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;?&#x27;</span>)[<span class="hljs-number">1</span>]);<br>    <span class="hljs-keyword">var</span> fn = params.<span class="hljs-property">callback</span>;<br>    <span class="hljs-comment">// jsonp返回设置</span><br>    res.<span class="hljs-title function_">writeHead</span>(<span class="hljs-number">200</span>, &#123; <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;text/javascript&#x27;</span> &#125;);<br>    res.<span class="hljs-title function_">write</span>(fn + <span class="hljs-string">&#x27;(&#x27;</span> + <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(params) + <span class="hljs-string">&#x27;)&#x27;</span>);<br>    res.<span class="hljs-title function_">end</span>();<br>&#125;);<br>server.<span class="hljs-title function_">listen</span>(<span class="hljs-string">&#x27;8080&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Server is running at port 8080...&#x27;</span>);<br></code></pre></td></tr></table></figure><p><strong>优点</strong>：兼容性好。<br><strong>缺点</strong>：只支持get请求；不安全，可能会遭到XSS攻击，XMLHttpRequest相对于JSONP有更好的错误处理机制。</p><h2 id="16-3-CORS跨域资源共享"><a href="#16-3-CORS跨域资源共享" class="headerlink" title="16.3 CORS跨域资源共享"></a>16.3 CORS跨域资源共享</h2><p>跨域资源共享允许运行在一个域上的web应用访问来自不同源服务器上的指定资源，当一个资源从与该资源本身所在的服务器不同的域、协议或端口请求一个资源时，浏览器向跨域服务器发送XMLHttpRequest请求，克服了AJAX只能同源使用的策略。<br>CORS需要浏览器和服务器同时支持，整个CORS过程都是浏览器完成的，无需用户参与，实现CORS的关键就是服务器，只要服务器实现了CORS请求就可以跨源通信了。服务器设置Access-Control-Allow-Origin就可以开启CORS，该属性表示哪些域名可以访问资源，若设置通配符则表示所有网站都可以访问资源。<br>浏览器将CORS分为<strong>简单请求</strong>和<strong>非简单请求</strong>，简单请求不会出发CORS预检请求。</p><h3 id="1、简单请求"><a href="#1、简单请求" class="headerlink" title="1、简单请求"></a>1、简单请求</h3><p><strong>判断方法</strong>：</p><ol><li>请求是HEAD、GET或POST。</li><li>HTTP请求头信息不超过这些字段：Accept、Accept-Language、Content-Language、Last-Event-ID、Content-Type只限于三个值application&#x2F;x-www-from-urlencoded、multipart&#x2F;form-data、text&#x2F;plain。<br><strong>简单请求过程</strong>：对于简单请求，浏览器会直接发出CORS请求，它会在请求的头信息中增加一个Orign字段，该字段用来说明本次请求来自哪个源（协议+端口+域名），服务器会根据这个值来决定是否同意这次请求。如果Orign指定的域名在许可范围之内，服务器返回的响应就会多出以下信息头：</li></ol><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">Access-Control-Allow-Origin</span><span class="hljs-punctuation">: </span>http://api.bob.com  // 和Orign一致<br><span class="hljs-attribute">Access-Control-Allow-Credentials</span><span class="hljs-punctuation">: </span>true   // 表示是否允许发送Cookie<br><span class="hljs-attribute">Access-Control-Expose-Headers</span><span class="hljs-punctuation">: </span>FooBar   // 指定返回其他字段的值<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>text/html; charset=utf-8   // 表示文档类型<br></code></pre></td></tr></table></figure><p>如果Orign指定的域名不在许可范围之内，服务器会返回一个正常的HTTP回应，浏览器发现没有上面的Access-Control-Allow-Origin头部信息，就知道出错了。这个错误无法通过状态码识别，因为返回的状态码可能是200。<br><strong>在简单请求服务器的响应报文中，设置字段Access-Control-Allow-Origin</strong>，表明该资源可以被任意外域访问。</p><h3 id="2、非简单请求"><a href="#2、非简单请求" class="headerlink" title="2、非简单请求"></a>2、非简单请求</h3><p>非简单请求对服务器有特殊的要求，请求方法必须是PUT、DELETE、CONNECT、OPTIONS、TRACE、PATCH。<strong>非简单请求的CORS请求会在正式通信之前进行一次HTTP查询请求，称为预检请求</strong>。<br>浏览器会询问服务器，当前所在的网页是否在服务器允许访问的范围内，以及可以使用哪些HTTP请求方式和头信息字段，只有得到肯定的回复，才会进行正式的HTTP请求，否则就会报错。<br><strong>预检请求</strong>使用的请求方法是OPTIONS，表示这个请求是来询问的。它的头信息中的关键字段是<strong>Origin</strong>，表示请求来自哪个源，除此之外还包括两个字段：<br><strong>Access-Control-Request-Method</strong>：该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法。<br><strong>Access-Control-Request-Headers</strong>： 该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，服务器据此决定该实际请求是否被允许。<br>服务器在收到浏览器的预检请求之后，会根据头信息的三个字段来进行判断，如果返回的头信息在中有<strong>Access-Control-Allow-Origin</strong>这个字段就是允许跨域请求，如果没有，就是不同意这个预检请求，就会报错。<br>服务器回应的CORS字段如下：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">Access-Control-Allow-Origin</span><span class="hljs-punctuation">: </span>http://api.bob.com  // 允许跨域的源地址<br><span class="hljs-attribute">Access-Control-Allow-Methods</span><span class="hljs-punctuation">: </span>GET, POST, PUT // 服务器支持的所有跨域请求的方法<br><span class="hljs-attribute">Access-Control-Allow-Headers</span><span class="hljs-punctuation">: </span>X-Custom-Header  // 服务器支持的所有头信息字段<br><span class="hljs-attribute">Access-Control-Allow-Credentials</span><span class="hljs-punctuation">: </span>true   // 表示是否允许发送Cookie<br><span class="hljs-attribute">Access-Control-Max-Age</span><span class="hljs-punctuation">: </span>1728000  // 用来指定本次预检请求的有效期，单位为秒<br></code></pre></td></tr></table></figure><p>只要服务器通过了预检请求，在以后每次的CORS请求都会自带一个Origin头信息字段。服务器的回应，也都会有一个Access-Control-Allow-Origin头信息字段。<br><strong>减少OPTIONS请求次数</strong>：OPTIONS请求次数过多就会损耗页面加载的性能，降低用户体验度。所以尽量要减少OPTIONS请求次数，可以后端在请求的返回头部添加：Access-Control-Max-Age：number。它表示预检请求的返回结果可以被缓存多久，单位是秒。该字段只对完全一样的URL的缓存设置生效，所以设置了缓存时间，在这个时间范围内，再次发送请求就不需要进行预检请求了。<br><strong>若想要传递Cookie</strong>：<br>1、在请求中设置 withCredentials，默认情况下在跨域请求，浏览器是不带 cookie 的。但是我们可以通过设置 withCredentials 来进行传递 cookie。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 原生 xml 的设置方式</span><br><span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br>xhr.<span class="hljs-property">withCredentials</span> = <span class="hljs-literal">true</span>;<br><span class="hljs-comment">// axios 设置方式</span><br>axios.<span class="hljs-property">defaults</span>.<span class="hljs-property">withCredentials</span> = <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure><p>2、Access-Control-Allow-Credentials 设置为 true<br>3、Access-Control-Allow-Origin 设置为非 *。</p><h2 id="16-4-document-domain-iframe"><a href="#16-4-document-domain-iframe" class="headerlink" title="16.4 document.domain+iframe"></a>16.4 document.domain+iframe</h2><p>只能用于二级域名相同的情况下，仅限主域相同，子域不同的跨域应用场景，如<br>a.test.com 和 b.test.com 适用于该方式。实现原理是给两个页面都通过js强制设置document.domain为基础主域，就实现了同域。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 父窗口 domain.com/a.html --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;iframe&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://child.domain.com/b.html&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-variable language_">document</span>.<span class="hljs-property">domain</span> = <span class="hljs-string">&#x27;a.com&#x27;</span>;</span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> user = <span class="hljs-string">&#x27;admin&#x27;</span>;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 子窗口 child.domain.com/a.html --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-variable language_">document</span>.<span class="hljs-property">domain</span> = <span class="hljs-string">&#x27;domain.com&#x27;</span>;</span><br><span class="language-javascript">    <span class="hljs-comment">// 获取父窗口中变量</span></span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;get js data from parent ---&gt; &#x27;</span> + <span class="hljs-variable language_">window</span>.<span class="hljs-property">parent</span>.<span class="hljs-property">user</span>);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="16-5-postMessage"><a href="#16-5-postMessage" class="headerlink" title="16.5 postMessage"></a>16.5 postMessage</h2><p>可以解决这些问题：页面和其打开的新窗口的数据传递、多窗口之间的消息传递、页面与嵌套的iframe消息传递、上面三个场景的跨域数据传递。<br>postMessage(data,origin)方法接收两个参数：<br><strong>data</strong>：具体的信息内容，htm5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，传参时最好用JSON.stringify()序列化。<br><strong>origin</strong>：接收消息的窗口的源，即协议+域名+端口号，也可以设置为’*’，表示不限制域名，可以传递给任意窗口，如果要指定和当前窗口同源的话设置为“&#x2F;”。<br>通常用于获取嵌入页面中的第三方页面数据，一个页面发送信息，另一个页面判断来源并接收消息。<br><strong>a.html：(domain1.com&#x2F;a.html)</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;iframe&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://www.domain2.com/b.html&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;display:none;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript">      </span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> iframe = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;iframe&#x27;</span>);</span><br><span class="language-javascript">    iframe.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-keyword">var</span> data = &#123;</span><br><span class="language-javascript">            <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;aym&#x27;</span></span><br><span class="language-javascript">        &#125;;</span><br><span class="language-javascript">        <span class="hljs-comment">// 向domain2传送跨域数据</span></span><br><span class="language-javascript">        iframe.<span class="hljs-property">contentWindow</span>.<span class="hljs-title function_">postMessage</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(data), <span class="hljs-string">&#x27;http://www.domain2.com&#x27;</span>);</span><br><span class="language-javascript">    &#125;;</span><br><span class="language-javascript">    <span class="hljs-comment">// 接受domain2返回数据</span></span><br><span class="language-javascript">    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;data from domain2 ---&gt; &#x27;</span> + e.<span class="hljs-property">data</span>);</span><br><span class="language-javascript">    &#125;, <span class="hljs-literal">false</span>);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>b.html：(domain2.com&#x2F;b.html)</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 接收domain1的数据</span></span><br><span class="language-javascript">    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;data from domain1 ---&gt; &#x27;</span> + e.<span class="hljs-property">data</span>);</span><br><span class="language-javascript">        <span class="hljs-keyword">var</span> data = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(e.<span class="hljs-property">data</span>);</span><br><span class="language-javascript">        <span class="hljs-keyword">if</span> (data) &#123;</span><br><span class="language-javascript">            data.<span class="hljs-property">number</span> = <span class="hljs-number">16</span>;</span><br><span class="language-javascript">            <span class="hljs-comment">// 处理后再发回domain1</span></span><br><span class="language-javascript">            <span class="hljs-variable language_">window</span>.<span class="hljs-property">parent</span>.<span class="hljs-title function_">postMessage</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(data), <span class="hljs-string">&#x27;http://www.domain1.com&#x27;</span>);</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">    &#125;, <span class="hljs-literal">false</span>);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="16-6-nginx代理跨域"><a href="#16-6-nginx代理跨域" class="headerlink" title="16.6 nginx代理跨域"></a>16.6 nginx代理跨域</h2><p>主要是通过配置文件设置请求响应头实现。<br><strong>nginx配置解决iconfont跨域</strong>：浏览器跨域访问js、css、img等常规静态资源被同源策略许可，但iconfont字体文件例外，可以在nginx服务器中加入以下配置：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-keyword">location</span> <span class="hljs-title">/ &#123;</span><br><span class="hljs-title"> add_header</span> Access-Control-Allow-Origin *;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>nginx反向代理接口跨域</strong>：<br>跨域原理：同源策略是浏览器的安全策略，不是HTTP协议的一部分。服务器端调用HTTP接口只是使用HTTP协议，不会执行JS脚本，不需要同源策略，也就不存在跨越问题。<br>实现思路：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;<br>    <span class="hljs-attribute">listen</span>       <span class="hljs-number">81</span>;<br>    <span class="hljs-attribute">server_name</span>  www.domain1.com;<br>    <span class="hljs-section">location</span> / &#123;<br>        <span class="hljs-attribute">proxy_pass</span>   http://www.domain2.com:8080;  <span class="hljs-comment">#反向代理</span><br>        <span class="hljs-attribute">proxy_cookie_domain</span> www.domain2.com www.domain1.com; <span class="hljs-comment">#修改cookie里域名</span><br>        <span class="hljs-attribute">index</span>  index.html index.htm;<br>        <span class="hljs-comment"># 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用</span><br>        <span class="hljs-attribute">add_header</span> Access-Control-Allow-Origin http://www.domain1.com;  <span class="hljs-comment">#当前端只跨域不带cookie时，可为*</span><br>        <span class="hljs-attribute">add_header</span> Access-Control-Allow-Credentials <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="16-7-websocket"><a href="#16-7-websocket" class="headerlink" title="16.7 websocket"></a>16.7 websocket</h2><p>Websocket实现了浏览器与服务器之间的全双工通信，允许跨域通讯。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br> <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">  高级api  不兼容  但是有一个socket.io这个库，是兼容的(一般用这个)</span><br><span class="hljs-comment">  --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">   <span class="hljs-keyword">let</span> socket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocket</span>(<span class="hljs-string">&quot;ws://localhost:3000&quot;</span>);<span class="hljs-comment">//ws协议是webSocket自己创造的</span></span><br><span class="language-javascript">   socket.<span class="hljs-property">onopen</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">    socket.<span class="hljs-title function_">send</span>(<span class="hljs-string">&quot;我叫俞华&quot;</span>);</span><br><span class="language-javascript">   &#125;</span><br><span class="language-javascript">   socket.<span class="hljs-property">onmessage</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)&#123;</span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e.<span class="hljs-property">data</span>);<span class="hljs-comment">//你好,我叫俞华！</span></span><br><span class="language-javascript">   &#125;</span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="16-8-nodejs中间件代理跨域"><a href="#16-8-nodejs中间件代理跨域" class="headerlink" title="16.8 nodejs中间件代理跨域"></a>16.8 nodejs中间件代理跨域</h2><p>node中间件实现跨域代理，原理大致与nginx相同，都是通过启一个代理服务器，实现数据的转发，也可以通过设置cookieDomainRewrite参数修改响应头中cookie中域名，实现当前域的cookie写入，方便接口登录认证。<br><strong>非VUE框架</strong>：使用node + express + http-proxy-middleware搭建一个proxy服务器。<br>前端：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br><span class="hljs-comment">// 前端开关：浏览器是否读写cookie</span><br>xhr.<span class="hljs-property">withCredentials</span> = <span class="hljs-literal">true</span>;<br><span class="hljs-comment">// 访问http-proxy-middleware代理服务器</span><br>xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;get&#x27;</span>, <span class="hljs-string">&#x27;http://www.domain1.com:3000/login?user=admin&#x27;</span>, <span class="hljs-literal">true</span>);<br>xhr.<span class="hljs-title function_">send</span>();<br></code></pre></td></tr></table></figure><p>中间键服务器：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-keyword">var</span> proxy = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http-proxy-middleware&#x27;</span>);<br><span class="hljs-keyword">var</span> app = <span class="hljs-title function_">express</span>();<br>app.<span class="hljs-title function_">use</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-title function_">proxy</span>(&#123;<br>    <span class="hljs-comment">// 代理跨域目标接口</span><br>    <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;http://www.domain2.com:8080&#x27;</span>,<br>    <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-comment">// 修改响应头信息，实现跨域并允许带cookie</span><br>    <span class="hljs-attr">onProxyRes</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">proxyRes, req, res</span>) &#123;<br>        res.<span class="hljs-title function_">header</span>(<span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="hljs-string">&#x27;http://www.domain1.com&#x27;</span>);<br>        res.<span class="hljs-title function_">header</span>(<span class="hljs-string">&#x27;Access-Control-Allow-Credentials&#x27;</span>, <span class="hljs-string">&#x27;true&#x27;</span>);<br>    &#125;,<br>    <span class="hljs-comment">// 修改响应信息中的cookie域名</span><br>    <span class="hljs-attr">cookieDomainRewrite</span>: <span class="hljs-string">&#x27;www.domain1.com&#x27;</span>  <span class="hljs-comment">// 可以为false，表示不修改</span><br>&#125;));<br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Proxy server is listen at port 3000...&#x27;</span>);<br></code></pre></td></tr></table></figure><p><strong>VUE框架</strong>：node + vue + webpack + webpack-dev-server搭建的项目，跨域请求接口，直接修改webpack.config.js配置。开发环境下，vue渲染服务和接口代理服务都是webpack-dev-server同一个，所以页面与代理接口之间不再跨域。<br>webpack.config.js部分配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>    <span class="hljs-attr">entry</span>: &#123;&#125;,<br>    <span class="hljs-attr">module</span>: &#123;&#125;,<br>    <span class="hljs-attr">devServer</span>: &#123;<br>        <span class="hljs-attr">historyApiFallback</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">proxy</span>: [&#123;<br>            <span class="hljs-attr">context</span>: <span class="hljs-string">&#x27;/login&#x27;</span>,<br>            <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;http://www.domain2.com:8080&#x27;</span>,  <span class="hljs-comment">// 代理跨域目标接口</span><br>            <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>,<br>            <span class="hljs-attr">secure</span>: <span class="hljs-literal">false</span>,  <span class="hljs-comment">// 当代理某些https服务报错时用</span><br>            <span class="hljs-attr">cookieDomainRewrite</span>: <span class="hljs-string">&#x27;www.domain1.com&#x27;</span>  <span class="hljs-comment">// 可以为false，表示不修改</span><br>        &#125;],<br>        <span class="hljs-attr">noInfo</span>: <span class="hljs-literal">true</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="16-9-location-hash-iframe"><a href="#16-9-location-hash-iframe" class="headerlink" title="16.9 location.hash + iframe"></a>16.9 location.hash + iframe</h2><p>实现原理：a欲与b跨域相互通信，通过中间页c来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。<br>具体实现：A域：a.html -&gt; B域：b.html -&gt; A域：c.html，a与b不同域只能通过hash值单向通信，b与c也不同域也只能单向通信，但c与a同域，所以c可通过parent.parent访问a页面所有对象。</p><ol><li>a.html：domain1.com&#x2F;a.html<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;iframe&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://www.domain2.com/b.html&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;display:none;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> iframe = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;iframe&#x27;</span>);</span><br><span class="language-javascript">    <span class="hljs-comment">// 向b.html传hash值</span></span><br><span class="language-javascript">    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        iframe.<span class="hljs-property">src</span> = iframe.<span class="hljs-property">src</span> + <span class="hljs-string">&#x27;#user=admin&#x27;</span>;</span><br><span class="language-javascript">    &#125;, <span class="hljs-number">1000</span>);</span><br><span class="language-javascript">   </span><br><span class="language-javascript">    <span class="hljs-comment">// 开放给同域c.html的回调方法</span></span><br><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">onCallback</span>(<span class="hljs-params">res</span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;data from c.html ---&gt; &#x27;</span> + res);</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li>b.html：domain2.com&#x2F;b.html<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;iframe&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://www.domain1.com/c.html&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;display:none;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> iframe = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;iframe&#x27;</span>);</span><br><span class="language-javascript">    <span class="hljs-comment">// 监听a.html传来的hash值，再传给c.html</span></span><br><span class="language-javascript">    <span class="hljs-variable language_">window</span>.<span class="hljs-property">onhashchange</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        iframe.<span class="hljs-property">src</span> = iframe.<span class="hljs-property">src</span> + location.<span class="hljs-property">hash</span>;</span><br><span class="language-javascript">    &#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li>c.html：domain1.com&#x2F;c.html<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 监听b.html传来的hash值</span></span><br><span class="language-javascript">    <span class="hljs-variable language_">window</span>.<span class="hljs-property">onhashchange</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-comment">// 再通过操作同域a.html的js回调，将结果传回</span></span><br><span class="language-javascript">        <span class="hljs-variable language_">window</span>.<span class="hljs-property">parent</span>.<span class="hljs-property">parent</span>.<span class="hljs-title function_">onCallback</span>(<span class="hljs-string">&#x27;hello: &#x27;</span> + location.<span class="hljs-property">hash</span>.<span class="hljs-title function_">replace</span>(<span class="hljs-string">&#x27;#user=&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>));</span><br><span class="language-javascript">    &#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="16-10-window-name-iframe"><a href="#16-10-window-name-iframe" class="headerlink" title="16.10 window.name + iframe"></a>16.10 window.name + iframe</h2>window.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。</li><li>a.html：domain1.com&#x2F;a.html<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> proxy = <span class="hljs-keyword">function</span>(<span class="hljs-params">url, callback</span>) &#123;<br>    <span class="hljs-keyword">var</span> state = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">var</span> iframe = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;iframe&#x27;</span>);<br>    <span class="hljs-comment">// 加载跨域页面</span><br>    iframe.<span class="hljs-property">src</span> = url;<br>    <span class="hljs-comment">// onload事件会触发2次，第1次加载跨域页，并留存数据于window.name</span><br>    iframe.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">if</span> (state === <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-comment">// 第2次onload(同域proxy页)成功后，读取同域window.name中数据</span><br>            <span class="hljs-title function_">callback</span>(iframe.<span class="hljs-property">contentWindow</span>.<span class="hljs-property">name</span>);<br>            <span class="hljs-title function_">destoryFrame</span>();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (state === <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 第1次onload(跨域页)成功后，切换到同域代理页面</span><br>            iframe.<span class="hljs-property">contentWindow</span>.<span class="hljs-property">location</span> = <span class="hljs-string">&#x27;http://www.domain1.com/proxy.html&#x27;</span>;<br>            state = <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;;<br>    <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(iframe);<br>    <span class="hljs-comment">// 获取数据以后销毁这个iframe，释放内存；这也保证了安全（不被其他域frame js访问）</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">destoryFrame</span>(<span class="hljs-params"></span>) &#123;<br>        iframe.<span class="hljs-property">contentWindow</span>.<span class="hljs-property">document</span>.<span class="hljs-title function_">write</span>(<span class="hljs-string">&#x27;&#x27;</span>);<br>        iframe.<span class="hljs-property">contentWindow</span>.<span class="hljs-title function_">close</span>();<br>        <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">removeChild</span>(iframe);<br>    &#125;<br>&#125;;<br><span class="hljs-comment">// 请求跨域b页面数据</span><br><span class="hljs-title function_">proxy</span>(<span class="hljs-string">&#x27;http://www.domain2.com/b.html&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)&#123;<br>    <span class="hljs-title function_">alert</span>(data);<br>&#125;);<br></code></pre></td></tr></table></figure></li><li>proxy.html：domain1.com&#x2F;proxy.html<br>中间代理页，与a.html同域，内容为空即可。</li><li>b.html：domain2.com&#x2F;b.html<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript">    </span><br><span class="language-javascript">    <span class="hljs-variable language_">window</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;This is domain2 data!&#x27;</span>;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。</li></ol><h1 id="十七、正向代理和反向代理"><a href="#十七、正向代理和反向代理" class="headerlink" title="十七、正向代理和反向代理"></a>十七、正向代理和反向代理</h1><p><strong>正向代理</strong>：客户端想获得一个服务器的数据，但是因为种种原因无法直接获取。于是客户端设置了一个代理服务器，并且指定目标服务器，之后代理服务器向目标服务器转交请求并将获得的内容发送给客户端。这样本质上起到了对真实服务器隐藏真实客户端的目的。实现正向代理需要修改客户端，比如修改浏览器配置。<br><strong>反向代理</strong>：服务器为了能够将工作负载分不到多个服务器来提高网站性能 (负载均衡)等目的，当其受到请求后，会首先根据转发规则来确定请求应该被转发到哪个服务器上，然后将请求转发到对应的真实服务器上。这样本质上起到了对客户端隐藏真实服务器的作用。 一般使用反向代理后，需要通过修改 DNS 让域名解析到代理服务器 IP，这时浏览器无法察觉到真正服务器的存在，当然也就不需要修改配置了。<br><strong>区别</strong>：正向代理和反向代理的结构是一样的，都是 client-proxy-server 的结构，它们主要的区别就在于中间这个 proxy 是哪一方设置的。在正向代理中，proxy 是 client 设置的，用来隐藏 client；而在反向代理中，proxy 是 server 设置的，用来隐藏 server。</p><h1 id="十八、XSS攻击"><a href="#十八、XSS攻击" class="headerlink" title="十八、XSS攻击"></a>十八、XSS攻击</h1><h2 id="18-1-什么是XSS攻击"><a href="#18-1-什么是XSS攻击" class="headerlink" title="18.1 什么是XSS攻击"></a>18.1 什么是XSS攻击</h2><p>XSS（跨站脚本攻击）是一种代码注入攻击。攻击者通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行。利用这些恶意脚本，攻击者可获取用户的敏感信息如 Cookie、SessionID 等。<br><strong>XSS 的本质是：恶意代码未经过滤，与网站正常的代码混在一起；浏览器无法分辨哪些脚本是可信的，导致恶意脚本被执行。</strong><br>攻击者可以通过这种攻击方式可以进行以下操作：</p><ul><li>获取页面的数据，如DOM、cookie、localStorage；</li><li>DOS攻击，发送合理请求，占用服务器资源，从而使用户无法访问服务器；</li><li>破坏页面结构；</li><li>流量劫持（将链接指向某网站）；</li></ul><h2 id="18-2-攻击类型"><a href="#18-2-攻击类型" class="headerlink" title="18.2 攻击类型"></a>18.2 攻击类型</h2><p>XSS可以分为存储型、反射型和DOM型。</p><ul><li>存储型指的是恶意脚本会存储在目标服务器上，当浏览器请求数据时，脚本从服务器传回并执行。</li><li>反射型指的是攻击者诱导用户访问一个带有恶意代码的URL后，服务器端接收数据后处理，然后把带有恶意代码的数据发送到浏览器端，浏览器端解析这段带有 XSS 代码的数据后当做脚本执行，最终完成 XSS 攻击。</li><li>DOM 型指的通过修改页面的 DOM 节点形成的 XSS。</li></ul><h3 id="存储型-XSS-存在数据库"><a href="#存储型-XSS-存在数据库" class="headerlink" title="存储型 XSS-存在数据库"></a>存储型 XSS-存在数据库</h3><p><strong>存储型 XSS 的攻击步骤</strong>：</p><ol><li>攻击者将恶意代码提交到目标网站的数据库中。</li><li>用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在HTML 中返回给浏览器。</li><li>用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。</li><li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。<br>这种攻击常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等。</li></ol><p>首先：</p><ul><li>A : 黑客发现了浏览器有 XSS 存储型的漏洞，于是向浏览器发起恶意代码。</li><li>B：服务器将这一段恶意代码存储到了服务器中。</li><li>C：用户发现这个 website 有个地方吸引了他，但是黑客提前在这里埋了恶意代码。</li><li>D：用户读取了服务器那一段有恶意的代码。</li><li>E：浏览器执行了恶意脚本获取了用户的敏感信息</li><li>F：恶意的代码传送到了黑客的服务器里</li><li>G：黑客就可以从服务器中获取到用户的敏感信息，从而模拟用户登录这个 website</li></ul><h3 id="反射型-XSS-存在url"><a href="#反射型-XSS-存在url" class="headerlink" title="反射型 XSS-存在url"></a>反射型 XSS-存在url</h3><p><strong>反射型 XSS 的攻击步骤</strong>：</p><ol><li>攻击者构造出特殊的 URL，其中包含恶意代码。</li><li>⽤户打开带有恶意代码的URL时，⽹站服务端将恶意代码从URL中取出，拼接在 HTML 中返回给浏览器。</li><li>⽤户浏览器接收到响应后解析执⾏，混在其中的恶意代码也被执⾏。</li><li>恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。</li></ol><p>反射型 XSS 跟存储型 XSS 的<strong>区别</strong>是：存储型 XSS 的恶意代码存在数据库⾥，反射型 XSS 的恶意代码存在 URL ⾥。<br>反射型 XSS 漏洞常⻅于通过 URL 传递参数的功能，如⽹站搜索、跳转等。 由于需要⽤户主动打开恶意的 URL 才能⽣效，攻击者往往会结合多种⼿段诱导⽤户点击。</p><p>首先：</p><ul><li>C：黑客向用户发送了一个有恶意脚本的URL。</li><li>D：用户点击之后且登录了 website 。</li><li>E：服务器返回了恶意脚本的响应。</li><li>F：恶意脚本在浏览器执行之后，向黑客已经部署的服务器上发送敏感信息。</li><li>G：黑客前往黑客服务器获取到用户的敏感信息。</li><li>H：黑客获取到了用户的敏感信息。</li><li>I：黑客利用已经获取的敏感信息向 website 发起请求，伪装成用户进行非法操作。</li></ul><h3 id="DOM型-XSS"><a href="#DOM型-XSS" class="headerlink" title="DOM型 XSS"></a>DOM型 XSS</h3><p><strong>DOM 型 XSS 的攻击步骤</strong>：</p><ol><li>攻击者构造出特殊的 URL，其中包含恶意代码。</li><li>⽤户打开带有恶意代码的 URL。</li><li>⽤户浏览器接收到响应后解析执⾏，前端 JavaScript 取出 URL 中的恶意代码并执⾏。</li><li>恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。</li></ol><p>DOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执⾏恶意代码由浏览器端完成，属于前端JavaScript ⾃身的安全漏洞，⽽其他两种 XSS 都属于服务端的安全漏洞。<br>HTML注入方式有script&#x2F;图片标签&#x2F;连接标签&#x2F;head头中其他标签、iframe。<br>JS一般为使用JS代码直接引用，不经校验的字符串，解析不安全的json(p)数据<br>注入的方式分别是通用修改 DOM 节点内容，通过修改 DOM 节点属性，通过修改 JavaScript 修改和通过富文本修改。<br>1.标签：script&gt;alert(1)&lt;&#x2F;script<br>2.伪协议：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;a href=<span class="hljs-attr">javascript</span>:<span class="hljs-title function_">alert</span>(<span class="hljs-number">1</span>)&gt;test&lt;/a&gt;<br></code></pre></td></tr></table></figure><p>3.事件型：<br>事件也是可以执行JS的。在HTML里面有一些标签它拥有事件事件：当满足了条件就可以触发。例如：onerror&#x3D;alert(1)在加载文档或图像时，发生错误。《img src&#x3D;’a’ onerror&#x3D;alert(1)&#x2F;》<br>常用的有：onerror（失败加载执行）、onload(成功加载执行)、oninput(有输入框、输入的时候触发)，onfocus获取焦点。</p><h2 id="18-3-如何防御XSS攻击"><a href="#18-3-如何防御XSS攻击" class="headerlink" title="18.3 如何防御XSS攻击"></a>18.3 如何防御XSS攻击</h2><p>主要是通过防止浏览器执行恶意代码来防范XSS，包括防止HTML中出现注入和防止JS执行时执行恶意代码。</p><h3 id="预防存储型和反射型XSS攻击"><a href="#预防存储型和反射型XSS攻击" class="headerlink" title="预防存储型和反射型XSS攻击"></a>预防存储型和反射型XSS攻击</h3><p>存储型和反射型 XSS 都是在服务端取出恶意代码后，插入到响应 HTML 里的，攻击者刻意编写的“数据”被内嵌到“代码”中，被浏览器所执行。<br><strong>纯前端渲染</strong>：不使用服务器端拼接后返回（不使用服务器渲染），把代码和数据分隔开。<br>纯前端渲染的过程：</p><ol><li>浏览器先加载一个静态HTML，此HTML中不包含任何跟业务相关的数据。</li><li>然后浏览器执行HTML中的 JavaScript。</li><li>JavaScript通过Ajax加载业务数据，调用 DOM API 更新到页面上。</li></ol><p>在纯前端渲染中，我们会明确的告诉浏览器：下面要设置的内容是文本（.innerText），还是属性（.setAttribute），还是样式（.style）等等。浏览器不会被轻易的被欺骗，执行预期外的代码了。<br>但纯前端渲染还需注意避免 DOM 型 XSS 漏洞（例如 onload事件和 href中的 javascript:xxx 等）。<br>在很多内部、管理系统中，采用纯前端渲染是非常合适的。但对于性能要求高，或有 SEO 需求的页面，我们仍然要面对拼接 HTML 的问题。<br><strong>转义HTML</strong>：如果拼接HTML是必要的，就需要采用合适的转义库，对需要插入到HTML中的代码做好充分的转义。</p><h3 id="预防DOM型XSS攻击"><a href="#预防DOM型XSS攻击" class="headerlink" title="预防DOM型XSS攻击"></a>预防DOM型XSS攻击</h3><p>主要是由于前端代码不可靠造成的，<strong>对于数据获取渲染和字符拼接的时候应该对可能出现的恶意代码情况进行判断</strong>。<br>在使用 <code>.innerHTML</code>、<code>.outerHTML</code>、<code>document.write()</code> 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用 <code>.textContent</code>、<code>.setAttribute()</code> 等。<br>如果用 Vue&#x2F;React 技术栈，并且不使用 <code>v-html</code>&#x2F;<code>dangerouslySetInnerHTML</code> 功能，就在前端 render 阶段避免 <code>innerHTML</code>、<code>outerHTML</code> 的 XSS 隐患。<br>DOM 中的内联事件监听器，如 <code>location</code>、<code>onclick</code>、<code>onerror</code>、<code>onload</code>、<code>onmouseover</code> 等，<code>&lt;a&gt;</code> 标签的 <code>href</code> 属性，JavaScript 的 <code>eval()</code>、<code>setTimeout()</code>、<code>setInterval()</code> 等，都能把字符串作为代码运行。如果不可信的数据拼接到字符串中传递给这些 API，很容易产生安全隐患，请务必避免。</p><h3 id="其它方案"><a href="#其它方案" class="headerlink" title="其它方案"></a>其它方案</h3><p><strong>使用CSP</strong>，其本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行，从而防止恶意代码的注入攻击，我们只需要配置规则，如何拦截由浏览器自己实现。<br>严格的 CSP 在 XSS 的防范中可以起到以下的作用：</p><ul><li><p>禁止加载外域代码，防止复杂的攻击逻辑。</p></li><li><p>禁止外域提交，网站被攻击后，用户的数据不会泄露到外域。</p></li><li><p>禁止内联脚本执行（规则较严格，目前发现 GitHub 使用）。</p></li><li><p>禁止未授权的脚本执行（新特性，Google Map 移动版在使用）。</p></li><li><p>合理使用上报可以及时发现 XSS，利于尽快修复问题。<br>通常有两种方式来开启 CSP，一种是设置 HTTP 首部中的 Content-Security-Policy，一种是设置 meta 标签的方式。</p><p><strong>HTTP-only</strong>：给cookie使用，禁止js读取某些敏感cookie。<br><strong>验证码</strong>：防止脚本冒充用户提交危险操作。</p></li></ul><h1 id="十九、CSRF"><a href="#十九、CSRF" class="headerlink" title="十九、CSRF"></a>十九、CSRF</h1><p>CSRF（跨站请求伪造），攻击者诱导用户进入一个第三方网站，然后该网站向被攻击网站发送跨站请求。如果用户在被攻击网站中保存了登录状态，那么攻击者就可以利用这个登录状态，借助获取的注册凭证，绕过后台的用户验证，冒充用户向服务器执行一些操作。<br><strong>本质</strong>：利用 cookie 会在同源请求中携带发送给服务器的特点，以此来实现用户的冒充。<br><strong>常见流程</strong>：</p><ul><li>受害者登录a.com，并保留了登录凭证（Cookie）。</li><li>攻击者引诱受害者访问了b.com。</li><li>b.com 向 a.com 发送了一个请求：a.com&#x2F;act&#x3D;xx。浏览器会默认携带a.com的Cookie。</li><li>a.com接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求。</li><li>a.com以受害者的名义执行了act&#x3D;xx。<br>攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让a.com执行了自己定义的操作.</li></ul><p>攻击者盗用了你的身份，以你的名义进行恶意请求。它能做的事情有很多包括：以你的名义发送邮件、发信息、盗取账号、购买商品、虚拟货币转账等。总结起来就是：个人隐私暴露及财产安全问题。<br>阐述 CSRF 攻击思想：（核心2和3）</p><ul><li>1、浏览并登录信任网站（举例：淘宝）</li><li>2、登录成功后在浏览器产生信息存储（举例：cookie）</li><li>3、用户在没有登出淘宝的情况下，访问危险网站</li><li>4、危险网站中存在恶意代码，代码为发送一个恶意请求（举例：购买商品&#x2F;余额转账）</li><li>5、携带刚刚在浏览器产生的信息进行恶意请求</li><li>6、淘宝验证请求为合法请求（区分不出是否是该用户发送）</li><li>7、达到了恶意目标</li></ul><h2 id="19-1-常见CSRF攻击类型"><a href="#19-1-常见CSRF攻击类型" class="headerlink" title="19.1 常见CSRF攻击类型"></a>19.1 常见CSRF攻击类型</h2><h3 id="GET类型的CSRF"><a href="#GET类型的CSRF" class="headerlink" title="GET类型的CSRF"></a>GET类型的CSRF</h3><p>比如在网站中的一个img标签里构建一个请求，当用户打开这个网站的时候就会自动发起提交。在受害者访问含有这个img的页面后，浏览器自动向网站发送一次HTTP请求。</p><h3 id="POST类型的CSRF"><a href="#POST类型的CSRF" class="headerlink" title="POST类型的CSRF"></a>POST类型的CSRF</h3><p>比如构建一个表单，然后隐藏它，让用户进入页面时，自动提交这个表单。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"> &lt;form action=<span class="hljs-string">&quot;http://bank.example/withdraw&quot;</span> method=<span class="hljs-variable constant_">POST</span>&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;hidden&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;account&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;xiaoming&quot;</span> /&gt;</span></span><br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;hidden&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;amount&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;10000&quot;</span> /&gt;</span></span><br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;hidden&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;for&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;hacker&quot;</span> /&gt;</span></span><br>&lt;/form&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"> <span class="hljs-variable language_">document</span>.<span class="hljs-property">forms</span>[<span class="hljs-number">0</span>].<span class="hljs-title function_">submit</span>(); </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>访问该页面后，表单会自动提交，相当于模拟用户完成了一次POST操作。<br>POST类型的攻击通常比GET要求更加严格一点，任何个人网站、博客，被黑客上传页面的网站都有可能是发起攻击的来源，后端接口不能将安全寄托在仅允许POST上面。</p><h3 id="链接类型的CSRF"><a href="#链接类型的CSRF" class="headerlink" title="链接类型的CSRF"></a>链接类型的CSRF</h3><p>需要用户点击链接才会触发，诱导用户点击。例如在a标签的href属性中构建一个请求，然后诱导用户去点击。<br>由于之前用户登陆了信任的网站A，并且保存登陆状态，只要用户主动访问这个PHP页面，则表示攻击成功。</p><h2 id="19-2-如何防御CSRF攻击"><a href="#19-2-如何防御CSRF攻击" class="headerlink" title="19.2 如何防御CSRF攻击"></a>19.2 如何防御CSRF攻击</h2><p><strong>为什么token可以防御CSRF</strong>：因为token是我们主动把他放在请求头里的，而cookie是浏览器的机制，访问其他网页的时候自动把cookie带上，所以一般token都存在localstorage中而不是cookie中。这样访问黑客网站就并不能让浏览器自动把我们的token带上，这样访问A网站就不会被冒充。<br><strong>CSRF特点</strong>：通常发生在第三方域名，攻击者不能获取到Cookie信息，只是使用。<br>①<strong>阻止不明外域的访问</strong>：<br><strong>进行同源检测</strong>：服务器根据 http 请求头中 origin 或者 referer 信息来判断请求是否为允许访问的站点，从而对请求进行过滤。当 origin 或者 referer 信息都不存在的时候，直接阻止请求。这种方式的缺点是有些情况下 referer 可以被伪造，同时还会把搜索引擎的链接也给屏蔽了。所以一般网站会允许搜索引擎的页面请求，但是相应的页面请求这种请求方式也可能被攻击者给利用。（Referer 字段会告诉服务器该网页是从哪个页面链接过来的）<br><strong>给cookie设置samesite，限制cookie被第三方使用</strong>：Samesite 一共有两种模式，一种是严格模式，在严格模式下 cookie 在任何情况下都不可能作为第三方 Cookie 使用，在宽松模式下，cookie 可以被请求是 GET 请求，且会发生页面跳转的请求所使用。<br>②<strong>提交时要求附加本域才能获取的信息</strong>：<br><strong>使用CSRF Token进行验证</strong>：服务器向用户返回一个随机数 Token ，当网站再次发起请求时，在请求参数中加入服务器端返回的 token ，然后服务器对这个 token 进行验证。这种方法解决了使用 cookie 单一验证方式时，可能会被冒用的问题，但是这种方法存在一个缺点就是，我们需要给网站中的所有请求都添加上这个 token，操作比较繁琐。还有一个问题是一般不会只有一台网站服务器，如果请求经过负载平衡转移到了其他的服务器，但是这个服务器的 session 中没有保留这个 token 的话，就没有办法验证了。这种情况可以通过改变 token 的构建方式来解决。<br><strong>双重Cookie验证</strong>：服务器在用户访问网站页面时，向请求域名注入一个Cookie，内容为随机字符串，然后当用户再次向服务器发送请求的时候，从 cookie 中取出这个字符串，添加到 URL 参数中，然后服务器通过对 cookie 中的数据和参数中的数据进行比较，来进行验证。使用这种方式是利用了攻击者只能利用 cookie，但是不能访问获取 cookie 的特点。并且这种方法比 CSRF Token 的方法更加方便，并且不涉及到分布式访问的问题。这种方法的缺点是如果网站存在 XSS 漏洞的，那么这种方式会失效。同时这种方式不能做到子域名的隔离。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue下</title>
    <link href="/2022/08/10/Vue%E4%B8%8B/"/>
    <url>/2022/08/10/Vue%E4%B8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="一、Vuex"><a href="#一、Vuex" class="headerlink" title="一、Vuex"></a>一、Vuex</h1><h2 id="一、Vuex原理"><a href="#一、Vuex原理" class="headerlink" title="一、Vuex原理"></a>一、Vuex原理</h2><p>Vuex是一个专门为Vue.js应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态。状态state集中放在仓库store中，改变状态的方式是提交mutations，它是同步的，异步逻辑封装在action中。</p><h3 id="状态管理模式"><a href="#状态管理模式" class="headerlink" title="状态管理模式"></a>状态管理模式</h3><p>包括状态（驱动应用的数据源）、视图（以声明方式将状态映射到视图）、操作（响应在视图上的用户输入导致的状态变化）。<br><strong>Vuex解决了两个问题及使用场景</strong>：</p><ol><li>多个组件共享状态时，单向数据流的简洁性很容易被破坏。来自不同组件的行为需要变更为同一状态，如果采用父子组件传值或通过事件来变更和同步状态的多份拷贝，这样很难维护。</li><li>多个视图依赖于同一状态，来自不同视图的行为需要变更同一状态，对于多层嵌套的组件的传参非常繁琐，兄弟组件之间的状态传递困难。<br>解决办法是把组建的共享状态分离出来，以一个全局单例模式管理，通过定义和隔离状态管理中的各种概念并通过强制规则维持视图和状态间的独立性。<br><strong>Vuex原理</strong>：Vuex的状态存储是响应式的，当Vue组件从store中读取状态的时候，若store中的状态发生变化，那么相应的组件也会高效更新。改变store中状态的唯一途径是显示提交commit mutation，方便跟踪每一个状态的变化。<img src="/2022/08/10/Vue%E4%B8%8B/Vuex.png" class=""></li></ol><ul><li>Vue Components是vue组件，组件会触发（dispatch）一些事件或动作（Actions）;</li><li>在组件中发出的动作，肯定是想获取或者改变数据的，但是在 vuex 中，数据是集中管理的，不能直接去更改数据，所以会把这个动作提交（Commit）到 Mutations 中;</li><li>然后 Mutations 就去改变（Mutate）State 中的数据;</li><li>当 State 中的数据被改变之后，就会重新渲染（Render）到 Vue Components 中去，组件展示更新后的数据，完成一个流程。</li></ul><hr><p><strong>各个模块在核心流程中的主要功能</strong></p><ul><li>Vue Components∶ Vue组件。HTML页面上，负责接收用户操作等交互行为，执行dispatch方法触发对应action进行回应。</li><li>dispatch∶操作行为触发方法，是唯一能执行action的方法。</li><li>actions∶ 操作行为处理模块。负责处理Vue Components接收到的所有交互行为。包含同步&#x2F;异步操作，支持多个同名方法，按照注册的顺序依次触发。向后台API请求的操作就在这个模块中进行，包括触发其他action以及提交mutation的操作。该模块提供了Promise的封装，以支持action的链式触发。</li><li>commit∶状态改变提交操作方法。对mutation进行提交，是唯一能执行mutation的方法。</li><li>mutations∶状态改变操作方法。是Vuex修改state的唯一推荐方法，其他修改方式在严格模式下将会报错。该方法只能进行同步操作，且方法名只能全局唯一。操作之中会有一些hook暴露出来，以进行state的监控等。</li><li>state∶ 页面状态管理容器对象。集中存储Vuecomponents中data对象的零散数据，全局唯一，以进行统一的状态管理。页面显示所需的数据从该对象中进行读取，利用Vue的细粒度数据响应机制来进行高效的状态更新。</li><li>getters∶ state对象读取方法。图中没有单独列出该模块，应该被包含在了render中，Vue Components通过该方法读取全局state对象。</li></ul><h2 id="二、Vuex的属性"><a href="#二、Vuex的属性" class="headerlink" title="二、Vuex的属性"></a>二、Vuex的属性</h2><ul><li><strong>state</strong>：基本数据（数据源存放地）。Vuex中状态存储在state中，改变Vuex中的状态的唯一途径就是显式地提交 (commit) mutation。Vuex中状态是对象时,因为对象是引用类型，复制后改变属性还是会影响原始数据，这样会改变state里面的状态，是不允许，所以先用深度克隆复制对象，再修改。</li><li><strong>getters</strong>：从基本数据派生出来的数据。使用getter属性，相当Vue中的计算属性computed，只有原状态改变派生状态才会改变。 getter接收两个参数，第一个是state，第二个是getters(可以用来访问其他getter)。然后在组件中可以用计算属性computed通过this.$store.getters.total这样来访问这些派生状态，获得想要的数据。</li><li><strong>mutation</strong>：提交更改数据的方法，每个mutation都有一个字符串的事件类型和一个回调函数，这个回调函数就是实际进行状态更改的地方。</li><li><strong>actions</strong>：像一个装饰器，包裹mutations，提交mutation，让它可以异步。</li><li><strong>modules</strong>：将Vuex模块化。</li></ul><h1 id="二、VUE-3-0的更新"><a href="#二、VUE-3-0的更新" class="headerlink" title="二、VUE 3.0的更新"></a>二、VUE 3.0的更新</h1><ul><li><strong>监测机制改变</strong>：3.0 将带来基于代理 Proxy的 observer 实现，提供全语言覆盖的反应性跟踪。消除了 Vue 2 当中基于 Object.defineProperty 的实现所存在的很多限制。</li><li><strong>只能监测属性，不能监测对象</strong>：检测属性的添加和删除；检测数组索引和长度的变更；支持 Map、Set、WeakMap 和 WeakSet。</li><li><strong>模板</strong>：作用域插槽，2.x 的机制导致作用域插槽变了，父组件会重新渲染，而 3.0 把作用域插槽改成了函数的方式，这样只会影响子组件的重新渲染，提升了渲染的性能。同时，对于 render 函数的方面，vue3.0 也会进行一系列更改来方便习惯直接使用 api 来生成 vdom。</li><li><strong>对象式的组件声明方式</strong>：vue2.x 中的组件是通过声明的方式传入一系列 option，和 TypeScript 的结合需要通过一些装饰器的方式来做，虽然能实现功能，但是比较麻烦。3.0修改了组件的声明方式，改成了类式的写法，这样使得和 TypeScript 的结合变得很容易。</li><li><strong>其它方面的更改</strong>：支持自定义渲染器，从而使得 weex 可以通过自定义渲染器的方式来扩展，而不是直接 fork 源码来改的方式；支持 Fragment（多个根节点）和 Protal（在 dom 其他部分渲染组建内容）组件，针对一些特殊的场景做了处理；基于 tree shaking 优化，提供了更多的内置功能。</li></ul><h1 id="三、defineProperty和proxy区别"><a href="#三、defineProperty和proxy区别" class="headerlink" title="三、defineProperty和proxy区别"></a>三、defineProperty和proxy区别</h1><p><strong>defineProperty</strong>：是Vue2的，Vue在实例初始化时遍历data中所有的属性，并使用Object.defineProperty把这些属性全部转为getter&#x2F;setter，当追踪数据发生变化时，setter被自动调用。Object.defineProperty 是 ES5 中一个无法 shim 的特性，这也就是 Vue 不支持 IE8 以及更低版本浏览器的原因。<br>存在问题：</p><ol><li>添加或删除对象的属性时，Vue 检测不到。因为添加或删除的对象没有在初始化进行响应式处理，只能通过<code>$set</code> 来调用<code>Object.defineProperty()</code>处理。</li><li>无法监控到数组下标和长度的变化。</li></ol><p><strong>缺点</strong>：</p><ol><li>不能监听到数组length属性的变化；</li><li>不能监听对象的添加；</li><li>只能劫持对象的属性,因此我们需要对每个对象的每个属性进行遍历。</li></ol><p><strong>Proxy</strong>：VUE3使用Proxy来监控数据的变化，它是ES6提供的功能，用于定于基本操作的自定义行为，如属性查找、赋值、枚举、函数调用等。</p><ol><li>Proxy 直接代理整个对象而非对象属性，这样只需做一层代理就可以监听同级结构下的所有属性变化，包括新增属性和删除属性。</li><li>Proxy 可以监听数组的变化。</li><li>可以代理整个对象，不需要对对象进行遍历，极大提高了性能。</li><li>拦截方式13种，Object.defineProperty只有get和set两种。<br> <strong>defineProperty监听的是对象的属性，而Proxy监听的是对象</strong>。</li></ol><h1 id="四、Proxy"><a href="#四、Proxy" class="headerlink" title="四、Proxy"></a>四、Proxy</h1><p>Proxy实际上重载了点运算符，用自己的定义覆盖了语言的原生定义。</p><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, handler);<br></code></pre></td></tr></table></figure><p>new Proxy表示生成一个Proxy实例，target参数表示所要拦截的目标对象，handler参数也是一个对象，用来定制拦截行为，该对象里面可以定义各种函数。Proxy的第一个参数是所要代理的目标对象，如果没有Proxy的介入操作原来访问的就是这个对象，第二个参数是一个配置对象，对于每一个被代理的操作，需要提供一个对应的处理函数，该函数将拦截对应的操作。</p><h2 id="4-1-VUE3-里为什么要用Proxy-API替代defineProperty-API"><a href="#4-1-VUE3-里为什么要用Proxy-API替代defineProperty-API" class="headerlink" title="4.1 VUE3 里为什么要用Proxy API替代defineProperty API"></a>4.1 VUE3 里为什么要用Proxy API替代defineProperty API</h2><p>相应式优化。</p><ol><li><strong>defineProperty的局限性最大原因是只能针对单例属性做监听</strong>：VUE2中的响应式实现是基于defineProperty，对data中的属性做个遍历+递归，为每个属性设置了getter和setter。在VUE中使用下标的方式直接修改属性的值或添加一个预先不存在的对象属性无法做到setter监听，是defineProperty的局限性。</li><li><strong>Proxy API的监听是针对一个对象的，对这个对象的所有操作会进入监听操作，这就可以完全代理所有属性</strong>：Proxy可以理解成在目标对象之前设置一层拦截，外界对该对象的访问必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。</li><li><strong>响应式是惰性的</strong>：在VUE2中对于一个深层属性嵌套的对象，要劫持它内部深层次的变化，就需要遍历这个对象，执行Object.defineProperty把每一层对象数据都变成响应式的，这会有很大的性能消耗。在VUE3中，使用Proxy并不能监听到对象内部深层次的属性变化，因此它的处理方式是在getter中去递归响应式，这样的好处是真正访问到的内部属性才会变成响应式。</li><li>defineProperty会改变原始数据，而Proxy是创建对象的虚拟表示，返回一个新对象，并提供set、get、deleteproperty等处理器，这些处理器可以在访问或修改原始对象上的属性时进行拦截。不需要使用Vue.$set或Vue.$delete触发响应式，它全方位进行数组变化检测，消除了VUE2无效的边界情况，支持Map、Set、WeakMap和WeakSet。Proxy通过get收集依赖，set和delete触发依赖，对于集合类型，对集合对象的方法做一层包装，原方法执行后执行依赖相关的收集或触发逻辑。</li></ol><h2 id="4-2-特点"><a href="#4-2-特点" class="headerlink" title="4.2 特点"></a>4.2 特点</h2><ul><li><strong>Proxy可以直接监听对象而非属性</strong>：它直接劫持整个对象，并返回一个新对象。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> input = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;input&#x27;</span>);<br><span class="hljs-keyword">const</span> p = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;p&#x27;</span>);<br><span class="hljs-keyword">const</span> obj = &#123;&#125;;<br> <br><span class="hljs-keyword">const</span> newObj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(obj, &#123;<br> <span class="hljs-attr">get</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">target, key, receiver</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`getting <span class="hljs-subst">$&#123;key&#125;</span>!`</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, key, receiver);<br> &#125;,<br> <span class="hljs-attr">set</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">target, key, value, receiver</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(target, key, value, receiver);<br>  <span class="hljs-keyword">if</span> (key === <span class="hljs-string">&#x27;text&#x27;</span>) &#123;<br>   input.<span class="hljs-property">value</span> = value;<br>   p.<span class="hljs-property">innerHTML</span> = value;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(target, key, value, receiver);<br> &#125;,<br>&#125;);<br> <br>input.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;keyup&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123;<br> newObj.<span class="hljs-property">text</span> = e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>;<br>&#125;);<br></code></pre></td></tr></table></figure></li><li><strong>Proxy可以直接监听数组的变化</strong>：当我们对数组进行操作时，会触发对应的方法名称和length的变化，可以借此进行操作。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> list = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;list&#x27;</span>);<br><span class="hljs-keyword">const</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;btn&#x27;</span>);<br> <br><span class="hljs-comment">// 渲染列表</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Render</span> = &#123;<br> <span class="hljs-comment">// 初始化</span><br> <span class="hljs-attr">init</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">arr</span>) &#123;<br>  <span class="hljs-keyword">const</span> fragment = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createDocumentFragment</span>();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-property">length</span>; i++) &#123;<br>   <span class="hljs-keyword">const</span> li = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;li&#x27;</span>);<br>   li.<span class="hljs-property">textContent</span> = arr[i];<br>   fragment.<span class="hljs-title function_">appendChild</span>(li);<br>  &#125;<br>  list.<span class="hljs-title function_">appendChild</span>(fragment);<br> &#125;,<br> <span class="hljs-comment">// 我们只考虑了增加的情况,仅作为示例</span><br> <span class="hljs-attr">change</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>) &#123;<br>  <span class="hljs-keyword">const</span> li = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;li&#x27;</span>);<br>  li.<span class="hljs-property">textContent</span> = val;<br>  list.<span class="hljs-title function_">appendChild</span>(li);<br> &#125;,<br>&#125;;<br> <br><span class="hljs-comment">// 初始数组</span><br><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br> <br><span class="hljs-comment">// 监听数组</span><br><span class="hljs-keyword">const</span> newArr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(arr, &#123;<br> <span class="hljs-attr">get</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">target, key, receiver</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(key);<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, key, receiver);<br> &#125;,<br> <span class="hljs-attr">set</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">target, key, value, receiver</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(target, key, value, receiver);<br>  <span class="hljs-keyword">if</span> (key !== <span class="hljs-string">&#x27;length&#x27;</span>) &#123;<br>   <span class="hljs-title class_">Render</span>.<span class="hljs-title function_">change</span>(value);<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(target, key, value, receiver);<br> &#125;,<br>&#125;);<br> <br><span class="hljs-comment">// 初始化</span><br><span class="hljs-variable language_">window</span>.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title class_">Render</span>.<span class="hljs-title function_">init</span>(arr);<br>&#125;<br> <br><span class="hljs-comment">// push数字</span><br>btn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br> newArr.<span class="hljs-title function_">push</span>(<span class="hljs-number">6</span>);<br>&#125;);<br></code></pre></td></tr></table></figure></li><li><strong>Proxy有多种拦截方法</strong>：返回的是一个新对象，可以只操作新对象达到目的，而Object.defineProperty只能遍历对象属性直接修改。</li></ul><h1 id="★五、VUE范例"><a href="#★五、VUE范例" class="headerlink" title="★五、VUE范例"></a>★五、VUE范例</h1><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> ... <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;&quot;</span>;</span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span>&#123;</span><br><span class="language-javascript">    <span class="hljs-comment">// 组件名</span></span><br><span class="language-javascript">    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;a&quot;</span>,</span><br><span class="language-javascript">    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">        <span class="hljs-keyword">return</span>&#123;</span><br><span class="language-javascript">            <span class="hljs-attr">one</span>:<span class="hljs-number">1</span>,</span><br><span class="language-javascript">            <span class="hljs-attr">two</span>: tree,</span><br><span class="language-javascript">        &#125;;</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">    <span class="hljs-title function_">created</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">        ...</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">    <span class="hljs-attr">methods</span>:&#123;</span><br><span class="language-javascript">        <span class="hljs-title function_">funcone</span>(<span class="hljs-params">a,b</span>)&#123;</span><br><span class="language-javascript">        &#125;,</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="六、webpack"><a href="#六、webpack" class="headerlink" title="六、webpack"></a>六、webpack</h1><h2 id="6-1-什么是webpack"><a href="#6-1-什么是webpack" class="headerlink" title="6.1 什么是webpack"></a>6.1 什么是webpack</h2><p> webpack是一款模块加载器兼打包工具，它能把各种资源，例如JS（含JSX）、coffee、样式（含less&#x2F;sass）、图片等都作为模块来使用和处理,它能有Grunt或Gulp所有基本功能。<br> <strong>是一个现代的JS应用的静态模块化打包工具</strong>：<br> <strong>模块化</strong>：webpack其中一个核心就是让我们可能进行模块化开发，并且会帮助我们处理模块间的依赖关系，而且不仅仅是JavaScript文件，CSS、图片、json文件等等在webpack中都可以被当做模块来使用。<br> <strong>打包</strong>：合并成一个或多个包(Bundle),并且在打包的过程中，还可以对资源进行处理，比如压缩图片，将scss转成css，将ES6语法转成ES5语法，将TypeScript转成JavaScript等等操作。<br> <strong>静态</strong>：最终可以将代码打包成最终的静态资源（部署到静态服务器）<br><strong>优势</strong>：<br>webpack 是以 commonJS 的形式来书写脚本，但对 AMD&#x2F;CMD 的支持也很全面，方便旧项目进行代码迁移。<br>支持很多模块加载器的调用，可以使模块加载器灵活定制，比如<strong>babel-loader</strong>加载器，该加载器能使我们使用ES6的语法来编写代码;<strong>less-loader</strong>加载器，可以将less编译成css文件；<br>开发便捷，能替代部分 grunt&#x2F;gulp 的工作，比如打包、压缩混淆、图片转base64等。<br>可以通过配置打包成多个文件，有效的利用浏览器的缓存功能提升性能。<br><strong>目标</strong>：<br>webpack它能将依赖的模块转化成可以代表这些包的静态文件<br>将依赖的模块分片化，并且按需加载<br>解决大型项目初始化加载慢的问题<br>每一个静态文件都可以看成一个模块<br>可以整合第三方库<br>能够在大型项目中运用<br>可以自定义切割模块的方式</p><h2 id="6-2-webpack类似工具"><a href="#6-2-webpack类似工具" class="headerlink" title="6.2 webpack类似工具"></a>6.2 webpack类似工具</h2><p>同样是基于入口的打包工具还有以下几个主流的：</p><ul><li>webpack</li><li>rollup</li><li>parcel<br>从应用场景上来看：</li><li>webpack适用于大型复杂的前端站点构建</li><li>rollup适用于基础库的打包，如vue、react</li><li>parcel适用于简单的实验性项目，他可以满足低门槛的快速看到效果<br>由于parcel在打包过程中给出的调试信息十分有限，所以一旦打包出错难以调试，所以不建议复杂的项目使用parcel。<h2 id="6-3-webpack比其他类似工具区别"><a href="#6-3-webpack比其他类似工具区别" class="headerlink" title="6.3 webpack比其他类似工具区别"></a>6.3 webpack比其他类似工具区别</h2>有同步和异步两种不同的加载方式<br>Loader,加载器可以将其他资源整合到JS文件中，通过这种方式，可以讲所有的源文件形成一个模块<br>优秀的语法分析能力，支持 CommonJs AMD 规范<br>有丰富的开源插件库，可以根据自己的需求自定义webpack的配置<br><strong>与grunt、gulp区别</strong>：<br>三者都是前端构建工具，grunt和gulp在早期比较流行，现在webpack相对来说比较主流，不过一些轻量化的任务还是会用gulp来处理，比如单独打包CSS文件等。<br>grunt和gulp是基于任务和流（Task、Stream）的。类似jQuery，找到一个（或一类）文件，对其做一系列链式操作，更新流上的数据， 整条链式操作构成了一个任务，多个任务就构成了整个web的构建流程。<br>webpack是基于入口的。webpack会自动地递归解析入口所需要加载的所有资源文件，然后用不同的Loader来处理不同的文件，用Plugin来扩展webpack功能。<br>所以总结一下：</li><li>从构建思路来说<br>gulp和grunt需要开发者将整个前端构建过程拆分成多个<code>Task</code>，并合理控制所有<code>Task</code>的调用关系<br>webpack需要开发者找到入口，并需要清楚对于不同的资源应该使用什么Loader做何种解析和加工复制代码</li><li>对于知识背景来说<br>gulp更像后端开发者的思路，需要对于整个流程了如指掌 webpack更倾向于前端开发者的思路<h2 id="6-4-webpack为什么要将所有资源放在一个文件里"><a href="#6-4-webpack为什么要将所有资源放在一个文件里" class="headerlink" title="6.4 webpack为什么要将所有资源放在一个文件里"></a>6.4 webpack为什么要将所有资源放在一个文件里</h2>我们知道，对于浏览器来说，加载的资源越少，响应的速度也就越快，所以有时候我们为了优化浏览器的性能，会尽可能的将资源合并到一个主文件app.js里面。但是这导致的很大的缺点：<br>当你的项目十分庞大的时候，不同的页面不能做到按需加载，而是将所有的资源一并加载，耗费时间长，性能降低。<br>会导致依赖库之间关系的混乱，特别是大型项目时，会变得难以维护和跟踪。比如:哪些文件是需要A模块加载完后才能执行的？哪些页面会受到多个样式表同时影响的？ 等许多问题。<br>而webpack可以很好的解决以上缺点,因为它是一个十分聪明的模块打包系统，当你正确配置后，它会比你想象中的更强大，更优秀。<h2 id="6-5-webpack怎么打包"><a href="#6-5-webpack怎么打包" class="headerlink" title="6.5 webpack怎么打包"></a>6.5 webpack怎么打包</h2>①在webpack开始打包时，会根据命令或者配置文件找到入口文件从入口开始。<br>②根据文件中之间的依赖关系生成依赖关系图，这个依赖关系图会包括项目中所需要的所有模块，包括 js文件，css文件,图片，字体等<br>③依次遍历图结构，根据文件类型使用对应的loader进行解析，依次进行打包。<br><strong>构建流程</strong>：串行的过程<br>1.初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数；<br>2.开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译；<br>3.确定入口：根据配置中的 entry 找出所有的入口文件；<br>4.编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理；<br>5.完成模块编译：在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系；<br>6.输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会；<br>7.输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。<br>在以上过程中，Webpack 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。<h2 id="6-6-webpack的使用过程"><a href="#6-6-webpack的使用过程" class="headerlink" title="6.6 webpack的使用过程"></a>6.6 webpack的使用过程</h2>①准备工作：<br>dist文件夹存放打包后的文件，src文件夹存放写的源文件<br>src中main.js项目的入口文件，index.html浏览器打开展示的首页html。</li></ul><p>②js文件的打包：js文件不可以直接使用，浏览器无法识别其中模块化代码。<br>webpack支持代码中写模块化，对模块化的代码进行处理，在处理完所有模块之间的关系后，将多个js打包到一个js文件中，引入就非常方便了。</p><p><strong>打包过程</strong><br>1.webpack<br>直接执行webpack默认会将当前目录下的 src&#x2F;index.js 作为入口文件，所以，如果当前项目中没有存在src&#x2F;index.js文件，那么会报错,打包后的文件会保存在dist&#x2F;main.js中<br>2.webpack –entry .&#x2F;src&#x2F;main.js –output-path .&#x2F;dist指定入口文件和出口文件<br>将src&#x2F;main.js文件打包，并把打包好的文件保存到dist&#x2F;main.js中 </p><p>③使用打包后的文件<br>打包后会在dist文件下生成一个main.js文件，只要在index.html中引入这个文件即可。</p><h2 id="6-7-配置entry和output"><a href="#6-7-配置entry和output" class="headerlink" title="6.7 配置entry和output"></a>6.7 配置entry和output</h2><p>在webpack.config.js中配置入口文件和出口文件。<br><strong>entry</strong>：用来写入口文件，它将是整个依赖关系的根<br><strong>output</strong>：用来定义出口文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>    <span class="hljs-attr">entry</span>: <span class="hljs-string">&#x27;./src/index.js&#x27;</span>, <span class="hljs-comment">// 若有多个入口文件，把entry写成对象，index.js的键为main</span><br>   <span class="hljs-attr">output</span>: &#123;<br>        <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;main.js&#x27;</span>,<br>        <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">resolve</span>(__dirname,<span class="hljs-string">&#x27;dist&#x27;</span>)<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果定义的入口文件有多个，那我们需要使用占位符来确保输出文件的唯一性，即[main].js。</p><h2 id="6-8-loader插件"><a href="#6-8-loader插件" class="headerlink" title="6.8 loader插件"></a>6.8 loader插件</h2><p>loader 用于对模块的源代码进行<strong>转换</strong>。loader 可以使你在 import 或”加载”模块时预处理文件。因此，loader 类似于其他构建工具中“任务(task)”，并提供了处理前端构建步骤的强大方法。loader 可以将文件从不同的语言（如 TypeScript）转换为 JavaScript，或将内联图像转换为 data URL。loader 甚至允许你直接在 JavaScript 模块中 import CSS文件！loader 本质是一个函数。<br><strong>常见loader</strong>：<br>file-loader：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件<br>url-loader：和 file-loader 类似，但是能在文件很小的情况下以 base64 的方式把文件内容注入到代码中去<br>source-map-loader：加载额外的 Source Map 文件，以方便断点调试<br>image-loader：加载并且压缩图片文件<br>babel-loader：把 ES6 转换成 ES5<br>css-loader：加载 CSS文件，对CSS文件进行解析，支持模块化、压缩、文件导入等特性<br>style-loader：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS。<br>eslint-loader：通过 ESLint 检查 JavaScript 代码<br>less-loader：把less文件转化为css文件。<br><strong>特性</strong>：<br>loader 支持链式传递。能够对资源使用流水线(pipeline)。一组链式的 loader 将按照相反的顺序执行。loader 链中的第一个 loader 返回值给下一个 loader。在最后一个 loader，返回 webpack 所预期的 JavaScript。<br>1.loader 可以是同步的，也可以是异步的。<br>2.loader 运行在 Node.js 中，并且能够执行任何可能的操作。<br>3.loader 接收查询参数。用于对 loader 传递配置。<br>4.loader 也能够使用 options 对象进行配置。<br>5.除了使用 package.json 常见的 main 属性，还可以将普通的 npm 模块导出为 loader，做法是<br>6.在 package.json 里定义一个 loader 字段。<br>7.插件(plugin)可以为 loader 带来更多特性。<br>8.loader 能够产生额外的任意文件。<br>loader 通过（loader）预处理函数，为 JavaScript 生态系统提供了更多能力。 用户现在可以更加灵活地引入细粒度逻辑，例如压缩、打包、语言翻译和其他更多。<br><strong>使用方式</strong><br>1.配置（推荐）：在 webpack.config.js 文件中指定 loader。<br>2.内联：在每个 import 语句中显式指定 loader。<br>3.CLI：在 shell 命令中指定它们。</p><h2 id="6-9-plugin插件"><a href="#6-9-plugin插件" class="headerlink" title="6.9 plugin插件"></a>6.9 plugin插件</h2><p>用于执行更加广泛的任务，比如打包优化、资源管理、环境变量注入等等，是对webpack现有功能的各种扩展。<br><strong>常见</strong>：<br>CleanWebpackPlugin：每次打包时，自动删除上一次打包的dist文件夹。<br>HTMLWebpackPlugin：对index.html文件进行打包，并且在打包的index.html中引用main.js</p><h2 id="6-10-loader与plugin区别"><a href="#6-10-loader与plugin区别" class="headerlink" title="6.10 loader与plugin区别"></a>6.10 loader与plugin区别</h2><p>Loader像一个”翻译官”<strong>把读到的源文件内容转义成新的文件内容</strong>，并且每个Loader通过<strong>链式操作</strong>，将源文件一步步翻译成想要的样子。<br>编写Loader时要遵循单一原则，每个Loader只做一种”转义”工作。 每个Loader的拿到的是源文件内容（source），可以通过返回值的方式将处理后的内容输出，也可以调用this.callback()方法，将内容返回给webpack。 还可以通过 this.async()生成一个callback函数，再用这个callback将处理后的内容输出出去。 此外webpack还为开发者准备了开发loader的工具函数集——loader-utils。<br>相对于Loader而言，Plugin的编写就灵活了许多。 webpack在运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。<br><strong>loader 本质是一个函数，plugin 本质是一个类</strong><br>不同的作用</p><ul><li>Loader直译为”加载器”。主要是做<strong>转换功能</strong>。Webpack将一切文件视为模块，但是webpack原生是只能解析js文件，如果想将其他文件也打包的话，就会用到loader。 所以Loader的作用是让webpack拥有了加载和解析<em>非<strong>JavaScript</strong>文件</em>的能力。</li><li>Plugin直译为”插件”。原理是<strong>监听 webpack 构建过程中的一些钩子</strong>，然后做一些自己的操作，更多的是丰富 webpack 的功能。Plugin可以扩展webpack的功能，让webpack具有更多的灵活性。 在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。<br>不同的用法</li><li>Loader在module.rules中配置，也就是说他作为模块的解析规则而存在。 类型为数组，每一项都是一个Object，里面描述了对于什么类型的文件（test），使用什么加载(loader)和使用的参数（options）</li><li>Plugin在plugins中单独配置。 类型为数组，每一项是一个plugin的实例，参数都通过构造函数传入。</li></ul><h1 id="七、plugin原理"><a href="#七、plugin原理" class="headerlink" title="七、plugin原理"></a>七、plugin原理</h1><p>webpack 在编译代码过程中，会触发一系列 Tapable 钩子事件，插件所做的，就是找到相应的钩子，往上面挂上自己的任务，也就是注册事件，这样当 webpack 构建的时候，插件注册的事件就会随着钩子的触发而执行。<br><strong>Webpack钩子</strong>：钩子的本质是事件，webpack把编译过程中触发的各类关键事件封装成事件接口暴露出来。<br><strong>Tapable</strong>：为webpack提供了统一的插件接口（事件），提供tap（可以注册同步钩子和异步钩子）、tapAsync（回调方式注册异步钩子）、tapPromise（Promise方式注册异步钩子）</p><h2 id="Compiler"><a href="#Compiler" class="headerlink" title="Compiler"></a>Compiler</h2><p>compiler 对象中<strong>保存着完整的 Webpack 环境配置</strong>，每次启动 webpack 构建时它都是一个独一无二，仅仅会创建一次的对象。<br>这个对象会在首次启动 Webpack 时创建，可以通过 compiler 对象上访问到 Webapck 的主环境配置，如 loader 、 plugin等配置信息。<br>它有以下主要属性：<br>compiler.options 可以访问本次启动 webpack 时候所有的配置文件，包括但不限于 loaders 、entry 、output 、plugin 等等完整配置信息<br>compiler.inputFileSystem 和 compiler.outputFileSystem 可以进行文件操作，相当于 Nodejs 中 fs<br>compiler.hooks 可以注册 tapable 的不同种类 Hook，从而可以在 compiler 生命周期中植入不同的逻辑</p><h2 id="Compilation"><a href="#Compilation" class="headerlink" title="Compilation"></a>Compilation</h2><p>compilation 对象<strong>代表一次资源的构建，compilation 实例能够访问所有的模块和它们的依赖</strong><br>一个 compilation 对象会对构建依赖图中所有模块，进行编译。 在编译阶段，模块会被加载(load)、封存(seal)、优化(optimize)、 分块(chunk)、哈希(hash)和重新创建(restore)<br>它有以下主要属性：<br>compilation.modules ：可以访问所有模块，打包的每一个文件都是一个模块。<br>compilation.chunks：chunk 即是多个 modules 组成而来的一个代码块。入口文件引入的资源组成一个 chunk，通过代码分割的模块又是另外的 chunk<br>compilation.assets：可以访问本次打包生成所有文件的结果。<br>compilation.hooks：可以注册 tapable 的不同种类 Hook，用于在 compilation 编译模块阶段进行逻辑添加以及修改</p><img src="/2022/08/10/Vue%E4%B8%8B/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" class=""> ]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript下</title>
    <link href="/2022/07/28/JavaScript%E4%B8%8B/"/>
    <url>/2022/07/28/JavaScript%E4%B8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="四、类、对象和作用域"><a href="#四、类、对象和作用域" class="headerlink" title="四、类、对象和作用域"></a>四、类、对象和作用域</h1><h2 id="一、-原型和原型链"><a href="#一、-原型和原型链" class="headerlink" title="一、 原型和原型链"></a>一、 原型和原型链</h2><p>在JavaScript中是使用构造函数来新建一个对象的，<strong>每一个构造函数的内部都有一个 prototype 属性（原型对象，构造函数独有），它的属性值是一个对象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法</strong>。当使用构造函数<strong>新建一个对象</strong>后，在这个对象的内部将包含一个指针，这个指针指向<strong>构造函数的 prototype 属性对应的值</strong>，在 ES5 中这个指针被称为对象的原型。一般来说不应该能够获取到这个值的，但是现在浏览器中都实现了 <strong>proto属性</strong>来访问这个属性，但是最好不要使用这个属性，因为它不是规范中规定的。ES5 中新增了一个 Object.getPrototypeOf() 方法，可以通过这个方法来获取对象的原型。<br><strong>当访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去，也就是原型链的概念</strong>。原型链的尽头一般来说都是 Object.prototype 所以这就是新建的对象为什么能够使用 toString() 等方法的原因。<br><strong>特点：</strong> JavaScript 对象是通过引用来传递的，创建的每个新对象实体中并没有一份属于自己的原型副本。当修改原型时，与之相关的对象也会继承这一改变。</p><h2 id="二、原型的修改、重写"><a href="#二、原型的修改、重写" class="headerlink" title="二、原型的修改、重写"></a>二、原型的修改、重写</h2><p><strong>p.constructor就是对象的构造函数Person</strong></p><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>&#125;<br><span class="hljs-comment">// 修改原型</span><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;&#125;<br><span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;hello&#x27;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>) <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-property">__proto__</span> === p.<span class="hljs-property">constructor</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>) <span class="hljs-comment">// true</span><br><span class="hljs-comment">// p.constructor就是对象的构造函数Person</span><br><span class="hljs-comment">// 重写原型</span><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = &#123;<br>    <span class="hljs-attr">getName</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;&#125;<br>&#125;<br><span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;hello&#x27;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>)        <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-property">__proto__</span> === p.<span class="hljs-property">constructor</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>) <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>可以看到修改原型的时候p的构造函数不是指向Person了，因为直接给Person的原型对象直接用对象赋值时，它的构造函数指向的了根构造函数Object，所以这时候p.constructor &#x3D;&#x3D;&#x3D; Object ，而不是p.constructor &#x3D;&#x3D;&#x3D; Person。要想成立，就要用constructor指回来：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = &#123;<br>    <span class="hljs-attr">getName</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;&#125;<br>&#125;<br><span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;hello&#x27;</span>)<br>p.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Person</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>)        <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-property">__proto__</span> === p.<span class="hljs-property">constructor</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h2 id="三、原型链的指向"><a href="#三、原型链的指向" class="headerlink" title="三、原型链的指向"></a>三、原型链的指向</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>()<br>p.<span class="hljs-property">__proto__</span>  <span class="hljs-comment">// Person.prototype</span><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">__proto__</span>  <span class="hljs-comment">// Object.prototype</span><br>p.<span class="hljs-property">__proto__</span>.<span class="hljs-property">__proto__</span> <span class="hljs-comment">//Object.prototype</span><br>p.<span class="hljs-property">__proto__</span>.<span class="hljs-property">constructor</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">__proto__</span> <span class="hljs-comment">// Object.prototype</span><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">__proto__</span> <span class="hljs-comment">// Object.prototype</span><br>p1.<span class="hljs-property">__proto__</span>.<span class="hljs-property">constructor</span> <span class="hljs-comment">// Person</span><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span>  <span class="hljs-comment">// Person</span><br></code></pre></td></tr></table></figure><p>由于Object是构造函数，原型链终点是Object.prototype.__proto__，而Object.prototype.<strong>proto</strong>&#x3D;&#x3D;&#x3D; null &#x2F;&#x2F; true，所以，原型链的终点是null。原型链上的所有原型都是对象，所有的对象最终都是由Object构造的，而Object.prototype的下一级是Object.prototype.__proto__。 </p><h2 id="四、获得对象非原型链上的属性"><a href="#四、获得对象非原型链上的属性" class="headerlink" title="四、获得对象非原型链上的属性"></a>四、获得对象非原型链上的属性</h2><p>使用后hasOwnProperty()方法来判断属性是否属于原型链的属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">iterate</span>(<span class="hljs-params">obj</span>)&#123;<br>   <span class="hljs-keyword">var</span> res=[];<br>   <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> obj)&#123;<br>        <span class="hljs-keyword">if</span>(obj.<span class="hljs-title function_">hasOwnProperty</span>(key))<br>           res.<span class="hljs-title function_">push</span>(key+<span class="hljs-string">&#x27;: &#x27;</span>+obj[key]);<br>   &#125;<br>   <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="★五、对this的理解-apply-call-bind区别"><a href="#★五、对this的理解-apply-call-bind区别" class="headerlink" title="★五、对this的理解(apply,call,bind区别)"></a>★五、对this的理解(apply,call,bind区别)</h2><p>this 是执行上下文中的一个属性，它指向最后一次调用这个方法的对象。在实际开发中，this 的指向可以通过四种调用模式来判断。</p><ul><li>第一种是<strong>函数调用模式</strong>，当一个函数不是一个对象的属性时，直接作为函数来调用时，this 指向全局对象。  </li><li>第二种是<strong>方法调用模式</strong>，如果一个函数作为一个对象的方法来调用时，this 指向这个对象。</li><li>第三种是<strong>构造器调用模式</strong>，如果一个函数用new调用时（构造函数），函数执行前会新创建一个对象，函数里的this指向这个新创建的对象。</li><li>第四种是 <strong>apply 、 call和bind 调用模式</strong>，这三个方法都可以显示的指定调用函数的 this 指向。<strong>apply方法</strong>接收两个参数：一个是this绑定的对象，一个是<strong>参数数组</strong>。<strong>call方法</strong>接收的参数，第一个是this绑定的对象，后面的其余参数是传入函数执行的参数，和apply区别是<strong>传入的参数数量不固定</strong>。在使用 call() 方法时，传递给函数的参数必须逐个列举出来。bind方法通过传入一个对象，返回一个this绑定了传入对象的新函数，<strong>和call区别是生成一个新函数</strong>。这个函数的this指向除了使用new时会被改变，其他情况下都不会改变。<br>这四种方式，使用构造器调用模式的优先级最高，然后是 apply、call 和 bind 调用模式，然后是方法调用模式，然后是函数调用模式。<h2 id="六、实现call、apply和bind"><a href="#六、实现call、apply和bind" class="headerlink" title="六、实现call、apply和bind"></a>六、实现call、apply和bind</h2><h3 id="6-1-call"><a href="#6-1-call" class="headerlink" title="6.1 call"></a>6.1 call</h3></li><li>判断调用对象是否为函数，即使是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li><li>判断传入上下文对象是否存在，如果不存在，则设置为 window 。</li><li>处理传入的参数，截取第一个参数后的所有参数。</li><li>将函数作为上下文对象的一个属性。</li><li>使用上下文对象来调用这个方法，并保存返回结果。</li><li>删除刚才新增的属性。</li><li>返回结果。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myCall</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">context</span>) &#123;<br>  <span class="hljs-comment">// 判断调用对象</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">this</span> !== <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;type error&quot;</span>);<br>  &#125;<br>  <span class="hljs-comment">// 获取参数</span><br>  <span class="hljs-keyword">let</span> args = [...<span class="hljs-variable language_">arguments</span>].<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>),<br>    result = <span class="hljs-literal">null</span>;<br>  <span class="hljs-comment">// 判断 context 是否传入，如果未传入则设置为 window</span><br>  context = context || <span class="hljs-variable language_">window</span>;<br>  <span class="hljs-comment">// 将调用函数设为对象的方法</span><br>  context.<span class="hljs-property">fn</span> = <span class="hljs-variable language_">this</span>;<br>  <span class="hljs-comment">// 调用函数</span><br>  result = context.<span class="hljs-title function_">fn</span>(...args);<br>  <span class="hljs-comment">// 将属性删除</span><br>  <span class="hljs-keyword">delete</span> context.<span class="hljs-property">fn</span>;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="6-2-apply"><a href="#6-2-apply" class="headerlink" title="6.2 apply"></a>6.2 apply</h3></li><li>判断调用对象是否为函数，即使是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li><li>判断传入上下文对象是否存在，如果不存在，则设置为 window 。</li><li>将函数作为上下文对象的一个属性。</li><li>判断参数值是否传入</li><li>使用上下文对象来调用这个方法，并保存返回结果。</li><li>删除刚才新增的属性</li><li>返回结果<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myApply</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">context</span>) &#123;<br>  <span class="hljs-comment">// 判断调用对象是否为函数</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">this</span> !== <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&quot;Error&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">let</span> result = <span class="hljs-literal">null</span>;<br>  <span class="hljs-comment">// 判断 context 是否存在，如果未传入则为 window</span><br>  context = context || <span class="hljs-variable language_">window</span>;<br>  <span class="hljs-comment">// 将函数设为对象的方法</span><br>  context.<span class="hljs-property">fn</span> = <span class="hljs-variable language_">this</span>;<br>  <span class="hljs-comment">// 调用方法</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">arguments</span>[<span class="hljs-number">1</span>]) &#123;<br>    result = context.<span class="hljs-title function_">fn</span>(...<span class="hljs-variable language_">arguments</span>[<span class="hljs-number">1</span>]);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    result = context.<span class="hljs-title function_">fn</span>();<br>  &#125;<br>  <span class="hljs-comment">// 将属性删除</span><br>  <span class="hljs-keyword">delete</span> context.<span class="hljs-property">fn</span>;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="6-3-bind"><a href="#6-3-bind" class="headerlink" title="6.3 bind"></a>6.3 bind</h3></li><li>判断调用对象是否为函数，即使是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li><li>保存当前函数的引用，获取其余传入参数值。</li><li>创建一个函数返回</li><li>函数内部使用 apply 来绑定函数调用，需要判断函数作为构造函数的情况，这个时候需要传入当前函数的 this 给 apply 调用，其余情况都传入指定的上下文对象。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myBind</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">context</span>) &#123;<br><span class="hljs-comment">// 判断调用对象是否为函数</span><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">this</span> !== <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&quot;Error&quot;</span>);<br>&#125;<br><span class="hljs-comment">// 获取参数</span><br><span class="hljs-keyword">var</span> args = [...<span class="hljs-variable language_">arguments</span>].<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>),<br>  fn = <span class="hljs-variable language_">this</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Fn</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 根据调用方式，传入不同绑定值</span><br>  <span class="hljs-keyword">return</span> fn.<span class="hljs-title function_">apply</span>(<br>    <span class="hljs-variable language_">this</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Fn</span> ? <span class="hljs-variable language_">this</span> : context,<br>    args.<span class="hljs-title function_">concat</span>(...<span class="hljs-variable language_">arguments</span>)<br>  );<br>&#125;;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><h2 id="七、对象创建的方式"><a href="#七、对象创建的方式" class="headerlink" title="七、对象创建的方式"></a>七、对象创建的方式</h2><ul><li>**{}**：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> o = &#123;&#125;<br>o.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;jack&#x27;</span><br>o.<span class="hljs-property">age</span> = <span class="hljs-number">20</span><br></code></pre></td></tr></table></figure></li><li><strong>工厂模式</strong>：使用函数来创建对象，问题是创建出来的对象无法与某个类型联系起来，只是简单封装了复用代码，没有建立起对象和和类型之间的关系。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createObject</span>(<span class="hljs-params">name</span>)&#123;<br>    <span class="hljs-keyword">var</span> o = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    o.<span class="hljs-property">name</span> = name;<br>    o.<span class="hljs-property">sayName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-title function_">alert</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>    &#125;;<br>    <span class="hljs-keyword">return</span> o;<br>&#125;<br><span class="hljs-keyword">var</span> o1 = <span class="hljs-title function_">createObject</span>(<span class="hljs-string">&#x27;zhang&#x27;</span>);<br></code></pre></td></tr></table></figure></li><li><strong>构造函数</strong>：js 中每一个函数都可以作为构造函数，只要一个函数是通过 new 来调用的，那么就可以把它称为构造函数。执行构造函数首先会创建一个对象，然后将对象的原型指向构造函数的prototype属性，然后将执行上下文中的this指向这个对象，最后再执行整个函数，如果返回值不是对象，则返回新建的对象。因为this的值指向了新建的对象，因此可以使用 this 给对象赋值。构造函数模式相对于工厂模式的优点是，所创建的对象和构造函数建立起了联系，因此可以通过原型来识别对象的类型。构造函数缺点就是，造成了不必要的函数对象的创建，因为在js中函数也是一个对象，因此如果对象属性中包含函数的话，那么每次都会新建一个函数对象，浪费了不必要的内存空间，因为函数是所有的实例都可以通用的。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><span class="hljs-keyword">var</span> p1  = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;zhang&#x27;</span>);<br></code></pre></td></tr></table></figure></li><li><strong>原型模型</strong>：每个方法都有一个原型prototype，每个原型都有一个构造器constructor，构造器指向这个方法。prototype属性，是一个对象，它包含了通过构造函数创建的所有实例都能共享的属性和方法。因此可以使用原型对象来添加公用属性和方法，从而实现代码的复用。这种方式相对于构造函数模式来说，解决了函数对象的复用问题。但是也存在一些问题，一是没有办法通过传入参数来初始化值，另一个是如果存在一个引用类型如Array这样的值，那么所有的实例将共享一个对象，一个实例对引用类型值的改变会影响所有的实例。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Animal</span>(<span class="hljs-params"></span>) &#123; &#125;<br><span class="hljs-title class_">Animal</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;animal&#x27;</span>;<br><span class="hljs-title class_">Animal</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayName</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123; <span class="hljs-title function_">alert</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>); &#125;;<br><span class="hljs-keyword">var</span> a1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>();<br></code></pre></td></tr></table></figure></li><li><strong>原型模式+构造函数模式</strong>：因为构造函数模式和原型模式分开使用都存在一些问题，因此可以组合使用这两种模式，通过构造函数来初始化对象的属性，通过原型对象来实现函数方法的复用。这种方法很好的解决了两种模式单独使用时的缺点，但是有一点不足的就是，因为使用了两种不同的模式，所以对于代码的封装性不够好。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Animal</span>(<span class="hljs-params">name</span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">friends</span> = [<span class="hljs-string">&#x27;cat&#x27;</span>, <span class="hljs-string">&#x27;dog&#x27;</span>];<br>&#125;<br><span class="hljs-title class_">Animal</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>&#125;;<br><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>(<span class="hljs-string">&#x27;d&#x27;</span>);<br></code></pre></td></tr></table></figure></li><li><strong>动态原型模式</strong>：仅在第一次调用构造函数时将方法赋给原型对象的相应属性，其它示例的处理方式同构造函数模式。</li><li><strong>寄生构造函数模式</strong>：仅仅封装创建对象的代码，然后再返回新创建的对象，仍使用new操作符调用。</li><li>**new Object()**：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> o = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>o.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;zhang&#x27;</span>;<br>o.<span class="hljs-property">sayName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><strong>使用字面量创建对象</strong>：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> person = &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;zhang&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">20</span>&#125;;<br></code></pre></td></tr></table></figure></li></ul><h2 id="八、对象继承的方式"><a href="#八、对象继承的方式" class="headerlink" title="八、对象继承的方式"></a>八、对象继承的方式</h2><ul><li><strong>原型链继承</strong>：通过b函数的原型b.prototype指向a的实例来实现。存在引用值共享问题，当a中某个属性是引用数据类型的时候b实例如果修改了这个属性的内容则其他b实例中这个属性也会一起改变。创建子类型时不能向超类型传递参数。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">parent</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> = <span class="hljs-string">&#x27;111&#x27;</span>;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">child</span>(<span class="hljs-params"></span>)&#123;&#125;<br>child.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title function_">parent</span>();<br><span class="hljs-keyword">var</span> c = <span class="hljs-keyword">new</span> <span class="hljs-title function_">child</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(c.<span class="hljs-property">a</span>) <span class="hljs-comment">// 111</span><br></code></pre></td></tr></table></figure></li><li><strong>构造函数继承</strong>：通过在b函数中独立执行a，在子类型的函数中调用超类型的构造函数，此时a的this指向window，通过call方法改变a的指向指向b实例。这样解决了不能向超类型传递参数的缺点，但是存在问题是无法实现函数方法的复用，同时子类型的实例没有办法拿到超类型原型上的属性和方法。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">parent</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> = <span class="hljs-string">&#x27;111&#x27;</span>;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">child</span>(<span class="hljs-params"></span>)&#123;<br>    parent.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>);<br>&#125;<br>parent.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">say</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;222&#x27;</span>)<br>&#125;<br><span class="hljs-keyword">var</span> c = <span class="hljs-keyword">new</span> <span class="hljs-title function_">child</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(c.<span class="hljs-property">a</span>) <span class="hljs-comment">//111</span><br>c.<span class="hljs-title function_">say</span>() <span class="hljs-comment">// 报错</span><br></code></pre></td></tr></table></figure></li><li><strong>组合继承</strong>：结合上面两种方法，用构造函数继承中的子类型的原型指向超类型。这样解决了前面两种模式单独使用了问题，但是由于是用超类型的实例作为子类型的原型，调用了两次超类型的构造函数，会产生属性与方法重叠的问题。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">parent</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> = <span class="hljs-string">&#x27;111&#x27;</span>;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">child</span>(<span class="hljs-params"></span>)&#123;<br>    parent.<span class="hljs-title function_">call</span>()(<span class="hljs-variable language_">this</span>);<br>&#125;<br>child.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title function_">parent</span>();<br>parent.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">say</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;222&#x27;</span>);<br>&#125;<br>child.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title function_">parent</span>();<br><span class="hljs-keyword">var</span> c = <span class="hljs-keyword">new</span> <span class="hljs-title function_">child</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(c.<span class="hljs-property">a</span>); <span class="hljs-comment">// 111</span><br>c.<span class="hljs-title function_">say</span>() <span class="hljs-comment">// 222</span><br></code></pre></td></tr></table></figure></li><li><strong>原型式继承</strong>：用构造函数在一个函数中传入了一个临时的构造函数，将传入对象作为构造函数的原型，最后返回这个临时类型的新的实例。也可以用Object.create()实现。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">child</span>(<span class="hljs-params">obj</span>)&#123;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">parent</span>(<span class="hljs-params"></span>)&#123;&#125;<br>    parent.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = obj;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">parent</span>();<br>&#125;<br><span class="hljs-keyword">let</span> person = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;a&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">18</span><br>&#125;<br><span class="hljs-keyword">var</span> c1 = <span class="hljs-title function_">child</span>(person);<br><span class="hljs-keyword">var</span> c2 = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(person);<br></code></pre></td></tr></table></figure></li><li><strong>寄生式继承</strong>：创建一个用于封装继承过程的函数，通过传入一个对象，复制一个对象的副本，对对象进行扩展最后返回一个对象。缺点是不能做单函数复用。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">object</span>(<span class="hljs-params">person</span>)&#123;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">F</span>(<span class="hljs-params"></span>)&#123;&#125;;<br>    F.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = person;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">F</span>();<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createChild</span>(<span class="hljs-params">obj</span>)&#123;<br>    <span class="hljs-keyword">let</span> clone = <span class="hljs-title function_">object</span>(obj); <span class="hljs-comment">//创建一个新对象</span><br>    clone.<span class="hljs-property">sayHi</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;hi&#x27;</span>);<br>    &#125;; <span class="hljs-comment">// 对象扩展</span><br>    <span class="hljs-keyword">return</span> clone;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><strong>寄生式组合继承</strong>：使用超类型的原型的副本作为子类型的原型，使用Object.create()将子类型的原型直接指向超类型的原型。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">parent</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> = <span class="hljs-string">&#x27;111&#x27;</span>;<br>&#125;<br>parent.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">say</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;222&quot;</span>);<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">child</span>(<span class="hljs-params"></span>)&#123;<br>    parent.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>);<br>&#125;<br><span class="hljs-comment">//es5之前就重写Object.create方法</span><br><span class="hljs-keyword">if</span>(!<span class="hljs-title class_">Object</span>.<span class="hljs-property">create</span>)&#123; <br>    <span class="hljs-title class_">Object</span>.<span class="hljs-property">create</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">proto</span>)&#123;<br>        <span class="hljs-keyword">function</span> <span class="hljs-title function_">F</span>(<span class="hljs-params"></span>)&#123;&#125;;<br>        F.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = proto;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">F</span>();<br>    &#125;<br>&#125;<br>child.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(parent.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>)<br><span class="hljs-keyword">var</span> c = <span class="hljs-keyword">new</span> <span class="hljs-title function_">child</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(c.<span class="hljs-property">a</span>)<br>c.<span class="hljs-title function_">say</span>()<br></code></pre></td></tr></table></figure></li></ul><h2 id="★九、对象的深拷贝和浅拷贝"><a href="#★九、对象的深拷贝和浅拷贝" class="headerlink" title="★九、对象的深拷贝和浅拷贝"></a>★九、对象的深拷贝和浅拷贝</h2><p>不同类型的复制方式：</p><ul><li>基本类型：从一个变量向另外一个新变量复制基本类型的值，会创建这个值的一个副本，并将该副本复制给新变量</li><li>引用类型：从一个变量向另一个新变量复制引用类型的值，其实复制的是指针，最终两个变量最终都指向同一个对象<br><strong>深拷贝和浅拷贝</strong>：</li><li>浅拷贝：仅仅是复制了引用，彼此之间的操作会互相影响。</li><li>深拷贝：在堆中重新分配内存，不同的地址，相同的值，互不影响。相当于重新建立了变量。</li></ul><p><strong>实现深拷贝</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">deepCopy</span>(<span class="hljs-params">object</span>) &#123;<br>  <span class="hljs-keyword">if</span> (!object || <span class="hljs-keyword">typeof</span> object !== <span class="hljs-string">&quot;object&quot;</span>) <span class="hljs-keyword">return</span> object;<br><br>  <span class="hljs-keyword">let</span> newObject = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(object) ? [] : &#123;&#125;;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> object) &#123;<br>    <span class="hljs-keyword">if</span> (object.<span class="hljs-title function_">hasOwnProperty</span>(key)) &#123;<br>      newObject[key] = <span class="hljs-title function_">deepCopy</span>(object[key]);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> newObject;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>解决循环引用的深拷贝</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">deepClone</span>(<span class="hljs-params">obj, hash = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakMap</span>()</span>) &#123;<br>  <span class="hljs-keyword">if</span> (!object || <span class="hljs-keyword">typeof</span> object !== <span class="hljs-string">&quot;object&quot;</span>) <span class="hljs-keyword">return</span> object;<br><br>  <span class="hljs-comment">// 是对象的话就要进行深拷贝,遇到循环引用，将引用存储起来，如果存在就不再拷贝</span><br>  <span class="hljs-keyword">if</span> (hash.<span class="hljs-title function_">get</span>(obj)) <span class="hljs-keyword">return</span> hash.<span class="hljs-title function_">get</span>(obj);<br>  <span class="hljs-keyword">let</span> cloneObj = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(object) ? [] : &#123;&#125;;<br>  hash.<span class="hljs-title function_">set</span>(obj, cloneObj);<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> obj) &#123;<br>    <span class="hljs-keyword">if</span> (obj.<span class="hljs-title function_">hasOwnProperty</span>(key)) &#123;<br>      <span class="hljs-comment">// 实现一个递归拷贝</span><br>      cloneObj[key] = <span class="hljs-title function_">deepClone</span>(obj[key], hash);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> cloneObj;<br></code></pre></td></tr></table></figure><h2 id="十、实现new操作符"><a href="#十、实现new操作符" class="headerlink" title="十、实现new操作符"></a>十、实现new操作符</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myNew</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-comment">//1.创建一个新的对象</span><br>    <span class="hljs-keyword">let</span> obj=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-comment">//获得构造函数</span><br>    <span class="hljs-keyword">let</span> con = [].<span class="hljs-property">shift</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>); <span class="hljs-comment">//[]为Array构造函数的实例  将类数组转化为真正的数组</span><br>    <span class="hljs-comment">//2.新对象的隐式原型__proto__链接到构造函数的显式原型prototype</span><br>    obj.<span class="hljs-property">__proto__</span> = con.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>;<br>    <span class="hljs-comment">//3.构造函数内部的 this 绑定到这个新创建的对象 执行构造函数</span><br>    <span class="hljs-keyword">let</span> result = con.<span class="hljs-title function_">apply</span>(obj, <span class="hljs-variable language_">arguments</span>)<br>    <span class="hljs-comment">//4.如果构造函数没有返回非空对象，则返回创建的新对象</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> result == <span class="hljs-string">&#x27;object&#x27;</span> ? <span class="hljs-attr">result</span>:obj;<br>&#125;<br><span class="hljs-keyword">var</span> test_create = <span class="hljs-title function_">myNew</span>(<span class="hljs-title class_">Car</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(test_create)<br></code></pre></td></tr></table></figure><h2 id="十一、闭包"><a href="#十一、闭包" class="headerlink" title="十一、闭包"></a>十一、闭包</h2><p><strong>闭包是指有权访问另一个函数作用域中变量的函数</strong>，创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以访问到当前函数的局部变量。<br>闭包有两个常用的用途；</p><ul><li>闭包的第一个用途是使我们在函数外部能够访问到函数内部的变量。通过使用闭包，可以通过在外部调用闭包函数，从而在外部访问到函数内部的变量，可以使用这种方法来创建私有变量。</li><li>闭包的另一个用途是使已经运行结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象的引用，所以这个变量对象不会被回收。<br>比如，函数 A 内部有一个函数 B，函数 B 可以访问到函数 A 中的变量，那么函数 B 就是闭包。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">A</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span><br>  <span class="hljs-variable language_">window</span>.<span class="hljs-property">B</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)<br>  &#125;<br>&#125;<br><span class="hljs-title function_">A</span>()<br><span class="hljs-title function_">B</span>() <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><p>在 JS 中，闭包存在的意义就是让我们可以间接访问函数内部的变量。经典面试题：循环中使用闭包解决 var 定义函数的问题</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">timer</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i)<br>  &#125;, i * <span class="hljs-number">1000</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>首先因为 setTimeout是个异步函数，所以会先把循环全部执行完毕，这时候 i就是 6 了，所以会输出一堆 6。<br>解决办法有三种：<br>①<strong>使用闭包</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) &#123;  <br>    (<span class="hljs-keyword">function</span>(<span class="hljs-params">j</span>) &#123;    <br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">timer</span>(<span class="hljs-params"></span>) &#123;      <br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(j)    <br>        &#125;, j * <span class="hljs-number">1000</span>)  <br>    &#125;)(i)<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述代码中，首先使用了立即执行函数将i传入函数内部，这个时候值就被固定在了参数 j上面不会改变，当下次执行 timer这个闭包的时候，就可以使用外部函数的变量j，从而达到目的。<br>②第二种就是使用 setTimeout的第三个参数，这个参数会被当成 timer函数的参数传入。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">timer</span>(<span class="hljs-params">j</span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(j)<br>    &#125;,<br>    i * <span class="hljs-number">1000</span>,<br>    i<br>  )<br>&#125;<br></code></pre></td></tr></table></figure><p>③第三种就是使用 let定义 i了来解决问题了，这个也是最为推荐的方式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">timer</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i)<br>  &#125;, i * <span class="hljs-number">1000</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="十二、作用域"><a href="#十二、作用域" class="headerlink" title="十二、作用域"></a>十二、作用域</h2><h3 id="12-1-全局作用域和函数作用域"><a href="#12-1-全局作用域和函数作用域" class="headerlink" title="12.1 全局作用域和函数作用域"></a>12.1 全局作用域和函数作用域</h3><p>（1）全局作用域</p><ul><li>最外层函数和最外层函数外面定义的变量拥有全局作用域</li><li>所有未定义直接赋值的变量自动声明为全局作用域</li><li>所有window对象的属性拥有全局作用域</li><li>全局作用域有很大的弊端，过多的全局作用域变量会污染全局命名空间，容易引起命名冲突。<br>（2）函数作用域</li><li>函数作用域声明在函数内部的变零，一般只有固定的代码片段可以访问到</li><li>作用域是分层的，内层作用域可以访问外层作用域，反之不行</li></ul><h3 id="12-2-块级作用域"><a href="#12-2-块级作用域" class="headerlink" title="12.2 块级作用域"></a>12.2 块级作用域</h3><ul><li>使用ES6中新增的let和const指令可以声明块级作用域，块级作用域可以在函数中创建也可以在一个代码块中的创建（由<code>&#123; &#125;</code>包裹的代码片段）</li><li>let和const声明的变量不会有变量提升，也不可以重复声明</li><li>在循环中比较适合绑定块级作用域，这样就可以把声明的计数器变量限制在循环内部。<br><strong>作用域链：</strong> 在当前作用域中查找所需变量，但是该作用域没有这个变量，那这个变量就是自由变量。如果在自己作用域找不到该变量就去父级作用域查找，依次向上级作用域查找，直到访问到window对象就被终止，这一层层的关系就是作用域链。<br>作用域链的作用是<strong>保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，可以访问到外层环境的变量和函数。</strong><br>作用域链的本质上是一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象。作用域链的前端始终都是当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象。<br>当查找一个变量时，如果当前执行环境中没有找到，可以沿着作用域链向后查找。</li></ul><h2 id="十三、执行上下文"><a href="#十三、执行上下文" class="headerlink" title="十三、执行上下文"></a>十三、执行上下文</h2><h3 id="13-1-执行上下文类型"><a href="#13-1-执行上下文类型" class="headerlink" title="13.1 执行上下文类型"></a>13.1 执行上下文类型</h3><p><strong>（1）全局执行上下文</strong><br>任何不在函数内部的都是全局执行上下文，它首先会创建一个全局的window对象，并且设置this的值等于这个全局对象，一个程序中只有一个全局执行上下文。<br><strong>（2）函数执行上下文</strong><br>当一个函数被调用时，就会为该函数创建一个新的执行上下文，函数的上下文可以有任意多个。<br><strong>（3）</strong>eval<strong>函数执行上下文</strong><br>执行在eval函数中的代码会有属于他自己的执行上下文，不过eval函数不常使用，不做介绍。</p><h3 id="13-2-执行上下文栈"><a href="#13-2-执行上下文栈" class="headerlink" title="13.2 执行上下文栈"></a>13.2 执行上下文栈</h3><ul><li>JavaScript引擎使用执行上下文栈来管理执行上下文</li><li>当JavaScript执行代码时，首先遇到全局代码，会创建一个全局执行上下文并且压入执行栈中，每当遇到一个函数调用，就会为该函数创建一个新的执行上下文并压入栈顶，引擎会执行位于执行上下文栈顶的函数，当函数执行完成之后，执行上下文从栈中弹出，继续执行下一个上下文。当所有的代码都执行完毕之后，从栈中弹出全局执行上下文。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> a = <span class="hljs-string">&#x27;Hello World!&#x27;</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">first</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Inside first function&#x27;</span>);<br>  <span class="hljs-title function_">second</span>();<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Again inside first function&#x27;</span>);<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">second</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Inside second function&#x27;</span>);<br>&#125;<br><span class="hljs-title function_">first</span>();<br><span class="hljs-comment">//执行顺序</span><br><span class="hljs-comment">//先执行second(),在执行first()</span><br></code></pre></td></tr></table></figure><h3 id="13-3-创建执行上下文"><a href="#13-3-创建执行上下文" class="headerlink" title="13.3 创建执行上下文"></a>13.3 创建执行上下文</h3><p>创建执行上下文有两个阶段：<strong>创建阶段</strong>和<strong>执行阶段</strong><br><strong>1）创建阶段</strong><br>（1）this绑定</p><ul><li>在全局执行上下文中，this指向全局对象（window对象）</li><li>在函数执行上下文中，this指向取决于函数如何调用。如果它被一个引用对象调用，那么 this 会被设置成那个对象，否则 this 的值被设置为全局对象或者 undefined</li></ul><p>（2）创建词法环境组件</p><ul><li>词法环境是一种有<strong>标识符——变量映射</strong>的数据结构，标识符是指变量&#x2F;函数名，变量是对实际对象或原始数据的引用。</li><li>词法环境的内部有两个组件：<strong>加粗样式</strong>：环境记录器:用来储存变量个函数声明的实际位置<strong>外部环境的引用</strong>：可以访问父级作用域</li></ul><p>（3）创建变量环境组件</p><p>变量环境也是一个词法环境，其环境记录器持有变量声明语句在执行上下文中创建的绑定关系。<br><strong>2）执行阶段</strong> 此阶段会完成对变量的分配，最后执行完代码。<br><strong>简单来说执行上下文就是指：</strong><br>在执行一点JS代码之前，需要先解析代码。解析的时候会先创建一个全局执行上下文环境，先把代码中即将执行的变量、函数声明都拿出来，变量先赋值为undefined，函数先声明好可使用。这一步执行完了，才开始正式的执行程序。<br>在一个函数执行之前，也会创建一个函数执行上下文环境，跟全局执行上下文类似，不过函数执行上下文会多出this、arguments和函数的参数。</p><ul><li>全局上下文：变量定义，函数声明</li><li>函数上下文：变量定义，函数声明，this，arguments</li></ul><h1 id="五、异步编程"><a href="#五、异步编程" class="headerlink" title="五、异步编程"></a>五、异步编程</h1><h2 id="一、异步编程实现方式"><a href="#一、异步编程实现方式" class="headerlink" title="一、异步编程实现方式"></a>一、异步编程实现方式</h2><ul><li><strong>回调函数</strong>：其它函数在满足某个条件或发生某个（异步）事件时调用（回调）这个函数。缺点是多个回调函数嵌套时会造成回调函数地狱，上下两层回调函数之间代码耦合度太高，不利于代码的维护。</li><li><strong>Promise</strong>：将嵌套的回调函数作为链式调用，使用这个方法有时会造成多个then的链式调用，可能会造成代码语义不够明确。</li><li><strong>generator</strong>：可以在函数的执行过程中，将函数的执行权转移出去，在函数外部还可以将执行权转移回来。当遇到异步函数执行的时候，将函数执行权转移出去，当异步函数执行完毕时再将执行权给转移回来。因此在generator内部对于异步操作的方式，可以以同步的顺序来书写。使用这种方式需要考虑的问题是何时将函数的控制权转移回来，因此需要有一个自动执行generator的机制，比如说 co 模块等方式来实现 generator 的自动执行。</li><li><strong>async&#x2F;await</strong>：async函数是generator和promise实现的一个自动执行的语法糖，它内部自带执行器，当函数内部执行到一个await语句的时候，如果语句返回一个promise对象，那么函数将会等待promise对象的状态变为resolve后再继续向下执行。因此可以将异步逻辑，转化为同步的顺序来书写，并且这个函数可以自动执行。</li></ul><h2 id="二、定时器setTimeout、setInterval、requestAnimationFrame"><a href="#二、定时器setTimeout、setInterval、requestAnimationFrame" class="headerlink" title="二、定时器setTimeout、setInterval、requestAnimationFrame"></a>二、定时器setTimeout、setInterval、requestAnimationFrame</h2><p><strong>setTimeout</strong>只在指定时间后执行一次。如果前面代码影响了性能，会导致setTimeout不能按期执行，因为定时器属于宏任务，宏任务必须等待同步任务执行完成，再等微任务执行完成才会执行其中回调函数。时间单位为毫秒。其返回值通过clearTimeout()来关闭定时器。<br>下面为计算每次执行setTimeout的间隔</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> period = <span class="hljs-number">60</span> * <span class="hljs-number">1000</span> * <span class="hljs-number">60</span> * <span class="hljs-number">2</span>  <span class="hljs-comment">// 一个周期为两个小时</span><br><span class="hljs-keyword">let</span> startTime = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getTime</span>() <span class="hljs-comment">//开始时间</span><br><span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span> <span class="hljs-comment">// 循环次数</span><br><span class="hljs-keyword">let</span> end = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getTime</span>() + period <span class="hljs-comment">// 期待结束时间</span><br><span class="hljs-keyword">let</span> interval = <span class="hljs-number">1000</span><br><span class="hljs-keyword">let</span> currentInterval = interval<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">loop</span>(<span class="hljs-params"></span>) &#123;<br>  count++ <span class="hljs-comment">// 循环增加一次</span><br>  <span class="hljs-comment">// 代码执行所消耗的时间</span><br>  <span class="hljs-keyword">let</span> offset = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getTime</span>() - (startTime + count * interval);<br>  <span class="hljs-keyword">let</span> diff = end - <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getTime</span>() <span class="hljs-comment">//距离结束时间</span><br>  <span class="hljs-keyword">let</span> h = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(diff / (<span class="hljs-number">60</span> * <span class="hljs-number">1000</span> * <span class="hljs-number">60</span>)) <span class="hljs-comment">//离结束还有多少小时</span><br>  <span class="hljs-keyword">let</span> hdiff = diff % (<span class="hljs-number">60</span> * <span class="hljs-number">1000</span> * <span class="hljs-number">60</span>) <span class="hljs-comment">//离结束剩余一个小时内多长时间</span><br>  <span class="hljs-keyword">let</span> m = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(hdiff / (<span class="hljs-number">60</span> * <span class="hljs-number">1000</span>)) <span class="hljs-comment">//离结束剩余一个小时内多少分钟</span><br>  <span class="hljs-keyword">let</span> mdiff = hdiff % (<span class="hljs-number">60</span> * <span class="hljs-number">1000</span>) <span class="hljs-comment">//离结束剩余一分钟内多少时间</span><br>  <span class="hljs-keyword">let</span> s = mdiff / (<span class="hljs-number">1000</span>) <span class="hljs-comment">// 离结束剩余一分钟内多少秒</span><br>  <span class="hljs-keyword">let</span> sCeil = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">ceil</span>(s)<br>  <span class="hljs-keyword">let</span> sFloor = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(s)<br>  <span class="hljs-comment">// 得到下一次循环所消耗的时间</span><br>  currentInterval = interval - offset<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;时：&#x27;</span>+h, <span class="hljs-string">&#x27;分：&#x27;</span>+m, <span class="hljs-string">&#x27;毫秒：&#x27;</span>+s, <span class="hljs-string">&#x27;秒向上取整：&#x27;</span>+sCeil, <span class="hljs-string">&#x27;代码执行时间：&#x27;</span>+offset, <span class="hljs-string">&#x27;下次循环间隔&#x27;</span>+currentInterval)<br>  <span class="hljs-built_in">setTimeout</span>(loop, currentInterval)<br>&#125;<br><span class="hljs-built_in">setTimeout</span>(loop, currentInterval)<br></code></pre></td></tr></table></figure><p><strong>setInterval</strong>以指定时间为周期循环执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">demo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-built_in">setInterval</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>)<br>  &#125;,<span class="hljs-number">1000</span>)<br>  <span class="hljs-title function_">sleep</span>(<span class="hljs-number">2000</span>)<br>&#125;<br><span class="hljs-title function_">demo</span>()<br></code></pre></td></tr></table></figure><p>一般情况下setTimeout用于延迟执行某种方法或功能，setInerval一般用于刷新表单，对一些表单的假实时指定时间刷新同步。<br><strong>requestAnimationFrame</strong>自带函数节流功能，基本可以保证在16.6毫秒（60Hz刷新频率）内只执行一次（不掉帧的情况下），且该函数的延迟效果是精确的。优势是由系统决定回调函数的执行时机，每次刷新的间隔中会执行一次回调函数，不会引起丢帧和卡顿。可以用来实现循环定时器。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">setInterval</span>(<span class="hljs-params">callback, interval</span>) &#123;<br>  <span class="hljs-keyword">let</span> timer<br>  <span class="hljs-keyword">const</span> now = <span class="hljs-title class_">Date</span>.<span class="hljs-property">now</span><br>  <span class="hljs-keyword">let</span> startTime = <span class="hljs-title function_">now</span>()<br>  <span class="hljs-keyword">let</span> endTime = startTime<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">loop</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    timer = <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">requestAnimationFrame</span>(loop)<br>    endTime = <span class="hljs-title function_">now</span>()<br>    <span class="hljs-keyword">if</span> (endTime - startTime &gt;= interval) &#123;<br>      startTime = endTime = <span class="hljs-title function_">now</span>()<br>      <span class="hljs-title function_">callback</span>(timer)<br>    &#125;<br>  &#125;<br>  timer = <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">requestAnimationFrame</span>(loop)<br>  <span class="hljs-keyword">return</span> timer<br>&#125;<br><span class="hljs-keyword">let</span> a = <span class="hljs-number">0</span><br><span class="hljs-built_in">setInterval</span>(<span class="hljs-function"><span class="hljs-params">timer</span> =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>)<br>  a++<br>  <span class="hljs-keyword">if</span> (a === <span class="hljs-number">3</span>) <span class="hljs-title function_">cancelAnimationFrame</span>(timer)<br>&#125;, <span class="hljs-number">1000</span>)<br></code></pre></td></tr></table></figure><p><strong>setInterval和setTimeout互相实现</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myInterval</span>(<span class="hljs-params">fn, delay,isPause</span>) &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">interval</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>        <span class="hljs-built_in">setTimeout</span>(interval ,delay)<br>        <span class="hljs-title function_">fn</span>()<br>    &#125;<br>    <span class="hljs-built_in">setTimeout</span>(interval, delay)<br>&#125;<br><span class="hljs-comment">//setInterval实现 setTimeout</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">mySetTimeOut</span>(<span class="hljs-params">fn,delay</span>)=&gt;&#123;<br>    <span class="hljs-keyword">let</span> timer = <span class="hljs-title function_">setInterVal</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-built_in">clearInterval</span>(timer)<br>        <span class="hljs-title function_">fn</span>()<br>    &#125;,delay)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="★三、宏任务与微任务"><a href="#★三、宏任务与微任务" class="headerlink" title="★三、宏任务与微任务"></a>★三、宏任务与微任务</h2><p><strong>宏任务</strong>：js执行的任务，是由宿主（Node、浏览器）发起的，后运行，会触发新一轮的Tick，主要包括：</p><ul><li>script里代码（全局代码）</li><li>setTimeout、setInterval</li><li>UI事件</li><li>postMessage、MessageChannel（主要用于不同浏览器上下文通信、worker跨线程通信、对象深拷贝，利用消息在发送和接收的过程中进行序列化和反序列化）</li><li>setImmediate（异步执行某些代码但要尽快执行），I&#x2F;O (Node.js）</li></ul><p><strong>微任务</strong>：是由JS引擎发起的，先运行，不会触发新一轮的Tick。主要包括：</p><ul><li>Promise</li><li>process.nextTick(Node.js定义一个动作，让其在下一个事件轮询的时间点上执行）</li><li>Object.observe</li><li>MutaionObserver</li></ul><h3 id="事件轮询执行顺序（宏任务和微任务怎样执行）"><a href="#事件轮询执行顺序（宏任务和微任务怎样执行）" class="headerlink" title="事件轮询执行顺序（宏任务和微任务怎样执行）"></a>事件轮询执行顺序（宏任务和微任务怎样执行）</h3><ol><li>先执行同步代码（取出一个宏任务），遇到异步宏任务就将其放入宏任务队列中，遇到异步微任务就将其放入微任务队列中。</li><li>当所有同步代码执行完毕后，再将异步微任务从队列中调入主线程执行，然后进行UI渲染。</li><li>执行下一个宏任务，执行下一个所有微任务，进行UI渲染，循环这个过程。<br>即<strong>先执行宏任务，执行完后看微任务队列是否有微任务，没有微任务浏览器渲染后执行下一个宏任务，有微任务则将所有微任务执行，执行完浏览器渲染后再执行下一个宏任务</strong>。</li></ol><h2 id="四、setTimeout、Promise、Async-x2F-await的区别"><a href="#四、setTimeout、Promise、Async-x2F-await的区别" class="headerlink" title="四、setTimeout、Promise、Async&#x2F;await的区别"></a>四、setTimeout、Promise、Async&#x2F;await的区别</h2><h3 id="4-1-setTimeout"><a href="#4-1-setTimeout" class="headerlink" title="4.1 setTimeout"></a>4.1 setTimeout</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;script start&#x27;</span>) <span class="hljs-comment">//1. 打印 script start</span><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;settimeout&#x27;</span>) <span class="hljs-comment">// 4. 打印 settimeout</span><br>&#125;)  <span class="hljs-comment">// 2. 调用 setTimeout 函数，并定义其完成后执行的回调函数</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;script end&#x27;</span>) <span class="hljs-comment">//3. 打印 script start</span><br><span class="hljs-comment">// 输出顺序：script start-&gt;script end-&gt;settimeout</span><br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="4-2-Promise"><a href="#4-2-Promise" class="headerlink" title="4.2 Promise"></a>4.2 Promise</h3><p>Promise本身是<strong>同步的立即执行函数</strong>，有Pending（进行中）、Resolved（已完成）、Rejected（已拒绝）三种状态。 当把一件事情交给promise时，它的状态就是Pending，任务完成了状态就变成了Resolved、没有完成失败了就变成了Rejected。<br>Promise的实例有两个过程：<br>pending &#x3D;&gt; fulfilled : Resolved(已完成)<br>pending &#x3D;&gt; rejected: Rejected (已拒绝)<br>注意: 一旦从进行状态变成为其他状态就永远不能更改状态了。<br>当在executor中执行resolve或者reject的时候, 此时是异步操作，会先执行then&#x2F;catch等，当主栈完成后，才会去调用resolve&#x2F;reject中存放的方法执行，打印p的时候，是打印的返回结果，一个Promise实例。</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>对象的状态不受外界影响，promise对象代表一个异步操作，只有异步操作的结果可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。</li><li>一旦状态改变就不会再变，任何时候都可以得到这个结果。如果改变已经发生了，再对promise对象添加回调函数也会立即得到这个结果。这与事件完全不同，事件的特点是如果错过了它再去监听得不到结果。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;script start&#x27;</span>)<br><span class="hljs-keyword">let</span> promise1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;promise1&#x27;</span>)<br>    <span class="hljs-title function_">resolve</span>()<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;promise1 end&#x27;</span>)<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;promise2&#x27;</span>)<br>&#125;)<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;settimeout&#x27;</span>)<br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;script end&#x27;</span>)<br><span class="hljs-comment">// 输出顺序: script start-&gt;promise1-&gt;promise1 end-&gt;script end-&gt;promise2-&gt;settimeout</span><br></code></pre></td></tr></table></figure>当JS主线程执行到Promise对象时：</li><li>promise1.then() 的回调就是一个 task</li><li>promise1 是 resolved或rejected: 那这个 task 就会放入当前事件循环回合的 microtask queue</li><li>promise1 是 pending: 这个 task 就会放入 事件循环的未来的某个(可能下一个)回合的 microtask queue 中</li><li>setTimeout 的回调也是个 task ，它会被放入 macrotask queue 即使是 0ms 的情况</li></ul><h3 id="4-3-async-x2F-await"><a href="#4-3-async-x2F-await" class="headerlink" title="4.3 async&#x2F;await"></a>4.3 async&#x2F;await</h3><p>async的函数返回值是一个Promise对象，await接收一个Promise并将其转换为一个返回值或一个抛出的异常。当函数执行的时候一旦遇上await就会先返回，等到触发的异步操作完成，再执行函数体内后面的语句。<br>可以理解为，是让出了线程，跳出了 async 函数体。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">async1</span>(<span class="hljs-params"></span>)&#123;<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;async1 start&#x27;</span>);<br>    <span class="hljs-keyword">await</span> <span class="hljs-title function_">async2</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;async1 end&#x27;</span>)<br>&#125;<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">async2</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;async2&#x27;</span>)<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;script start&#x27;</span>);<br><span class="hljs-title function_">async1</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;script end&#x27;</span>)<br><span class="hljs-comment">// 输出顺序：script start-&gt;async1 start-&gt;async2-&gt;script end-&gt;async1 end</span><br></code></pre></td></tr></table></figure><p>await的含义为等待，也就是 async 函数需要等待await后的函数执行完成并且有了返回结果（Promise对象）之后，才能继续执行下面的代码。await通过返回一个Promise对象来实现同步的效果。</p><h2 id="五、Promise的理解及实现"><a href="#五、Promise的理解及实现" class="headerlink" title="五、Promise的理解及实现"></a>五、Promise的理解及实现</h2><p>Promise是异步编程的一种解决方案，它是一个对象，可以获取异步操作的消息，他的出现大大改善了异步编程的困境，避免了<strong>地狱回调</strong>，它比传统的解决方案回调函数和事件更合理和更强大。<br>所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。<br><strong>executor是Promise对象的参数，是一段将输出与promise联系起来的自定义代码，函数签名为function(resolutionFunc, rejectionFunc){}</strong><br>（1）Promise的实例有<strong>三个状态</strong>:</p><ul><li>Pending（进行中）</li><li>Resolved（已完成）</li><li>Rejected（已拒绝）<br>当把一件事情交给promise时，它的状态就是Pending，任务完成了状态就变成了Resolved、没有完成失败了就变成了Rejected。</li></ul><p>（2）Promise的实例有<strong>两个过程</strong>：</p><ul><li>pending -&gt; fulfilled : Resolved（已完成）</li><li>pending -&gt; rejected：Rejected（已拒绝）<br>注意：一旦从进行状态变成为其他状态就永远不能更改状态了。<br><strong>Promise的特点：</strong></li><li>对象的状态不受外界影响。promise对象代表一个异步操作，有三种状态，pending（进行中）、fulfilled（已成功）、rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。</li><li>一旦状态改变就不会再变，任何时候都可以得到这个结果。promise对象的状态改变，只有两种可能：从pending变为fulfilled，从pending变为rejected。这时就称为resolved（已定型）。如果改变已经发生了，你再对promise对象添加回调函数，也会立即得到这个结果。这与事件（event）完全不同，事件的特点是：如果你错过了它，再去监听是得不到结果的。<br><strong>Promise的缺点：</strong></li><li>无法取消Promise，一旦新建它就会立即执行，无法中途取消。</li><li>如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。</li><li>当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。<br><strong>总结：</strong> Promise 对象是异步编程的一种解决方案。Promise 是一个构造函数，接收一个函数作为参数，返回一个 Promise 实例。一个 Promise 实例有三种状态，分别是pending、resolved 和 rejected，分别代表了进行中、已成功和已失败。实例的状态只能由 pending 转变 resolved 或者rejected 状态，并且状态一经改变，就凝固了，无法再被改变了。<br>状态的改变是通过 resolve() 和 reject() 函数来实现的，可以在异步操作结束后调用这两个函数改变 Promise 实例的状态，它的原型上定义了一个 then 方法，使用这个 then 方法可以为两个状态的改变注册回调函数。这个回调函数属于微任务，会在本轮事件循环的末尾执行。<br><strong>注意：</strong> 在构造Promise的时候，构造函数内部的代码是立即执行的。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) &#123;<span class="hljs-comment">//参数是两个函数</span><br> <span class="hljs-comment">// ... some code</span><br> <span class="hljs-keyword">if</span> (<span class="hljs-comment">/* 异步操作成功*/</span>)&#123;<br>  <span class="hljs-title function_">resolve</span>(value); <span class="hljs-comment">//将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；</span><br> &#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-title function_">reject</span>(error);<br> &#125;<br>&#125;); <span class="hljs-comment">//resolv和reject是同步执行的，改变状态返回值就确定了</span><br></code></pre></td></tr></table></figure>Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">promise.<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) &#123;<br> <span class="hljs-comment">// success,Promise对象的状态变为resolved时调用</span><br>&#125;, <span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) &#123;<br> <span class="hljs-comment">// failure,Promise对象的状态变为rejected时调用</span><br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//excutor 执行构造器 Promise：构造promise函数对象</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Promise</span>(<span class="hljs-params">excutor</span>)&#123;<br>    <span class="hljs-keyword">const</span> _that = <span class="hljs-variable language_">this</span>;<br>    _that.<span class="hljs-property">status</span> = <span class="hljs-string">&#x27;pending&#x27;</span>; <span class="hljs-comment">//promise绑定status属性，初始值pending</span><br>    _that.<span class="hljs-property">data</span> = <span class="hljs-literal">undefined</span>;  <span class="hljs-comment">//promise绑定data指定一个存储结果的属性</span><br>    _that.<span class="hljs-property">callbacks</span> = [];    <span class="hljs-comment">//每个元素的结构：&#123; onFulfilled()&#123;&#125;, onRejected()&#123;&#125;&#125;</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-params">value</span>)&#123;<br>        <span class="hljs-keyword">if</span>(_that.<span class="hljs-property">status</span> !== <span class="hljs-string">&#x27;pending&#x27;</span>) <span class="hljs-keyword">return</span>    <span class="hljs-comment">//如果当前状态不是pending直接结束</span><br>        _that.<span class="hljs-property">status</span> = <span class="hljs-string">&#x27;resolved&#x27;</span> <span class="hljs-comment">//改状态</span><br>        _that.<span class="hljs-property">data</span> = value;    <span class="hljs-comment">//保存数据</span><br>        <span class="hljs-keyword">if</span>(value <span class="hljs-keyword">instanceof</span> promise)&#123;<br>          <span class="hljs-keyword">return</span> value.<span class="hljs-title function_">then</span>(resolve,reject)<br>    &#125;<br>         <span class="hljs-comment">// 为什么resolve 加setTimeout?</span><br>        <span class="hljs-comment">// 2.2.4规范 onFulfilled 和 onRejected 只允许在 execution context 栈仅包含平台代码时运行.</span><br>        <span class="hljs-comment">// 注1 这里的平台代码指的是引擎、环境以及 promise 的实施代码。实践中要确保 onFulfilled 和 onRejected 方法异步执行，且应该在 then 方法被调用的那一轮事件循环之后的新执行栈中执行。</span><br>        <span class="hljs-keyword">if</span>(_that.<span class="hljs-property">callbacks</span>.<span class="hljs-property">length</span> &gt;<span class="hljs-number">0</span>)&#123; <span class="hljs-comment">// 如果有待执行callback 函数，立刻异步执行回调函数</span><br>            <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>                _that.<span class="hljs-property">callbacks</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">callbackobj</span> =&gt;</span>&#123;<br>                    callbackobj.<span class="hljs-title function_">onFulfilled</span>(value)<br>                &#125;)<br>            &#125;)<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">reject</span>(<span class="hljs-params">reason</span>)&#123;<br>        <span class="hljs-keyword">if</span>(_that.<span class="hljs-property">status</span> !== <span class="hljs-string">&#x27;pending&#x27;</span>) <span class="hljs-keyword">return</span>    <span class="hljs-comment">//如果当前状态不是pending直接结束</span><br>        _that.<span class="hljs-property">status</span> = <span class="hljs-string">&#x27;rejected&#x27;</span> <span class="hljs-comment">//改状态</span><br>        _that.<span class="hljs-property">data</span> = reason;    <span class="hljs-comment">//保存数据</span><br>        <span class="hljs-keyword">if</span>(_that.<span class="hljs-property">callbacks</span>.<span class="hljs-property">length</span> &gt;<span class="hljs-number">0</span>)&#123; <span class="hljs-comment">// 如果有待执行callback 函数，立刻异步执行回调函数</span><br>            <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>                _that.<span class="hljs-property">callbacks</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">callbackobj</span> =&gt;</span>&#123;<br>                    callbackobj.<span class="hljs-title function_">onRejected</span>(reason)<br>                &#125;)<br>            &#125;)<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//立刻同步执行 excutor</span><br>    <span class="hljs-keyword">try</span>&#123;<br>        <span class="hljs-title function_">excutor</span>(resolve,reject)<br>    &#125;.<span class="hljs-title function_">catch</span>(<span class="hljs-params">error</span>)&#123;  <span class="hljs-comment">//如果执行器抛出异常，promise对象变为 rejected 状态</span><br>        <span class="hljs-title function_">reject</span>(error)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="六、Promise的基本用法"><a href="#六、Promise的基本用法" class="headerlink" title="六、Promise的基本用法"></a>六、Promise的基本用法</h2><h3 id="6-1-创建Promise对象"><a href="#6-1-创建Promise对象" class="headerlink" title="6.1 创建Promise对象"></a>6.1 创建Promise对象</h3><p>Promise对象代表一个异步操作，包括pending进行中、fulfilled兑现、rejected拒绝。Promise构造函数接收一个函数作为参数，该函数的两个参数分别为resolve和reject。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) &#123;<br>  <span class="hljs-comment">// ... some code</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-comment">/* 异步操作成功*/</span>)&#123;<br>    <span class="hljs-title function_">resolve</span>(value);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-title function_">reject</span>(error);<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>一般情况下都会使用new Promise()来创建Promise对象，但也可以使用promise.resolve和promise.reject这两个方法</strong></p><h3 id="6-2-Promise-resolve-value"><a href="#6-2-Promise-resolve-value" class="headerlink" title="6.2 Promise.resolve(value)"></a>6.2 Promise.resolve(value)</h3><p>该方法的返回值是一个以value值兑现的Promise对象。如果这个值带有then方法，返回的Promise对象以then的回调返回的值<strong>解决</strong>。如果传入的值value本身就是Promise对象，则该对象作为Promise.resolve方法的返回值返回，其它情况以该值为成功状态返回一个Promise对象。</p><ul><li>例如：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//如果传入的 value 本身就是 Promise 对象，则该对象作为 Promise.resolve 方法的返回值返回。</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">resolve</span>)&#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-number">123</span>);<br>  &#125;,<span class="hljs-number">3000</span>);<br>&#125;<br><span class="hljs-keyword">let</span> p0 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(fn);<br><span class="hljs-keyword">let</span> p1 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(p0);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p0 === p1); <span class="hljs-comment">// 返回为true，返回的 Promise 即是 入参的 Promise 对象。</span><br></code></pre></td></tr></table></figure></li><li>例如：传入thenable对象，返回Promise对象跟随thenable对象的最终状态。ES6 Promises里提到了Thenable这个概念，简单来说它就是一个非常类似Promise的东西。最简单的例子就是jQuery.ajax，它的返回值就是thenable对象。但是并不是只要实现了then方法就一定能作为Promise对象来使用。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//如果传入的 value 本身就是 thenable 对象，返回的 promise 对象会跟随 thenable 对象的状态。</span><br><span class="hljs-keyword">let</span> promise = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>($.<span class="hljs-title function_">ajax</span>(<span class="hljs-string">&#x27;/test/test.json&#x27;</span>));<span class="hljs-comment">// =&gt; promise对象</span><br>promise.<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>)&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<br>&#125;);<br><span class="hljs-comment">//返回一个状态已变成 resolved 的 Promise 对象。</span><br><span class="hljs-keyword">let</span> p1 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">123</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1)<span class="hljs-comment">//打印p1 可以看到p1是一个状态置为resolved的Promise对象</span><br></code></pre></td></tr></table></figure></li><li>例如：对返回值进行then调用<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">11</span>).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>)&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value); <span class="hljs-comment">// 打印出11</span><br>&#125;);<br></code></pre></td></tr></table></figure>resolve(11)代码中，会让promise对象进入确定(resolve状态)，并将参数11传递给后面的then所指定的onFulfilled函数；<br><strong>创建promise对象可以使用new Promise的形式创建对象，也可以使用Promise.resolve(value)的形式创建promise对象；</strong></li></ul><h3 id="6-3-Promise-reject-value"><a href="#6-3-Promise-reject-value" class="headerlink" title="6.3 Promise.reject(value)"></a>6.3 Promise.reject(value)</h3><p>与Promise.resolve唯一不同的是，返回的值是一个以该参数为理由拒绝的Promise对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">resolve</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">reason</span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>        <span class="hljs-title function_">reject</span>(reason)<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>使用方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;我错了&quot;</span>));<br></code></pre></td></tr></table></figure><p>下面是使用resolve方法和reject方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">testPromise</span>(<span class="hljs-params">ready</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve,reject</span>)&#123;<br>    <span class="hljs-keyword">if</span>(ready) &#123;<br>      <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;hello world&quot;</span>);<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-title function_">reject</span>(<span class="hljs-string">&quot;No thanks&quot;</span>);<br>    &#125;<br>  &#125;);<br>&#125;;<br><span class="hljs-comment">// 方法调用</span><br><span class="hljs-title function_">testPromise</span>(<span class="hljs-literal">true</span>).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">msg</span>)&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(msg);<br>&#125;,<span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>)&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error);<br>&#125;);<br></code></pre></td></tr></table></figure><p>上面的代码的含义是给testPromise方法传递一个参数，返回一个promise对象，如果为true的话，那么调用promise对象中的resolve()方法，并且把其中的参数传递给后面的then第一个函数内，因此打印出“hello world”,如果为false的话，会调用promise对象中的reject()方法，则会进入then的第二个函数内，会打印No thanks</p><h3 id="6-4-Promise-then"><a href="#6-4-Promise-then" class="headerlink" title="6.4 Promise.then()"></a>6.4 Promise.then()</h3><p>作用是为Promise实例添加状态改变时的回调函数，<strong>then里面可以传入两个回调函数，第一个回调函数在期约被兑现时调用，第二个回调函数在期约被拒绝时调用</strong>，第二个参数可以省略。<br>then方法的返回值是一个新的Promise对象，可以使用链式写法，即一个then方法后面再调用另一个then方法。<strong>返回的Promise对象p</strong>的状态由then指定的<strong>回调函数</strong>执行的结果决定：</p><ol><li>如果抛出异常，新的Promise对象为rejected拒绝状态，resaon为抛出的异常。</li><li>如果返回的值是非期约值，那么新Promise为resolved兑现，对象，返回值为对象成功的值value，默认的返回undefined，也是成功。</li><li>如果返回的是一个新的期约Promise为v，那么p以v解决，这个新的Promise的返回值就是then返回的Promise的值。<br>then中的回调函数一定要return一个结果或一个新的Promise对象，才能让之后的then回调接收。<br>实现思路：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    Promise原型对象的then()思路：注册fulfilled状态/rejected状态对应的回调函数</span><br><span class="hljs-comment">      1、指定成功和失败的回调函数</span><br><span class="hljs-comment">      2、返回一个新的 promise 对象</span><br><span class="hljs-comment">      3、返回promise的结果由 onFulfilled/onRejected执行结果决定</span><br><span class="hljs-comment">      4、指定 onFulfilled/onRejected的默认值</span><br><span class="hljs-comment">     注意的点： then里面的FULFILLED/REJECTED状态时为什么要加setTimeout?</span><br><span class="hljs-comment">     原因:</span><br><span class="hljs-comment">     其一 要确保 onFulfilled 和 onRejected 方法异步执行(且应该在 then 方法被调用的那一轮事件循环之后的新执行栈中执行) 所以要在resolve里加上setTimeout</span><br><span class="hljs-comment">     其二 对于一个promise，它的then方法可以调用多次.（当在其他程序中多次调用同一个promise的then时 由于之前状态已经为FULFILLED/REJECTED状态，则会走的下面逻辑),所以要确保为FULFILLED/REJECTED状态后 也要异步执行onFulfilled/onRejected。也是resolve函数里加setTimeout的原因</span><br><span class="hljs-comment">    // 总之都是 让then方法异步执行 也就是确保onFulfilled/onRejected异步执行</span><br><span class="hljs-comment">*/</span><br><span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">then</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">onFulfilled,onRejected</span>)&#123;<br>   <span class="hljs-comment">// 处理参数默认值 保证参数后续能够继续执行</span><br>    onFulfilled = <span class="hljs-keyword">typeof</span> onFulfilled === <span class="hljs-string">&#x27;function&#x27;</span> ?<br>        onFulfilled : <span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> reason <span class="hljs-comment">//向后传递成功的value</span><br>   <br>    <span class="hljs-comment">//指定默认的失败的回调（实现错误/异常穿透的关键点）</span><br>    onRejected = <span class="hljs-keyword">typeof</span> onRejected === <span class="hljs-string">&#x27;function&#x27;</span> ? onRejected : <span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123;<br>        <span class="hljs-comment">//向后传递失败的reason</span><br>        <span class="hljs-keyword">throw</span> reason<br>    &#125;<br>   <br>    <span class="hljs-keyword">const</span> _that = <span class="hljs-variable language_">this</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>        <span class="hljs-comment">//调用指定的回调函数处理，根据执行结果，改变return的promise的状态</span><br>        <span class="hljs-keyword">function</span> <span class="hljs-title function_">handle</span>(<span class="hljs-params">callback</span>)&#123;<br>            <span class="hljs-comment">//1. 如果抛出异常，return 的promise就会失败，reason 就是 error</span><br>            <span class="hljs-comment">//2. 如果回调函数返回的不是promise，return的promise就会成功，value就是返回的值</span><br>            <span class="hljs-comment">//3.如果回调函数返回的是promise，return的promise的结果就是这个promise的结果</span><br>            <span class="hljs-keyword">try</span>&#123;<br>                <span class="hljs-keyword">const</span> result = <span class="hljs-title function_">callback</span>(_that.<span class="hljs-property">data</span>)<br>                <span class="hljs-keyword">if</span>(result <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise</span>)&#123;<br>                    result.<span class="hljs-title function_">then</span>(resolve,reject)<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-title function_">resolve</span>(result)<br>                &#125;<br>            &#125;<span class="hljs-keyword">catch</span>(error)&#123;<br>                <span class="hljs-title function_">reject</span>(error)<br>            &#125;<br>        &#125;<br>     <br>        <span class="hljs-keyword">if</span>(_that.<span class="hljs-property">status</span> === <span class="hljs-string">&#x27;pending&#x27;</span>)&#123;<span class="hljs-comment">//假设当前状态还是 pending 状态，将回调函数 保存起来</span><br>          <span class="hljs-comment">// 当异步调用resolve/rejected时 将onFulfilled/onRejected收集暂存到集合中</span><br>            _that.<span class="hljs-property">callbacks</span>.<span class="hljs-title function_">push</span>(&#123;<br>                <span class="hljs-title function_">onFulfilled</span>(<span class="hljs-params">value</span>)&#123;<br>                    <span class="hljs-title function_">handle</span>(onFulfilled)<span class="hljs-comment">//改promise的状态为 onFulfilled状态</span><br>                &#125;,<br>                <span class="hljs-title function_">onRejected</span>(<span class="hljs-params">reason</span>) &#123;<br>                    <span class="hljs-title function_">handle</span>(onRejected)  <span class="hljs-comment">//改promise的状态为 onRejected状态</span><br>                &#125;<br>            &#125;)<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(_that.<span class="hljs-property">status</span> === <span class="hljs-string">&#x27;resolved&#x27;</span>)&#123;<span class="hljs-comment">//如果当前是resolved状态，异步执行onresolved并改变return的promise状态</span><br>            <span class="hljs-title function_">setTimeOut</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>                <span class="hljs-title function_">handle</span>(onFulfilled)<br>            &#125;)<br>        &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//如果当前是rejected状态，异步执行onRejected并改变return的promise状态</span><br>            <span class="hljs-title function_">setTimeOut</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>                <span class="hljs-title function_">handle</span>(onRejected)<br>            &#125;)<br>        &#125;<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure>当要写有顺序的异步事件，需要串行时：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>    <span class="hljs-title function_">ajax</span>(<span class="hljs-string">&#x27;first&#x27;</span>).<span class="hljs-title function_">success</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">res</span>)&#123;<br>        <span class="hljs-title function_">resolve</span>(res);<br>    &#125;)<br>&#125;)<br>promise.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resovle,reject</span>)=&gt;</span>&#123;<br>        <span class="hljs-title function_">ajax</span>(<span class="hljs-string">&#x27;second&#x27;</span>).<span class="hljs-title function_">success</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">res</span>)&#123;<br>            <span class="hljs-title function_">resolve</span>(res)<br>        &#125;)<br>    &#125;)<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resovle,reject</span>)=&gt;</span>&#123;<br>        <span class="hljs-title function_">ajax</span>(<span class="hljs-string">&#x27;second&#x27;</span>).<span class="hljs-title function_">success</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">res</span>)&#123;<br>            <span class="hljs-title function_">resolve</span>(res)<br>        &#125;)<br>    &#125;)<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;<br>   <br>&#125;)<br></code></pre></td></tr></table></figure></li></ol><h3 id="6-5-Promise-catch"><a href="#6-5-Promise-catch" class="headerlink" title="6.5 Promise.catch()"></a>6.5 Promise.catch()</h3><p>该方法相当于then的第二个参数，指向reject的回调函数。另一个作用是在执行resolve回调函数前，如果出现错误，抛出异常，不会停止运行，而是进入到catch方法中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    Promise原型对象的 catch()</span><br><span class="hljs-comment">    指定失败的回调函数</span><br><span class="hljs-comment">    返回一个新的 promise 对象</span><br><span class="hljs-comment">*/</span><br><span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">catch</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">onRejected</span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">then</span>(<span class="hljs-literal">undefined</span>,onRejected)<br>&#125;<br><span class="hljs-comment">// 使用方法</span><br><br>p.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;resolved&#x27;</span>,data);<br>&#125;,<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;rejected&#x27;</span>,err);<br>     &#125;<br>);<br>p.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;resolved&#x27;</span>,data);<br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;rejected&#x27;</span>,err);<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="6-6-Promise-all"><a href="#6-6-Promise-all" class="headerlink" title="6.6 Promise.all()"></a>6.6 Promise.all()</h3><p>该方法用于完成并行任务，让多个Promise任务同时执行，它接收一个数组，数组的每一项都是一个Promise对象。当数组中所有Promise状态都达到resolved成功执行，all方法的状态就是resolved，如果有一个状态变成了rejected，那么all方法的状态就是rejected。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 实现</span><br><span class="hljs-title class_">Promise</span>.<span class="hljs-property">all</span>=<span class="hljs-function">(<span class="hljs-params">promises</span>)=&gt;</span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>    <span class="hljs-keyword">const</span> len = promises.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">const</span> res =[];<br>    <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>      <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(promises[i]).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span>=&gt;</span>&#123;<br>        res[i] = data;<br>        index ++;<br>        <span class="hljs-keyword">if</span>(index ===len)&#123;<br>          <span class="hljs-title function_">resolve</span>(res)<br>        &#125;<br>      &#125;,<span class="hljs-function"><span class="hljs-params">error</span>=&gt;</span>&#123;<br>        <span class="hljs-title function_">reject</span>(error)<br>      &#125;)<br>  &#125;<br>  &#125;)<br>&#125;<br><span class="hljs-comment">// 使用</span><br><span class="hljs-keyword">let</span> promise1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>       <span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>);<br>  &#125;,<span class="hljs-number">2000</span>)<br>&#125;);<br><span class="hljs-keyword">let</span> promise2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>       <span class="hljs-title function_">resolve</span>(<span class="hljs-number">2</span>);<br>  &#125;,<span class="hljs-number">1000</span>)<br>&#125;);<br><span class="hljs-keyword">let</span> promise3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>       <span class="hljs-title function_">resolve</span>(<span class="hljs-number">3</span>);<br>  &#125;,<span class="hljs-number">3000</span>)<br>&#125;);<br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([promise1,promise2,promise3]).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);<br>    <span class="hljs-comment">//结果为：[1,2,3]</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>调用all方法时的结果成功的时候是回调函数的参数也是一个数组，这个数组按顺序保存着每一个promise对象resolve执行时的值。</p><h3 id="6-7-Promise-race"><a href="#6-7-Promise-race" class="headerlink" title="6.7 Promise.race()"></a>6.7 Promise.race()</h3><p>接收的参数是一个每项都是promise的数组，当最先执行完的事件执行完后，直接返回该Promise对象的值。如果第一个返回的Promise对象状态是resolved，那么自身状态是resolved，反之自身状态为rejected。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 实现</span><br><span class="hljs-title class_">Promise</span>.<span class="hljs-property">race</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">promises</span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>        promises.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">promise</span>=&gt;</span>&#123;<br>            <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(promise).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span>=&gt;</span>&#123;<br>                <span class="hljs-title function_">resolve</span>(date)<br>            &#125;,<span class="hljs-function"><span class="hljs-params">error</span>=&gt;</span>&#123;<br>                <span class="hljs-title function_">reject</span>(error)<br>            &#125;)<br>        &#125;)<br>    &#125;)<br>&#125;<br><span class="hljs-comment">// 使用</span><br><span class="hljs-keyword">let</span> promise1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>       <span class="hljs-title function_">reject</span>(<span class="hljs-number">1</span>);<br>  &#125;,<span class="hljs-number">2000</span>)<br>&#125;);<br><span class="hljs-keyword">let</span> promise2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>       <span class="hljs-title function_">resolve</span>(<span class="hljs-number">2</span>);<br>  &#125;,<span class="hljs-number">1000</span>)<br>&#125;);<br><span class="hljs-keyword">let</span> promise3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>       <span class="hljs-title function_">resolve</span>(<span class="hljs-number">3</span>);<br>  &#125;,<span class="hljs-number">3000</span>)<br>&#125;);<br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>([promise1,promise2,promise3]).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);<br>  <span class="hljs-comment">//结果：2</span><br>&#125;,<span class="hljs-function"><span class="hljs-params">rej</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(rej)&#125;;<br>)<br></code></pre></td></tr></table></figure><p>实际中当遇到做一件事，超过多长时间就不做了时，用这个方法来解决：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">Promise<span class="hljs-selector-class">.race</span>(<span class="hljs-selector-attr">[promise1,timeOutPromise(5000)]</span>)<span class="hljs-selector-class">.then</span>(res=&gt;&#123;&#125;)<br></code></pre></td></tr></table></figure><h3 id="6-8-Promise-finally"><a href="#6-8-Promise-finally" class="headerlink" title="6.8 Promise.finally()"></a>6.8 Promise.finally()</h3><p>该方法用于指定不管Promise对象最后状态如何，都会执行的操作，在期约落定的时候调用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;···&#125;)<br>.<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;···&#125;)<br>.<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =&gt;</span> &#123;···&#125;);<br></code></pre></td></tr></table></figure><p>在上面代码中，不管Promise最后的状态，执行完then或catch指定的回调函数后，会执行finally方法指定的回调函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 实现</span><br><span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">finally</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">callback</span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>&#123;<br>        <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-title function_">callback</span>(value))<br>    &#125;,<span class="hljs-function"><span class="hljs-params">reason</span>=&gt;</span>&#123;<br>        <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-title function_">callback</span>(reason))<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>finally方法不接收任何参数， 无法知道前面Promise状态是fulfilled还是rejected，这表明finally方法里面的操作与状态无关，不依赖于Promise执行的结果，其本质上是then方法的特例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js">promise.<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">// 语句</span><br>&#125;);<br><span class="hljs-comment">// 等同于</span><br>promise.<span class="hljs-title function_">then</span>(<br>  <span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// 语句</span><br>    <span class="hljs-keyword">return</span> result;<br>  &#125;,<br>  <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// 语句</span><br>    <span class="hljs-keyword">throw</span> error;<br>  &#125;<br>);<br><span class="hljs-comment">// 例：服务器使用Promise处理请求，然后用finally方法关掉服务器</span><br>server.<span class="hljs-title function_">listen</span>(port).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;).<span class="hljs-title function_">finally</span>(server.<span class="hljs-property">stop</span>);<br></code></pre></td></tr></table></figure><h2 id="七、Promise解决的问题"><a href="#七、Promise解决的问题" class="headerlink" title="七、Promise解决的问题"></a>七、Promise解决的问题</h2><ol><li>回调地狱问题</li><li>代码的可读性问题</li><li>信任问题<br><strong>回调地狱问题</strong>：指把函数作为参数层层嵌套请求，使得代码阅读性非常差。有时候前端为了能够拿到异步的数据，使用了大量的回调函数，来获取将来异步执行成功之后的数据。例如在使用ajax发送A请求后，成功拿到数据，需要把数据传给B请求：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)<br>fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./a.txt&#x27;</span>,<span class="hljs-string">&#x27;utf8&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">err,data</span>)&#123;<br>  fs.<span class="hljs-title function_">readFile</span>(data,<span class="hljs-string">&#x27;utf8&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">err,data</span>)&#123;<br>    fs.<span class="hljs-title function_">readFile</span>(data,<span class="hljs-string">&#x27;utf8&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">err,data</span>)&#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data)<br>    &#125;)<br>  &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure>该代码有几个缺点：一是后一个请求依赖于前一个请求成功后，把数据向下传递，会导致多个ajax请求嵌套，代码不够直观，二是如果前后两个请求不需要传递参数的情况下，后一个请求也需要前一个请求成功后再执行下一步操作，这种情况下也需要这样编写代码，导致代码不够直观。若采用Promise：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">read</span>(<span class="hljs-params">url</span>)&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>    fs.<span class="hljs-title function_">readFile</span>(url,<span class="hljs-string">&#x27;utf8&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">error,data</span>)&#123;<br>      error &amp;&amp; <span class="hljs-title function_">reject</span>(error);<br>      <span class="hljs-title function_">resolve</span>(data);<br>    &#125;)<br>  &#125;)<br>&#125;<br><span class="hljs-title function_">read</span>(<span class="hljs-string">&#x27;./a.txt&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span>=&gt;</span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">read</span>(data)<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span>=&gt;</span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">read</span>(data)  <br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span>=&gt;</span>&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data)<br>&#125;)<br></code></pre></td></tr></table></figure></li></ol><h2 id="★八、Promise-all和Promise-race的区别和使用场景"><a href="#★八、Promise-all和Promise-race的区别和使用场景" class="headerlink" title="★八、Promise.all和Promise.race的区别和使用场景"></a>★八、Promise.all和Promise.race的区别和使用场景</h2><h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h3><p>可以将多个Promise对象包装成一个新的Promise对象，成功时返回的值是一个结果数组，失败的时候返回的是最先被reject失败状态的值。<br>Promise.all中传入的是数组，返回的也是数组，并且会进行映射，传入的Promise对象返回的值是按照顺序在数组中排列的，但是执行的顺序并不是按照顺序执行，除非可迭代对象为空。<br>Promise.all获得的成功结果的数据里面的数据顺序和Promise.all接收到的数组顺序是一致的，当遇到发送多个请求并根据请求顺序获取和使用数据的场景，就可以使用Promise.all来解决。</p><h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h3><p>看哪个结果获得的快就返回哪个结果，不管结果本身是兑现状态还是拒绝状态。<br>当需要做一件事，超过多长时间就不做了，可以使用这个方法来解决：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>([promise1,<span class="hljs-title function_">timeOutPromise</span>(<span class="hljs-number">5000</span>)]).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;&#125;)<br></code></pre></td></tr></table></figure><h2 id="九、async-x2F-await"><a href="#九、async-x2F-await" class="headerlink" title="九、async&#x2F;await"></a>九、async&#x2F;await</h2><h3 id="9-1-async-x2F-await的概念和理解"><a href="#9-1-async-x2F-await的概念和理解" class="headerlink" title="9.1 async&#x2F;await的概念和理解"></a>9.1 async&#x2F;await的概念和理解</h3><p>async&#x2F;await是生成器Generator的语法糖，它能实现的效果都能用then链来实现，是为了优化then链而开发出来的。<br>async&#x2F;await是基于Promise实现的，不能用于普通的回调函数，与Promise一样是异步的、非阻塞的，它使得异步代码看起来像是同步代码。<br>一个函数如果加上async，那么该函数就会返回一个Promise，async就是将函数返回值用Promise.resolve()进行了包裹，和then中处理返回值一样，并且<strong>await只能在async声明的函数内使用</strong>。<br><strong>async作用</strong>：以async声明的函数返回的是一个Promise对象，如果函数有返回值，async会把这个返回值通过Promise.resolve()封装成Promise对象，可以使用then链来继续处理这个Promise对象。如果函数没有返回值，返回Promise.resolve(undefined).<br><strong>await作用</strong>：await命令后跟的是一个Promise对象，它接收一个期约并将其转换为一个返回值或一个抛出的异常，等待Promise对象状态发生改变，得到返回值，也可以是任意表达式返回的结果。<br>await后面不管接的是什么表达式，都能等待到结果的返回，当等到的不是Promise对象时，就将等到的结果返回；否则会阻塞后面的代码，等待Promise对象状态的变化，得到对应的值作为await等待的结果，这里阻塞指的是async内部的阻塞，async函数的调用并不会阻塞。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">testAsy</span>(<span class="hljs-params"></span>)&#123;<br>   <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;hello world&#x27;</span><br>&#125;<br><span class="hljs-keyword">let</span> result = <span class="hljs-title function_">testAsy</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result)<br>result.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">v</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(v)   <span class="hljs-comment">// hello world</span><br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="9-2-async-x2F-await带来和解决了什么问题"><a href="#9-2-async-x2F-await带来和解决了什么问题" class="headerlink" title="9.2 async&#x2F;await带来和解决了什么问题"></a>9.2 async&#x2F;await带来和解决了什么问题</h3><p><strong>解决了</strong>：每个Promise相当于一个异步的网络请求，通常一个业务流程需要多个网络请求，而且网络请求都依赖一个请求结果。相比于Promise的then链调用相比，async&#x2F;await调用个更加清晰简单。<br><strong>带来了</strong>：使用它会导致同步执行带来的时间累加，使得程序变慢，有时会让并发执行的代码变成了继发执行。</p><h3 id="9-3-await在等待什么"><a href="#9-3-await在等待什么" class="headerlink" title="9.3 await在等待什么"></a>9.3 await在等待什么</h3><p>await等待后面表达式的计算，其计算结果为Promise对象或其它值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getSomething</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;something&quot;</span>;<br>&#125;<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">testAsync</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;hello async&quot;</span>);<br>&#125;<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> v1 = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getSomething</span>();<br>    <span class="hljs-keyword">const</span> v2 = <span class="hljs-keyword">await</span> <span class="hljs-title function_">testAsync</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(v1, v2); <br>&#125;<br><span class="hljs-title function_">test</span>();<br></code></pre></td></tr></table></figure><p>await 表达式的运算结果取决于它等的是什么，如果等到的不是一个Promise对象，那await表达式的运算结果就是它等到的东西；如果它等到的是一个Promise对象，await会阻塞后面代码直到Promise对象resolve，然后得到resolve的值作为await表达式的运算结果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">testAsy</span>(<span class="hljs-params">x</span>)&#123;<br>   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span>=&gt;</span>&#123;<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>       <span class="hljs-title function_">resolve</span>(x);<br>     &#125;, <span class="hljs-number">3000</span>)<br>    &#125;<br>   )<br>&#125;<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">testAwt</span>(<span class="hljs-params"></span>)&#123;    <br>  <span class="hljs-keyword">let</span> result =  <span class="hljs-keyword">await</span> <span class="hljs-title function_">testAsy</span>(<span class="hljs-string">&#x27;hello world&#x27;</span>);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);    <span class="hljs-comment">// 3秒钟之后出现hello world</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;cuger&#x27;</span>)   <span class="hljs-comment">// 因为前面导致阻塞，3秒钟之后出现cug</span><br>&#125;<br><span class="hljs-title function_">testAwt</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;cug&#x27;</span>)  <span class="hljs-comment">//立即输出cug</span><br></code></pre></td></tr></table></figure><p><strong>await必须在async函数中使用</strong>：是因为async函数调用不会导致阻塞，其内部所有阻塞都被封装在一个Promise对象中异步执行，await暂停当前async的执行，所以先输出cug，3s后再出现hello world和cuger。</p><h3 id="9-4-async-x2F-await优势"><a href="#9-4-async-x2F-await优势" class="headerlink" title="9.4 async&#x2F;await优势"></a>9.4 async&#x2F;await优势</h3><ul><li>代码读起来更加清晰，Promise虽然解决了回调地狱，但then的链式调用也会带来阅读负担。</li><li>Promise传递中间值非常麻烦，而async&#x2F;await几乎是同步写法。</li><li>错误处理友好，async&#x2F;await使用成熟的try&#x2F;catch，Promise的错误捕获非常冗余。</li><li>调试友好，Promise调试很差，由于没有代码块，不能在返回表达式的箭头函数中设置断点，如果在一个then代码块中使用调试器的步进功能，调试器不会进入后续的then代码块，因为调试器只能跟踪同步代码的每一步。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 用Promise写</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">doIt</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">time</span>(<span class="hljs-string">&quot;doIt&quot;</span>);<br>    <span class="hljs-keyword">const</span> time1 = <span class="hljs-number">300</span>;<br>    <span class="hljs-title function_">step1</span>(time1)<br>        .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">time2</span> =&gt;</span> <span class="hljs-title function_">step2</span>(time2))<br>        .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">time3</span> =&gt;</span> <span class="hljs-title function_">step3</span>(time3))<br>        .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`result is <span class="hljs-subst">$&#123;result&#125;</span>`</span>);<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">timeEnd</span>(<span class="hljs-string">&quot;doIt&quot;</span>);<br>        &#125;);<br>&#125;<br><span class="hljs-title function_">doIt</span>();<br><span class="hljs-comment">// 用async/await</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">doIt</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">time</span>(<span class="hljs-string">&quot;doIt&quot;</span>);<br>    <span class="hljs-keyword">const</span> time1 = <span class="hljs-number">300</span>;<br>    <span class="hljs-keyword">const</span> time2 = <span class="hljs-keyword">await</span> <span class="hljs-title function_">step1</span>(time1);<br>    <span class="hljs-keyword">const</span> time3 = <span class="hljs-keyword">await</span> <span class="hljs-title function_">step2</span>(time2);<br>    <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> <span class="hljs-title function_">step3</span>(time3);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`result is <span class="hljs-subst">$&#123;result&#125;</span>`</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">timeEnd</span>(<span class="hljs-string">&quot;doIt&quot;</span>);<br>&#125;<br><span class="hljs-title function_">doIt</span>();<br></code></pre></td></tr></table></figure></li></ul><h3 id="9-5-async-x2F-await如何捕获异常"><a href="#9-5-async-x2F-await如何捕获异常" class="headerlink" title="9.5 async&#x2F;await如何捕获异常"></a>9.5 async&#x2F;await如何捕获异常</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">try</span>&#123;<br>        <span class="hljs-keyword">let</span> a = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;error&#x27;</span>)<br>    &#125;<span class="hljs-keyword">catch</span>(error)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="★十、js为什么是单线程的"><a href="#★十、js为什么是单线程的" class="headerlink" title="★十、js为什么是单线程的"></a>★十、js为什么是单线程的</h2><p>主要和js用途有关。js作为浏览器脚本语言，主要是实现用户与浏览器的交互，以及操作dom，这决定了它只能是单线程，否则会带来很复杂的同步问题。例如：若js是多线程，如果有一个线程要修改一个dom元素，另一个元素要删除这个dom元素，此时会发生冲突。</p><h2 id="★十一、同步任务和异步任务、消息队列和事件循环"><a href="#★十一、同步任务和异步任务、消息队列和事件循环" class="headerlink" title="★十一、同步任务和异步任务、消息队列和事件循环"></a>★十一、同步任务和异步任务、消息队列和事件循环</h2><p><strong>同步任务</strong>：等待上一个事件执行完毕才执行下文，会阻塞，等待时间长，这种同步执行的操作容易使页面呈卡死状态，异步可以解决阻塞。<br><strong>异步任务</strong>：不等前一个任务结束就执行。不进入主线程、而进入”任务队列”的任务，只有等主线程任务执行完毕，”任务队列”开始通知主线程，请求执行任务，该任务才会进入主线程执行。<br><strong>消息队列（任务队列）</strong>：先进先出队列，里面存放着异步操作的回调函数，异步操作会把相关的回调函数添加到任务队列中，不同的异步操作添加到任务队列的时机不同。如：onclick事件触发时回调函数会立即加入到消息队列、setTimeout会进行延时处理直到到达指定时间时才将回调函数放入消息队列、ajax会在网络请求完成返回后将回调添加到任务队列。<br><strong>事件循环</strong>：js会创建一个类似while（true）的循环，每执行一次循环体的过程称为Tick，每次Tick就是看是否有待处理时间，有就取出相关事件及回调函数放入执行栈由主线程执行，待处理的事件会放到任务队列中。</p><h2 id="十二、手写Ajax请求"><a href="#十二、手写Ajax请求" class="headerlink" title="十二、手写Ajax请求"></a>十二、手写Ajax请求</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">ajax</span>(<span class="hljs-params">url</span>) &#123;<br>    <span class="hljs-comment">// 创建一个 XHR 对象</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>()<br>        <span class="hljs-comment">// 指定请求类型，请求URL，和是否异步</span><br>        xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;GET&#x27;</span>, url, <span class="hljs-literal">true</span>)<br>        xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-title function_">funtion</span>(<span class="hljs-params"></span>) &#123;<br>          <span class="hljs-comment">// 表明数据已就绪</span><br>            <span class="hljs-keyword">if</span>(xhr.<span class="hljs-property">readyState</span> === <span class="hljs-number">4</span>) &#123;<br>                <span class="hljs-keyword">if</span>(xhr.<span class="hljs-property">status</span> === <span class="hljs-number">200</span>)&#123;<br>                    <span class="hljs-comment">// 回调</span><br>                    <span class="hljs-title function_">resolve</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(xhr.<span class="hljs-property">responseText</span>))<br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;error&#x27;</span>)<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 发送定义好的请求</span><br>        xhr.<span class="hljs-title function_">send</span>(<span class="hljs-literal">null</span>)<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript上</title>
    <link href="/2022/07/13/JavaScript%E4%B8%8A/"/>
    <url>/2022/07/13/JavaScript%E4%B8%8A/</url>
    
    <content type="html"><![CDATA[<h1 id="一、数据类型"><a href="#一、数据类型" class="headerlink" title="一、数据类型"></a>一、数据类型</h1><h2 id="一、数据类型和区别"><a href="#一、数据类型和区别" class="headerlink" title="一、数据类型和区别"></a>一、数据类型和区别</h2><p>JS的八大数据类型：Number、String、Boolean、Undefined、Null、Object、Symbol（ES6新增）、Bigint（ES6新增）<br>基本数据类型：Number、String、Boolean、Undefined、Null、Symbol(ES6)<br>引用数据类型：Object、Array、Function<br>集合：set。映射：Map。</p><ul><li>Symbol代表创建后独一无二的数据类型，主要是为了解决可能出现的全局变量冲突的问题。</li><li>BigInt 是一种数字类型的数据，它可以表示任意精度格式的整数，可以安全地存储和操作大整数，即使这个数已经超出了 Number 能够表示的安全整数范围。<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3>1、 <strong>位置</strong>：基本数据类型值（原始值）是存储在栈中的数据段，直接存储在变量访问的位置，存放js基本数据类型的变量存放的是基本类型数据的实际值。<br>引用数据类型值是存储在堆中的对象，存储在变量处的值是一个指针，指向存储对象的内存地址。存放引用数据类型的变量是保存对它的引用，即指针。<br>2、复制变量时：对于存放基本数据类型的变量的交换，等于在一个新的作用域创建一个新的空间，新的空间与原空间不会互相影响。<br>对于存放引用数据类型的变量交换，并不会创建一个新的空间，而是让对象或方法和之前对象或方法同时指向一个原有空间（地址）。<br>3、参数传递不同：函数传参时，变量存储的基本类型的值只是把值传递给参数之后，参数和这个变量互不影响。<br>变量存储的引用数据类型值存储的是该引用值在堆内存中的内存地址，传递的值就是这个内存地址。<br>4、在操作系统中，内存被分为栈区和堆区。栈区内存由编译器自动分配释放，存放函数的参数值、局部变量的值等，操作方式类似数据结构中的栈。堆区内存一般由开发者分配释放，若开发者不释放，程序结束时可能由垃圾回收机制回收。</li></ul><p>确定一个值是哪种基本类型可以使用typeof操作符，确定一个值是哪种引用类型使用instanceof操作符。<br>typeof null输出object</p><h2 id="二、判断数据类型"><a href="#二、判断数据类型" class="headerlink" title="二、判断数据类型"></a>二、判断数据类型</h2><ul><li>最好的方法：Object.prototype.toString.call(a)，返回值为[object 类型]<img src="/2022/07/13/JavaScript%E4%B8%8A/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD.png" class="" title="数据类型判断"> </li><li><strong>typeof</strong>：对于原始类型来说，除了null都可以显示正确的类型。null和对象（函数除外返回function）都显示object。返回一个字符串，表示未经求值的操作数的类型。不能判断出Array、null和object之间区别。</li><li><strong>instanceof</strong>：判断某个构造函数的prototype属性所指向的对象是否存在于另一个要检测的对象的原型链上。a instanceof b就是检测a是不是b的一个实例对象或者是b子类的一个实例对象。例如：console.log([] instanceof Array)为true。<strong>只能判断引用数据类型，不能判断基本数据类型</strong>。</li><li>valueOf：</li></ul><ol><li>booleanObject.valueOf()返回布尔对象的原始值。</li><li>stringObject.valueOf()返回String对象的原始值，原始值是由从String对象下来的所有对象继承的。</li><li>arrayObject.valueOf()返回Array对象的原始值，该值是由Array对象派生的所有对象继承。</li><li>NumberObject.valueOf()可以字符串返回数字，字符串的输出通常等于该数字。</li><li>DateObject.valueOf()方法返回Date对象的原始值。返回值和方法Date.getTime返回的值相等。</li></ol><ul><li><strong>constructor</strong>：有两个作用，一是判断数据的类型，二是对象实例通过constructor对象访问它的构造函数。如果创建一个对象来改变它的原型，constructor就不能判断它的数据类型了。使用方法：(2).constructor&#x3D;&#x3D;&#x3D;Number<figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Fn</span>(<span class="hljs-params"></span>)&#123;&#125;;<br><span class="hljs-title class_">Fn</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>();<br><span class="hljs-keyword">var</span> f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Fn</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(f.<span class="hljs-property">constructor</span>===<span class="hljs-title class_">Fn</span>);    <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(f.<span class="hljs-property">constructor</span>===<span class="hljs-title class_">Array</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h3 id="检测对象obj时obj-toString-的结果和Object-prototype-toString-call-obj-结果为何不同"><a href="#检测对象obj时obj-toString-的结果和Object-prototype-toString-call-obj-结果为何不同" class="headerlink" title="检测对象obj时obj.toString()的结果和Object.prototype.toString.call(obj)结果为何不同"></a>检测对象obj时obj.toString()的结果和Object.prototype.toString.call(obj)结果为何不同</h3>因为toString是Object的原型方法，而Array、function等<strong>类型作为Object的实例，都重写了toString方法</strong>。不同的对象类型调用toString方法时，根据原型链调用的是对应的重写之后的toString方法，而不会去调用Object上原型toString方法（返回对象的具体类型），所以采用obj.toString()不能得到其对象类型，只能将obj转换为字符串类型[object Object]；因此，在想要得到对象的具体类型时，应该调用Object原型上的toString方法。</li></ul><h2 id="三、判断数组的方式"><a href="#三、判断数组的方式" class="headerlink" title="三、判断数组的方式"></a>三、判断数组的方式</h2><ul><li>Object.prototype.toString.call()<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(obj).<span class="hljs-title function_">slice</span>(<span class="hljs-number">8</span>,-<span class="hljs-number">1</span>) === <span class="hljs-string">&#x27;Array&#x27;</span>;<br></code></pre></td></tr></table></figure></li><li>通过ES6的Array.isArray()做判断<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArrray</span>(obj);<br></code></pre></td></tr></table></figure></li><li>通过instanceof判断<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">obj <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Array</span><br></code></pre></td></tr></table></figure></li><li>通过原型链做判断<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">obj.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span><br></code></pre></td></tr></table></figure></li><li>通过Array.prototype.isPrototypeOf<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">isPrototypeOf</span>(obj)<br></code></pre></td></tr></table></figure></li></ul><p><strong>将非数组队列转为数组</strong>：Array.from(obj)</p><h2 id="四、null和undefined区别"><a href="#四、null和undefined区别" class="headerlink" title="四、null和undefined区别"></a>四、null和undefined区别</h2><p>二者都是剧本数据类型。<br><strong>undefined</strong>代表未定义，<strong>null</strong>代表空对象。一般变量声明了但还没有定义时返回undefined，null主要用于赋值给一些可能会返回对象的变量，作为初始化。<br>undefined在JavaScript中不是一个保留字，意味着它可以作为一个变量名，可以使用一些方法获得安全的undefined值，如<strong>void 0</strong>。<br>对这两种类型使用typeof时，null会返回object（第一个版本的JavaScript中null的类型标签和object类型标签一样是000）。使用双等号对两种类型的值进行比较的时候会返回true，用三等号比较返回false。</p><h2 id="五、instanceof实现原理"><a href="#五、instanceof实现原理" class="headerlink" title="五、instanceof实现原理"></a>五、instanceof实现原理</h2><p>instanceof运算符用于判断构造函数的prototye属性是否出现在对象的原型链中的任何位置。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myInstanceof</span>(<span class="hljs-params">left, right</span>) &#123;<br>  <span class="hljs-comment">// 获取对象的原型</span><br>  <span class="hljs-keyword">let</span> proto = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(left)<br>  <span class="hljs-comment">// 获取构造函数的 prototype 对象</span><br>  <span class="hljs-keyword">let</span> prototype = right.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>;<br> <br>  <span class="hljs-comment">// 判断构造函数的 prototype 对象是否在对象的原型链上</span><br>  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!proto) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (proto === prototype) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">// 如果没有找到，就继续从其原型上找，Object.getPrototypeOf方法用来获取指定对象的原型</span><br>    proto = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(proto);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="六、小数求和（0-1-0-2-x3D-x3D-x3D-0-3）"><a href="#六、小数求和（0-1-0-2-x3D-x3D-x3D-0-3）" class="headerlink" title="六、小数求和（0.1+0.2&#x3D;&#x3D;&#x3D;0.3）"></a>六、小数求和（0.1+0.2&#x3D;&#x3D;&#x3D;0.3）</h2><p>JS用Number类型来表示数字（整数或浮点数），通过64位来表示一个数字（1位符号位+11位指数位e+52位小数位f）</p><ul><li>1 符号位，0表示正数，1表示负数</li><li>11 指数位（e），决定数值大小</li><li>52 尾数（f），小数部分（即有效数字），决定数值精度。<br>计算方式：尾数为1.xxx…，这些x指的就是52位尾数。指数位二进制-1023。指数位最大为11111111110。  最大安全数字：Number.MAX_SAFE_INTEGER &#x3D; Math.pow(2,53)-1，为一个16位整数。<br>最大数字：Number.MAX_VALUE &#x3D; 2^Math.pow(2,2046-1023)*（1.11111….（52个1））<br>两数相加，0.1和0.2均先转换为二进制数，尾数会发生无限循环，进行截断时会发生精度丢失。<br><strong>精度丢失可能会出现在进制换和对阶运算中</strong><br>解决办法：设置一个误差范围，如<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">（<span class="hljs-number">0.1</span>+<span class="hljs-number">0.2</span>）.<span class="hljs-title function_">toFixed</span>(<span class="hljs-number">2</span>) <span class="hljs-comment">//利用toFixed进行四舍五入，保留小数后面两位</span><br></code></pre></td></tr></table></figure>在ES6中，提供Number.EPSILON属性，只要判断0.1+0.2-0.3是否小于Number.EPSILON，小于就视为正常。</li></ul><h2 id="七、typeof-NaN的结果是什么"><a href="#七、typeof-NaN的结果是什么" class="headerlink" title="七、typeof NaN的结果是什么"></a>七、typeof NaN的结果是什么</h2><p>NaN是指结果不是一个数字，用于指出数字类型中的错误情况，即执行数学运算没有成功，这是失败后返回的结果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">typeof</span> <span class="hljs-title class_">NaN</span>; <span class="hljs-comment">// &quot;number&quot;</span><br></code></pre></td></tr></table></figure><p>NaN是一个特殊值，和自身不相等，是唯一一个非自反的值，NaN!&#x3D;&#x3D;NaN为true。</p><h2 id="八、isNaN和Number-isNaN区别"><a href="#八、isNaN和Number-isNaN区别" class="headerlink" title="八、isNaN和Number.isNaN区别"></a>八、isNaN和Number.isNaN区别</h2><ul><li>isNaN接收参数后，会尝试将这个参数转换为数值，任何不能转换为数值的值都会返回true，非数字值传入也会返回true，会影响NaN的判断。</li><li>Number.isNaN会首先判断传入的参数是否为数字，如果是数字再继续判断是否为NaN，不会进行数据类型的转换，对NaN的判断更加准确。<h2 id="九、-x3D-x3D-强制类型转换"><a href="#九、-x3D-x3D-强制类型转换" class="headerlink" title="九、&#x3D;&#x3D;强制类型转换"></a>九、&#x3D;&#x3D;强制类型转换</h2>对于&#x3D;&#x3D;，如果对比双方类型不一样，会进行类型转换。如果比较x和y是否相同，进行如下流程：</li></ul><ol><li>首先会判断两者类型是否<strong>相同</strong>，相同的话就比较两者的大小；</li><li>类型不相同的话，就会进行类型转换；</li><li>会先判断是否在对比 null和undefined，是的话就会返回 true</li><li>判断两者类型是否为string和number，是的话就会将字符串转换为number</li><li>判断其中一方是否为boolean，是的话就把boolean转换为number（0或1）再进行判断。</li><li>判断其中一方是否为object且另一方为string、number或symbol，是就会把object转换为原始类型再进行判断。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-string">&#x27;1&#x27;</span> == &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;js&#x27;</span> &#125;    <span class="hljs-comment">//    &#x27;1&#x27; == &#x27;[object Object]&#x27;</span><br></code></pre></td></tr></table></figure></li></ol> <img src="/2022/07/13/JavaScript%E4%B8%8A/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.png" class=""> <h2 id="十、类型转换"><a href="#十、类型转换" class="headerlink" title="十、类型转换"></a>十、类型转换</h2><ul><li>显示转化：</li></ul><ol><li>转化为字符串类型（String）：String(a)除了极大极小的数字会转换为指数形式，symbol类型显示强制类型转换。</li><li>转换为数值类型：Number(a)。空字符串、空格字符串和null会转换为0，undefined转换为NaN，当其他类型无法转换为具体数值时，打印成NaN。Symbol报错，对象回先转换为对应基本类型值，若返回非数字的基本类型值，则再根据规则强制转换为数字。<br>为了将值转换为相应的基本类型值，抽象操作 ToPrimitive 会首先（通过内部操作 DefaultValue）检查该值是否有valueOf()方法。如果有并且返回基本类型值，就使用该值进行强制类型转换。如果没有就使用 toString() 的返回值（如果存在）来进行强制类型转换。如果 valueOf() 和 toString() 均不返回基本类型值，会产生 TypeError 错误。</li><li>转化为布尔类型：Boolean(a)。数值类型中的0和NaN转化为false，其余转化为true。字符串类型中除了空字符串其它都是true。undefined和null转换为false。</li><li>parseInt和parseFloat将字符串类型转换为数值类型，取字符串以整数开头的字符串中的数值。parseInt取整，parseFloat取小数。如果第一个非空格字符不是有效的数值字面量，则返回NaN。</li></ol><ul><li>隐式转换：除Date对象用toString转换为字符串，其余都如下<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> <span class="hljs-title function_">objToNumber</span> = value =&gt; <span class="hljs-title class_">Number</span>(value.<span class="hljs-title function_">valueOf</span>().<span class="hljs-title function_">toString</span>())<br><span class="hljs-title function_">objToNumber</span>([]) === <span class="hljs-number">0</span><br><span class="hljs-title function_">objToNumber</span>(&#123;&#125;) === <span class="hljs-title class_">NaN</span><br></code></pre></td></tr></table></figure></li></ul><ol><li>二元+：如果一个操作数是对象，把该操作数转换为原始值（toString和valueOf）。如果有操作数是字符串，另一个操作数也会转换为字符串并进行拼接。否则，两个操作数都转换为数值。</li><li>一元+、-、++：将操作数转转换为数值。</li><li>！：将操作数转换为布尔值再取反。</li><li>通常会按照需要转换操作数的类型进行转换。如”3”*”5”结果为15。</li><li>对于&lt;和&gt;，如果两边都是字符串，则比较字母表顺序，否则转换为数字再比较。<h2 id="十一、-和-amp-amp-操作符的返回值"><a href="#十一、-和-amp-amp-操作符的返回值" class="headerlink" title="十一、||和&amp;&amp;操作符的返回值"></a>十一、||和&amp;&amp;操作符的返回值</h2>||和&amp;&amp;首先会对第一个操作数执行条件进行判断，若其不是布尔值就先强制转换为布尔类型，再进行条件判断。<br>对于||，若第一个值判断结果为true就返回第一个操作数的值，不处理第二个值；如果第一个值为false才返回第二个操作数的值。<br>&amp;&amp;相反，如果第一个操作数的值为true返回第二个操作数的值，否则只返回第一个操作数的值不看第二个操作数。<h2 id="十二、-x3D-x3D-、-x3D-x3D-x3D-和Object-is"><a href="#十二、-x3D-x3D-、-x3D-x3D-x3D-和Object-is" class="headerlink" title="十二、&#x3D;&#x3D;、&#x3D;&#x3D;&#x3D;和Object.is()"></a>十二、&#x3D;&#x3D;、&#x3D;&#x3D;&#x3D;和Object.is()</h2></li></ol><ul><li>&#x3D;&#x3D;&#x3D;：判断两者类型和值是否完全相等，不进行类型转换。如果一个值是NaN，则不相等。</li><li>&#x3D;&#x3D;：如果两个操作数的值类型不同，会先进行类型转换，再进行比较。</li></ul><ol><li>如果两个值类型相同，比较大小。</li><li>如果类型不同，会进行类型转换。</li><li>如果一个值是null，另一个值是undefined，则相等。</li><li>如果一个值是数值，另一个是字符串，就会将字符串转换为数值，再进行比较。</li><li>如果有一个值为布尔值，true转1false转0，再进行比较。</li><li>如果一个值为对象object，另一个值是数值或者字符串，就把对象转换为原始类型再比较。</li></ol><ul><li>Object.is()一般情况下判断和&#x3D;&#x3D;&#x3D;相同，+0和-0不相等，两个NaN相等。<h2 id="十三、包装类型"><a href="#十三、包装类型" class="headerlink" title="十三、包装类型"></a>十三、包装类型</h2>在 JavaScript 中，基本类型是没有属性和方法的，但是为了便于操作基本类型的值，在调用基本类型的属性或方法时JavaScript会在后台隐式地将基本类型的值转换为对象，如：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> a = <span class="hljs-string">&quot;abc&quot;</span>;<br>a.<span class="hljs-property">length</span>; <span class="hljs-comment">// 3</span><br>a.<span class="hljs-title function_">toUpperCase</span>(); <span class="hljs-comment">// &quot;ABC&quot;</span><br></code></pre></td></tr></table></figure>在访问’abc’.length时，JavaScript 将’abc’在后台转换成String(‘abc’)，然后再访问其length属性。<br>JavaScript也可以使用Object函数显式地将基本类型转换为包装类型：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-string">&#x27;abc&#x27;</span><br><span class="hljs-title class_">Object</span>(a) <span class="hljs-comment">// String &#123;&quot;abc&quot;&#125;</span><br>复制代码<br></code></pre></td></tr></table></figure><p>也可以使用valueOf方法将包装类型倒转成基本类型：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-string">&#x27;abc&#x27;</span><br><span class="hljs-keyword">var</span> b = <span class="hljs-title class_">Object</span>(a)<br><span class="hljs-keyword">var</span> c = b.<span class="hljs-title function_">valueOf</span>() <span class="hljs-comment">// &#x27;abc&#x27;</span><br></code></pre></td></tr></table></figure><p>看看如下代码会打印出什么：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Boolean</span>(<span class="hljs-literal">false</span>);<br><span class="hljs-keyword">if</span> (!a) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-string">&quot;Oops&quot;</span> ); <span class="hljs-comment">// never runs</span><br>&#125;<br></code></pre></td></tr></table></figure><p>答案是什么都不会打印，因为虽然包裹的基本类型是false，但是false被包裹成包装类型后就成了对象，所以其非值为false，所以循环体中的内容不会运行。</p><h1 id="二、ES6"><a href="#二、ES6" class="headerlink" title="二、ES6"></a>二、ES6</h1><h2 id="★一、let、const、var"><a href="#★一、let、const、var" class="headerlink" title="★一、let、const、var"></a>★一、let、const、var</h2><p><strong>（1）块级作用域：</strong> 块作用域由{}包括，let和const具有块级作用域，var不存在块级作用域，仅限于包含函数的函数体，若在函数体外会声明全局变量。块级作用域解决了ES5中的两个问题：</p><ul><li>内层变量可能覆盖外层变量</li><li>用来计数的循环变量泄露为全局变量</li></ul><p><strong>（2）变量提升：</strong> var存在变量提升，可以使用window.name调用该变量，let和const不存在变量提升，即变量只能在声明之后使用，否在会报错。<br><strong>（3）给全局添加属性：</strong> 浏览器的全局对象是window，Node的全局对象是global。var声明的变量为全局变量，并且会将该变量添加为全局对象的属性，但是let和const不会。<br><strong>（4）重复声明：</strong> var声明变量时，可以重复声明变量，后声明的同名变量会覆盖之前声明的遍历。const和let不允许重复声明变量。let在不同作用域或不同块级作用域可以重复声明赋值。<br><strong>（5）暂时性死区：</strong> 在使用let、const命令声明变量之前，该变量都是不可用的。这在语法上，称为<strong>暂时性死区</strong>。使用var声明的变量不存在暂时性死区。<br><strong>（6）初始值设置：</strong> 在变量声明时，var 和 let 可以不用设置初始值，为undefined。而const声明变量必须设置初始值。<br><strong>（7）指针指向：</strong> let和const都是ES6新增的用于创建变量的语法。 let创建的变量是可以更改指针指向（可以重新赋值）。但const声明的变量是不允许改变指针的指向。</p><table><thead><tr><th><strong>区别</strong></th><th><strong>var</strong></th><th><strong>let</strong></th><th><strong>const</strong></th></tr></thead><tbody><tr><td>是否有块级作用域</td><td>×</td><td>✔️</td><td>✔️</td></tr><tr><td>是否存在变量提升</td><td>✔️</td><td>×</td><td>×</td></tr><tr><td>是否添加全局属性</td><td>✔️</td><td>×</td><td>×</td></tr><tr><td>能否重复声明变量</td><td>✔️</td><td>×</td><td>×</td></tr><tr><td>是否存在暂时性死区</td><td>×</td><td>✔️</td><td>✔️</td></tr><tr><td>是否必须设置初始值</td><td>×</td><td>×</td><td>✔️</td></tr><tr><td>能否改变指针指向</td><td>✔️</td><td>✔️</td><td>×</td></tr></tbody></table><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> x=<span class="hljs-number">10</span>;<br>&#123;<br>    <span class="hljs-keyword">var</span> x=<span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-comment">// x=2(为x重新赋值）</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> x=<span class="hljs-number">10</span>;<br>&#123;<br>    <span class="hljs-keyword">let</span> x=<span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-comment">// x=10,let只在&#123;&#125;内有效。&#125;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> x=<span class="hljs-number">2</span>; <span class="hljs-comment">//合法</span><br><span class="hljs-keyword">let</span> x=<span class="hljs-number">3</span>; <span class="hljs-comment">//不合法</span><br>&#123;<br>    <span class="hljs-keyword">var</span> x=<span class="hljs-number">4</span>; <span class="hljs-comment">//合法</span><br>    <span class="hljs-keyword">let</span> x=<span class="hljs-number">3</span>; <span class="hljs-comment">//不合法</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>未声明的变量会被添加一个全局作用域，声明变量作用域是当前上下文。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">x</span>(<span class="hljs-params"></span>) &#123;<br>  y = <span class="hljs-number">1</span>;   <span class="hljs-comment">// 在严格模式下会抛出ReferenceError</span><br>  <span class="hljs-keyword">var</span> z = <span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-title function_">x</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(y); <span class="hljs-comment">// &#x27;1&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(z); <span class="hljs-comment">// ReferenceError: z is not defined</span><br></code></pre></td></tr></table></figure></li><li>声明变量在任何代码执行前创建，未声明的变量只有在执行赋值操作的时候才会被创建。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);  <span class="hljs-comment">// 抛出ReferenceError。</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;still going...&#x27;</span>); <span class="hljs-comment">// 不会执行</span><br><span class="hljs-keyword">var</span> a;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);  <span class="hljs-comment">// &quot;undefined&quot;或&quot;&quot;（不同执行引擎的实现不同）</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;still going...&#x27;</span>); <span class="hljs-comment">// &#x27;still going...&#x27;</span><br></code></pre></td></tr></table></figure></li><li>声明变量是不可配置属性，而未声明变量是可配置的。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br>b = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">delete</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>; <span class="hljs-comment">// 在严格模式下抛出TypeError，非严格模式下执行失败且无任何提示</span><br><span class="hljs-keyword">delete</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">b</span>;<br></code></pre></td></tr></table></figure></li><li>函数内部声明的变量只能在函数内部使用，函数外部声明的变量可以全局使用。变量在函数内重新声明后在外部依旧保持原状态。<h2 id="二、const对象的属性可以修改吗"><a href="#二、const对象的属性可以修改吗" class="headerlink" title="二、const对象的属性可以修改吗"></a>二、const对象的属性可以修改吗</h2>const保证的并不是变量的值不能改动，而是变量指向的那个内存地址不能改动。对于基本类型的数据（数值、字符串、布尔值），其值就保存在变量指向的那个内存地址，因此等同于常量。<br>但对于引用类型的数据（主要是对象和数组）来说，变量指向数据的内存地址，保存的只是一个指针，const只能保证这个指针是固定不变的，至于它指向的数据结构是不是可变的，就完全不能控制了。<h2 id="三、…扩展运算符的作用及使用场景"><a href="#三、…扩展运算符的作用及使用场景" class="headerlink" title="三、…扩展运算符的作用及使用场景"></a>三、…扩展运算符的作用及使用场景</h2><h3 id="3-1-对象扩展运算符"><a href="#3-1-对象扩展运算符" class="headerlink" title="3.1 对象扩展运算符"></a>3.1 对象扩展运算符</h3>对象的扩展运算符(…)用于取出参数对象中的所有可遍历属性，拷贝到当前对象之中。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> bar = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span> &#125;;<br><span class="hljs-keyword">let</span> baz = &#123; ...bar &#125;; <span class="hljs-comment">// &#123; a: 1, b: 2 &#125;</span><br></code></pre></td></tr></table></figure>上述方法实际上等价于:<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> bar = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span> &#125;;<br><span class="hljs-keyword">let</span> baz = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(&#123;&#125;, bar); <span class="hljs-comment">// &#123; a: 1, b: 2 &#125;</span><br></code></pre></td></tr></table></figure>Object.assign方法用于对象的合并，将源对象source的所有可枚举属性，复制到目标对象target。Object.assign方法的第一个参数是目标对象，后面的参数都是源对象。(<strong>如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性</strong>)。<br>同样，如果用户自定义的属性，放在扩展运算符后面，则扩展运算符内部的同名属性会被覆盖掉。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> bar = &#123;<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>&#125;;<br><span class="hljs-keyword">let</span> baz = &#123;...bar, ...&#123;<span class="hljs-attr">a</span>:<span class="hljs-number">2</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">4</span>&#125;&#125;;  <span class="hljs-comment">// &#123;a: 2, b: 4&#125;</span><br></code></pre></td></tr></table></figure>利用上述特性就可以很方便的修改对象的部分属性。在redux中的reducer函数规定必须是<strong>一个纯函数</strong>，reducer中的state对象要求不能直接修改，可以通过扩展运算符把修改路径的对象都复制一遍，然后产生一个新的对象返回。<br>需要注意：<strong>扩展运算符对对象实例的拷贝属于浅拷贝</strong>。<h3 id="3-2-数组扩展运算符"><a href="#3-2-数组扩展运算符" class="headerlink" title="3.2 数组扩展运算符"></a>3.2 数组扩展运算符</h3>数组的扩展运算符可以将一个数组转为用逗号分隔的参数序列，且每次只能展开一层数组。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(...[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])<br><span class="hljs-comment">// 1 2 3</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(...[<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>], <span class="hljs-number">5</span>])<br><span class="hljs-comment">// 1 [2, 3, 4] 5</span><br></code></pre></td></tr></table></figure>下面是数组的扩展运算符的应用：</li><li><strong>将数组转换为参数序列</strong><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x, y</span>) &#123;<br>  <span class="hljs-keyword">return</span> x + y;<br>&#125;<br><span class="hljs-keyword">const</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>];<br><span class="hljs-title function_">add</span>(...numbers) <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure></li><li><strong>复制数组</strong><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>];<br><span class="hljs-keyword">const</span> arr2 = [...arr1];<br></code></pre></td></tr></table></figure>要记住：<strong>扩展运算符(…)用于取出参数对象中的所有可遍历属性，拷贝到当前对象之中</strong>，这里参数对象是个数组，数组里面的所有对象都是基础数据类型，将所有基础数据类型重新拷贝到新的数组中。</li><li><strong>合并数组</strong><br>如果想在数组内合并数组，可以这样：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr1 = [<span class="hljs-string">&#x27;two&#x27;</span>, <span class="hljs-string">&#x27;three&#x27;</span>];<br><span class="hljs-keyword">const</span> arr2 = [<span class="hljs-string">&#x27;one&#x27;</span>, ...arr1, <span class="hljs-string">&#x27;four&#x27;</span>, <span class="hljs-string">&#x27;five&#x27;</span>];<br><span class="hljs-comment">// [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;]</span><br></code></pre></td></tr></table></figure></li><li><strong>扩展运算符与解构赋值结合起来，用于生成数组</strong><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> [first, ...rest] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br>first <span class="hljs-comment">// 1</span><br>rest  <span class="hljs-comment">// [2, 3, 4, 5]</span><br></code></pre></td></tr></table></figure>需要注意：<strong>如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。</strong><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> [...rest, last] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];         <span class="hljs-comment">// 报错</span><br><span class="hljs-keyword">const</span> [first, ...rest, last] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];  <span class="hljs-comment">// 报错</span><br></code></pre></td></tr></table></figure></li><li><strong>将字符串转为真正的数组</strong><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">[...<span class="hljs-string">&#x27;hello&#x27;</span>]    <span class="hljs-comment">// [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ]</span><br></code></pre></td></tr></table></figure></li><li><strong>任何 Iterator 接口的对象，都可以用扩展运算符转为真正的数组</strong><br>比较常见的应用是可以将某些数据结构转为数组：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// arguments对象</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> args = [...<span class="hljs-variable language_">arguments</span>];<br>&#125;<br></code></pre></td></tr></table></figure>用于替换es5中的Array.prototype.slice.call(arguments)写法。</li><li><strong>使用</strong>Math<strong>函数获取数组中特定的值</strong><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> numbers = [<span class="hljs-number">9</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">1</span>];<br><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(...numbers); <span class="hljs-comment">// 1</span><br><span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(...numbers); <span class="hljs-comment">// 9</span><br></code></pre></td></tr></table></figure><h2 id="四、对象与数组的解构"><a href="#四、对象与数组的解构" class="headerlink" title="四、对象与数组的解构"></a>四、对象与数组的解构</h2>解构是ES6提供的一种新的提取数据的模式，能够从对象或数组中有针对性地拿到想要的数值。<h3 id="4-1-数组的解构"><a href="#4-1-数组的解构" class="headerlink" title="4.1 数组的解构"></a>4.1 数组的解构</h3>在解构数组时，以元素的位置为匹配条件来提取想要的数据。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> [a, b, c] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><span class="hljs-comment">// a=1, b=2, c=3</span><br></code></pre></td></tr></table></figure>数组里的0、1、2索引位的元素值，精准地被映射到了左侧的第0、1、2个变量里去，这就是数组解构的工作模式。还可以通过给左侧变量数组设置空占位的方式，实现对数组中某几个元素的精准提取：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> [a,,c] = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br><span class="hljs-comment">// a=1 c=3</span><br></code></pre></td></tr></table></figure>通过把中间位留空，可以顺利地把数组第一位和最后一位的值赋给 a、c 两个变量。<h3 id="4-2-对象的解构"><a href="#4-2-对象的解构" class="headerlink" title="4.2 对象的解构"></a>4.2 对象的解构</h3>对象结构是以属性的名称为匹配条件，来提取想要的数据。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> stu = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Bob&#x27;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">24</span><br>&#125;<br><span class="hljs-keyword">const</span> &#123; name, age &#125; = stu<br><span class="hljs-comment">// name=&#x27;Bob&#x27;, age=24</span><br></code></pre></td></tr></table></figure>这样就得到了name和age两个和stu平级的变量。<br>注意，对象解构严格以属性名作为定位依据，所以就算调换了 name 和 age 的位置，结果也是一样的：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> &#123; age, name &#125; = stu<br></code></pre></td></tr></table></figure></li></ul><h2 id="★五、为什么let和const不能重复声明"><a href="#★五、为什么let和const不能重复声明" class="headerlink" title="★五、为什么let和const不能重复声明"></a>★五、为什么let和const不能重复声明</h2><p>这是一个比较底层的问题，在ES6中有一个<strong>全局环境变量记录</strong>，它包括<strong>对象式</strong>环境记录和<strong>声明式</strong>环境记录。对象式环境记录主要是包括函数声明和var变量的声明，声明式环境记录包括let和const声明的变量。<br>在使用var声明的时候，v8引擎会检查声明式环境记录中是否有该变量，如果有就报错，否则将其加入到对象式环境记录。<br>使用let和const声明时，引擎会检查对象式环境记录和声明式环境记录，如果有就会报错，否则会加入到声明式环境记录。</p><h1 id="三、JavaScript基础"><a href="#三、JavaScript基础" class="headerlink" title="三、JavaScript基础"></a>三、JavaScript基础</h1><h2 id="一、for…in和for…of"><a href="#一、for…in和for…of" class="headerlink" title="一、for…in和for…of"></a>一、for…in和for…of</h2><h3 id="1-1-for…in"><a href="#1-1-for…in" class="headerlink" title="1.1 for…in"></a>1.1 for…in</h3><p>for&#x2F;in循环in后面可以是任意对象，循环获取的是对象的键名，会遍历对象的整个原型链，性能非常差不建议使用。遍历数组时会返回数组中所有可枚举的属性，包括原型链上可枚举的属性。主要是为了遍历对象而生，不适用于遍历数组。</p><h3 id="1-2-for…of"><a href="#1-2-for…of" class="headerlink" title="1.2 for…of"></a>1.2 for…of</h3><p>for…of是ES6新增的循环语句，专门用于可迭代对象，如数组、字符串、集合和映射。<br>遍历获取的是对象的键值，只遍历当前对象不会遍历原型链。for&#x2F;of只返回数组的下标对应的属性值，可以用来遍历数组、类数组对象、字符串、set、map和Generator对象。<br><strong>对象默认是不可迭代的</strong>，直接使用for&#x2F;of会报错TypeError。</p><ul><li>如果需要遍历的对象是类数组对象，用Array.from转成数组。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> obj = &#123;<br>    <span class="hljs-number">0</span>:<span class="hljs-string">&#x27;one&#x27;</span>,<br>    <span class="hljs-number">1</span>:<span class="hljs-string">&#x27;two&#x27;</span>,<br>    <span class="hljs-attr">length</span>: <span class="hljs-number">2</span><br>&#125;;<br>obj = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(obj);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> k <span class="hljs-keyword">of</span> obj)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(k)<br>&#125;<br><span class="hljs-comment">// &quot;one&quot; &quot;two&quot;</span><br></code></pre></td></tr></table></figure></li><li>如果不是类数组对象，就给对象添加一个Symbol.iterator属性，并指向一个迭代器。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> obj = &#123;<br>    <span class="hljs-attr">a</span>:<span class="hljs-number">1</span>,<br>    <span class="hljs-attr">b</span>:<span class="hljs-number">2</span>,<br>    <span class="hljs-attr">c</span>:<span class="hljs-number">3</span><br>&#125;;<br>obj[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>] = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-keyword">var</span> keys = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(<span class="hljs-variable language_">this</span>);<br>  <span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-title function_">next</span>(<span class="hljs-params"></span>)&#123;<br>      <span class="hljs-keyword">if</span>(count&lt;keys.<span class="hljs-property">length</span>)&#123;<br>        <span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">value</span>: obj[keys[count++]],<span class="hljs-attr">done</span>:<span class="hljs-literal">false</span>&#125;;<br>      &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">value</span>:<span class="hljs-literal">undefined</span>,<span class="hljs-attr">done</span>:<span class="hljs-literal">true</span>&#125;;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> k <span class="hljs-keyword">of</span> obj)&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(k);<br>&#125;<br><span class="hljs-comment">// 或</span><br><span class="hljs-keyword">var</span> obj = &#123;<br>    <span class="hljs-attr">a</span>:<span class="hljs-number">1</span>,<br>    <span class="hljs-attr">b</span>:<span class="hljs-number">2</span>,<br>    <span class="hljs-attr">c</span>:<span class="hljs-number">3</span><br>&#125;;<br>obj[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>] = <span class="hljs-keyword">function</span>*()&#123;<br>    <span class="hljs-keyword">var</span> keys = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(obj);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> k <span class="hljs-keyword">of</span> keys)&#123;<br>        <span class="hljs-keyword">yield</span> [k,obj[k]]<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> [k,v] <span class="hljs-keyword">of</span> obj)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(k,v);<br>&#125;<br></code></pre></td></tr></table></figure></li><li>想要迭代对象的属性&#x2F;值&#x2F;键值对<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> o = &#123; <span class="hljs-attr">x</span>:<span class="hljs-number">1</span>, <span class="hljs-attr">y</span>:<span class="hljs-number">2</span>, <span class="hljs-attr">z</span>:<span class="hljs-number">3</span> &#125;<br><span class="hljs-comment">// 属性</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> k <span class="hljs-keyword">of</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(o))<br><span class="hljs-comment">// 值</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> v <span class="hljs-keyword">of</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">values</span>(o))<br><span class="hljs-comment">// 键值对</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> [k,v] <span class="hljs-keyword">of</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(o))<br></code></pre></td></tr></table></figure></li><li>Symbol.iterator在es6中有三类结构本来具有iterator接口：数组、类数组对象、Map和Set结构。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>];<br><span class="hljs-keyword">let</span> iterator = arr[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]();<br> <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>());  <span class="hljs-comment">//&#123; value: 1, done: false &#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>());  <span class="hljs-comment">//&#123; value: 2, done: false &#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>());  <span class="hljs-comment">//&#123; value: 3, done: false &#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>());  <span class="hljs-comment">//&#123; value: 4, done: false &#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iterator.<span class="hljs-title function_">next</span>());  <span class="hljs-comment">//&#123; value: undefined, done: true &#125;</span><br></code></pre></td></tr></table></figure></li><li>迭代几何Set和映射Map<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> wordSet = &#123;<span class="hljs-string">&quot;na&quot;</span>, <span class="hljs-string">&quot;Na&quot;</span>, <span class="hljs-string">&quot;Bat&quot;</span>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> word <span class="hljs-keyword">of</span> wordSet)<br><span class="hljs-keyword">let</span> m = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([[<span class="hljs-number">1</span>,<span class="hljs-string">&quot;one&quot;</span>]])<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> [key, value] <span class="hljs-keyword">of</span> m)<br></code></pre></td></tr></table></figure><h2 id="二、数组原生方法-是否改变原数组"><a href="#二、数组原生方法-是否改变原数组" class="headerlink" title="二、数组原生方法+是否改变原数组"></a>二、数组原生方法+是否改变原数组</h2></li><li>数组和字符串的转换方法：toString()、toLocalString()、join()，其中 join() 方法可以指定转换为字符串时的分隔符。</li><li>数组尾部操作的方法 pop() 和 push()，push 方法可以传入多个参数。</li><li>数组首部操作的方法 shift() 和 unshift() 重排序的方法 reverse() 和 sort()，sort() 方法可以传入一个函数来进行比较，传入前后两个值，如果返回值为正数，则交换两个参数的位置。</li><li>数组连接的方法concat() ，返回的是拼接好的数组，不影响原数组。</li><li>数组截取办法slice()，用于截取数组中的一部分返回，不影响原数组。</li><li>数组插入方 splice()，影响原数组。</li><li>查找特定项的索引的方法，indexOf() 和 lastIndexOf() </li><li>迭代方法 every()、some()、filter()、map() 和 forEach() 方法</li><li>数组归并方法 reduce() 和 reduceRight() 方法，使用指定的函数归并数组元素，最终产生一个值。<br><strong>会改变原始数组的方法</strong>：push、pop、shift、unshift、splice、sort、reverse、forEach。<br><strong>不会改变原始数组的方法</strong>：filter、concat、slice、map。</li></ul><h2 id="三、类数组对象"><a href="#三、类数组对象" class="headerlink" title="三、类数组对象"></a>三、类数组对象</h2><p>一个拥有 length 属性和若干索引属性的对象就可以被称为类数组对象，类数组对象和数组类似，但是不能调用数组的方法。常见的类数组对象有arguments和DOM方法的返回结果，函数也可以被看作是类数组对象，因为它含有 length 属性值，代表可接收的参数个数。<br>常见的类数组转换为数组的方法有这样几种：</p><ul><li>通过 call 调用数组的 slice 方法来实现转换<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">slice</span>.<span class="hljs-title function_">call</span>(arrayLike);<br></code></pre></td></tr></table></figure></li><li>通过 call 调用数组的 splice 方法来实现转换<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">splice</span>.<span class="hljs-title function_">call</span>(arrayLike, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure></li><li>通过 apply 调用数组的 concat 方法来实现转换<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">concat</span>.<span class="hljs-title function_">apply</span>([], arrayLike);<br></code></pre></td></tr></table></figure></li><li>通过 Array.from 方法来实现转换<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(arrayLike);<br></code></pre></td></tr></table></figure><h2 id="四、map和Object区别"><a href="#四、map和Object区别" class="headerlink" title="四、map和Object区别"></a>四、map和Object区别</h2><table><thead><tr><th></th><th>Map</th><th>Object</th></tr></thead><tbody><tr><td>意外的键</td><td>Map默认情况不包含任何键，只包含显式插入的键。</td><td>Object 有一个原型, 原型链上的键名有可能和自己在对象上的设置的键名产生冲突。</td></tr><tr><td>键的类型</td><td>Map的键可以是任意值，包括函数、对象或任意基本类型。</td><td>Object 的键必须是 String 或是Symbol。</td></tr><tr><td>键的顺序</td><td>Map 中的 key 是有序的。因此，当迭代的时候， Map 对象以插入的顺序返回键值。</td><td>Object 的键是无序的</td></tr><tr><td>Size</td><td>Map 的键值对个数可以轻易地通过size 属性获取</td><td>Object 的键值对个数只能手动计算</td></tr><tr><td>迭代</td><td>Map 是 iterable 的，所以可以直接被迭代。</td><td>迭代Object需要以某种方式获取它的键然后才能迭代。</td></tr><tr><td>性能</td><td>在频繁增删键值对的场景下表现更好。</td><td>在频繁添加和删除键值对的场景下未作出优化。</td></tr></tbody></table><h2 id="★五、数组遍历的方法"><a href="#★五、数组遍历的方法" class="headerlink" title="★五、数组遍历的方法"></a>★五、数组遍历的方法</h2><table><thead><tr><th><strong>方法</strong></th><th><strong>是否改变原数组</strong></th><th><strong>特点</strong></th></tr></thead><tbody><tr><td>forEach()</td><td>是</td><td>数组方法，对数据操作会改变原数组，没有返回值，可以用try-catch跳出循环</td></tr><tr><td>map()</td><td>否</td><td>数组方法，不改变原数组，返回一个新数组，为原数组调用函数处理后的值，可链式调用</td></tr><tr><td>filter()</td><td>否</td><td>数组方法，过滤数组，返回包含符合条件的元素的数组，可链式调用</td></tr><tr><td>for…of</td><td>否</td><td>for…of遍历具有Iterator迭代器的对象的属性，返回的是数组的元素、对象的属性值，不能遍历普通的obj对象，将异步循环变成同步循环</td></tr><tr><td>every() 和 some()</td><td>否</td><td>数组方法，some()只要有一个是true，便返回true；而every()只要有一个是false，便返回false.</td></tr><tr><td>find() 和 findIndex()</td><td>否</td><td>数组方法，find()返回的是第一个符合条件的值；findIndex()返回的是第一个返回条件的值的索引值</td></tr><tr><td>reduce() 和 reduceRight()</td><td>否</td><td>数组方法，reduce()对数组正序操作；reduceRight()对数组逆序操作</td></tr></tbody></table></li></ul><h2 id="★六、JS的垃圾回收"><a href="#★六、JS的垃圾回收" class="headerlink" title="★六、JS的垃圾回收"></a>★六、JS的垃圾回收</h2><h3 id="6-1-概念"><a href="#6-1-概念" class="headerlink" title="6.1 概念"></a>6.1 概念</h3><p><strong>垃圾回收</strong>：JavaScript代码运行时，需要分配内存空间来储存变量和值。当变量不在参与运行时，就需要系统收回被占用的内存空间，这就是垃圾回收。<strong>目的是为了防止内存泄露</strong>。<br><strong>回收机制</strong>：</p><ul><li>Javascript 具有自动垃圾回收机制，会定期对那些不再使用的变量、对象所占用的内存进行释放，原理就是找到不再使用的变量，然后释放掉其占用的内存。</li><li>JavaScript中存在两种变量：局部变量和全局变量。全局变量的生命周期会持续要页面卸载；而局部变量声明在函数中，它的生命周期从函数执行开始，直到函数执行结束，在这个过程中，局部变量会在堆或栈中存储它们的值，当函数执行结束后，这些局部变量不再被使用，它们所占有的空间就会被释放。</li><li>不过，当局部变量被外部函数使用时，其中一种情况就是闭包，在函数执行结束后，函数外部的变量依然指向函数内部的局部变量，此时局部变量依然在被使用，所以不会回收。</li></ul><h3 id="★6-2-垃圾回收方式"><a href="#★6-2-垃圾回收方式" class="headerlink" title="★6.2 垃圾回收方式"></a>★6.2 垃圾回收方式</h3><p><strong>标记清除</strong>：标记清除是浏览器常见的垃圾回收方式。</p><ol><li>当变量进入执行环境时，就标记这个变量“进入环境”，被标记为“进入环境”的变量是不能被回收的，因为他们正在被使用。当变量离开环境时，就会被标记为“离开环境”，被标记为“离开环境”的变量会被内存释放。</li><li>垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。</li><li>它会去掉环境中的变量以及被环境中的变量引用的标记。</li><li>在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。</li><li>垃圾收集器完成内存清除工作，销毁那些带标记的值，并回收他们所占用的内存空间。</li></ol><p><strong>引用计数</strong>：使用较少，常常会引起内存泄露。<br>引用计数就是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数就减1。当这个引用次数变为0时，说明这个变量已经没有价值，因此，在在机回收期下次再运行时，这个变量所占有的内存空间就会被释放出来。<br><strong>循环引用问题</strong>：例如：obj1和obj2通过属性进行相互引用，两个对象的引用次数都是2。当使用循环计数时，由于函数执行完后，两个对象都离开作用域，函数执行结束，obj1和obj2还将会继续存在，因此它们的引用次数永远不会是0，就会引起循环引用。</p><h2 id="★七、哪些情况会导致内存泄露"><a href="#★七、哪些情况会导致内存泄露" class="headerlink" title="★七、哪些情况会导致内存泄露"></a>★七、哪些情况会导致内存泄露</h2><ul><li><strong>意外的全局变量：</strong> 由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。</li><li><strong>被遗忘的计时器或回调函数：</strong> 设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。</li><li><strong>脱离 DOM 的引用：</strong> 获取一个 DOM 元素的引用，而后面这个元素被删除，由于一直保留了对这个元素的引用，所以它也无法被回收。</li><li><strong>闭包：</strong> 不合理的使用闭包，从而导致某些变量一直被留在内存当中。</li></ul><h2 id="八、前端模块化"><a href="#八、前端模块化" class="headerlink" title="八、前端模块化"></a>八、前端模块化</h2><p>好处：解决命名冲突、提供复用性、提高代码可维护性。<br>方式：<strong>AMD</strong>、<strong>CMD</strong>、<strong>CommonJs</strong>、<strong>ES6</strong>。<br>好处：解决命名冲突，提供复用性，提高代码可维护性、性能优化、模块化的版本管理、跨环境共享模块。<br>AMD、CMD、CommonJs是ES5中提供的模块化编程的方案，import&#x2F;export是ES6中定义新增的</p><h3 id="8-1-AMD异步模块定义"><a href="#8-1-AMD异步模块定义" class="headerlink" title="8.1 AMD异步模块定义"></a>8.1 AMD异步模块定义</h3><p>AMD是RequireJS在推广过程中对模块定义的规范化产出，它是一个概念，RequireJS是对这个概念的实现，就好比JavaScript语言是对ECMAScript规范的实现。AMD是一个组织，RequireJS是在这个组织下自定义的一套脚本语言<br>RequireJS：是一个AMD框架，可以异步加载JS文件，按照模块加载方法，通过define()函数定义，第一个参数是一个数组，里面定义一些需要依赖的包，第二个参数是一个回调函数，通过变量来引用模块里面的方法，最后通过return来输出。<br>是一个依赖前置、异步定义的AMD框架（在参数里面引入js文件），在定义的同时如果需要用到别的模块，在最前面定义好即在参数数组里面进行引入，在回调里面加载。</p><h3 id="8-2-CMD"><a href="#8-2-CMD" class="headerlink" title="8.2 CMD"></a>8.2 CMD</h3><p>CMD是SeaJS在推广过程中对模块定义的规范化产出，是一个同步模块定义，是SeaJS的一个标准，SeaJS是CMD概念的一个实现，SeaJS是淘宝团队提供的一个模块开发的js框架.<br>通过define()定义，没有依赖前置，通过require加载jQuery插件，CMD是依赖就近，在什么地方使用到插件就在什么地方require该插件，即用即返，这是一个同步的概念。</p><h3 id="8-3-CommonJS"><a href="#8-3-CommonJS" class="headerlink" title="8.3 CommonJS"></a>8.3 CommonJS</h3><p>CommonJS规范—是通过module.exports定义的，在前端浏览器里面并不支持module.exports,通过node.js后端使用的。Nodejs端是使用CommonJS规范的，前端浏览器一般使用AMD、CMD、ES6等定义模块化开发的。<br>输出方式有2种：默认输出—module export 和带有名字的输出—exports.area</p><h3 id="8-4-ES6"><a href="#8-4-ES6" class="headerlink" title="8.4 ES6"></a>8.4 ES6</h3><p>特性：模块化，export&#x2F;import对模块进行导出导入。<br>在早期，使用立即执行函数实现模块化是常见的手段，通过函数作用域解决了命名冲突、污染全局作用域的问题</p><h3 id="8-5-ES6和CommonJS模块的异同"><a href="#8-5-ES6和CommonJS模块的异同" class="headerlink" title="8.5 ES6和CommonJS模块的异同"></a>8.5 ES6和CommonJS模块的异同</h3><p><strong>区别</strong>：</p><ul><li><strong>CommonJS是对模块的拷贝</strong>：对于基本数据类型，属于复制。即会被模块缓存，一旦输出一个值，模块内部的变化不影响该值。可以进行重新赋值，改变指针指向。在另一个模块可以对该模块输出的变量重新赋值。对于复杂数据类型，属于浅拷贝。由于两个模块引用的对象指向同一个内存空间，因此对该模块的值做修改时会影响另一个模块。</li><li><strong>ES6模块输出的是值的引用</strong>：ES6模块中的值属于动态只读引用，不能改变其值，也就是指针指向不能变，对它重新赋值会报错。<br>对于<strong>只读</strong>来说，即不允许修改引入变量的值，import的变量是只读的，不论是基本数据类型还是复杂数据类型。JS引擎对脚本静态分析时，模块遇到import命令时，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。<br>对于<strong>动态</strong>来说，原始值发生变化，import加载的值也会发生变化。不论是基本数据类型还是复杂数据类型</li><li><strong>CommonJS是同步加载模块</strong>：当使用require命令加载某个模块时，就会运行整个模块的代码。主要用于服务器编程，模块文件一般在本地硬盘，在运行时加载，只有加载完成才能执行后面的操作。<br>当使用require命令加载同一个模块时，不会再执行该模块，而是取到缓存之中的值。也就是说，CommonJS模块无论加载多少次，都只会在第一次加载时运行一次，以后再加载，就返回第一次运行的结果，除非手动清除系统缓存。</li><li><strong>ES6是异步加载模块</strong>：如果是在浏览器环境中从服务端加载模块，浏览器加载模块不会堵塞浏览器，在整个页面渲染完再执行模块脚本。</li><li><strong>CommonJS模块是运行时加载</strong>：它加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。</li><li><strong>ES6模块是编译时输出接口</strong>：ES6模块不是对象，它的对外接口在代码静态解析阶段就会生成。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// lib.js</span><br><span class="hljs-keyword">var</span> counter = <span class="hljs-number">3</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">incCounter</span>(<span class="hljs-params"></span>) &#123;<br>  counter++;<br>&#125;<br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">counter</span>: counter,<br>  <span class="hljs-attr">incCounter</span>: incCounter,<br>&#125;;<br><span class="hljs-comment">// main.js</span><br><span class="hljs-keyword">var</span> mod = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./lib&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(mod.<span class="hljs-property">counter</span>);  <span class="hljs-comment">// 3</span><br>mod.<span class="hljs-title function_">incCounter</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(mod.<span class="hljs-property">counter</span>); <span class="hljs-comment">// 3</span><br><span class="hljs-comment">// lib.js</span><br><span class="hljs-keyword">var</span> counter = <span class="hljs-number">3</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">incCounter</span>(<span class="hljs-params"></span>) &#123;<br>  counter++;<br>&#125;<br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-keyword">get</span> <span class="hljs-title function_">counter</span>() &#123;<br>    <span class="hljs-keyword">return</span> counter<br>  &#125;,<br>  <span class="hljs-attr">incCounter</span>: incCounter,<br>&#125;;<br>$ node main.<span class="hljs-property">js</span><br><span class="hljs-number">3</span><br><span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p><strong>共同点</strong>：<br>CommonJS和ES6 Module都可以对引⼊的对象进⾏赋值，即对对象内部属性的值进⾏改变。</p><h3 id="8-6-require和import区别"><a href="#8-6-require和import区别" class="headerlink" title="8.6 require和import区别"></a>8.6 require和import区别</h3><p><strong>遵循规范不同</strong>：require&#x2F;exports是CommonJS的一部分，import&#x2F;export是ES6新规范。<br><strong>出现时间不同</strong>：CommonJS 作为 Node.js 的规范，一直沿用至今。由于 npm 上 CommonJS 的类库众多，以及 CommonJS 和 ES6 之间的差异，Node.js 无法直接兼容 ES6。所以现阶段 require&#x2F;exports 仍然是必要且是必须的。<br><strong>形式不同</strong>：<br>require&#x2F;exports用法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<br><span class="hljs-built_in">exports</span>.<span class="hljs-property">fs</span> = fs;<br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = fs;<br></code></pre></td></tr></table></figure><p>import&#x2F;export用法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> fs <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;fs&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123;<span class="hljs-keyword">default</span> <span class="hljs-keyword">as</span> fs&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;fs&#x27;</span>;<br><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> fs <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;fs&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> fs;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> fs;<br><span class="hljs-keyword">export</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;fs&#x27;</span>;<br></code></pre></td></tr></table></figure><p><strong>本质不同</strong>：CommonJS还是ES6 Module 输出都可以看成是一个具备多个属性或者方法的对象;default 是ES6 Module所独有的关键字，export default 输出默认的接口对象，import from ‘fs’可直接导入这个对象;<br>其它见上面。</p><h2 id="九、箭头函数"><a href="#九、箭头函数" class="headerlink" title="九、箭头函数"></a>九、箭头函数</h2><p>箭头函数相当于匿名函数，并且简化了函数定义。箭头函数有两种格式，一种只包含一个表达式，连{ … }和return都省略掉了。还有一种可以包含多条语句，这时候就不能省略{ … }和return。</p><h3 id="9-1-箭头函数和普通函数区别"><a href="#9-1-箭头函数和普通函数区别" class="headerlink" title="9.1 箭头函数和普通函数区别"></a>9.1 箭头函数和普通函数区别</h3><p><strong>①箭头函数比普通批就那个函数更加简洁</strong>：</p><ul><li>如果没有参数，就直接写一个空括号即可</li><li>如果只有一个参数，可以省去参数的括号</li><li>如果有多个参数，用逗号分割</li><li>如果函数体的返回值只有一句，可以省略大括号</li><li>如果函数体不需要返回值，且只有一句话，可以给这个语句前面加一个void关键字。最常见的就是调用一个函数：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> <span class="hljs-title function_">fn</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">doesNotReturn</span>();<br></code></pre></td></tr></table></figure><p><strong>②箭头函数没有自己的this</strong>：箭头函数不会创建自己的this，它只会在自己的作用域上一层继承this，会捕获其上下文的this值作为自己的this，所以箭头函数中this的指向在它在定义时已经确定了，之后不会改变。<br><strong>③箭头函数继承来的this指向永远不会改变</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> id = <span class="hljs-string">&#x27;GLOBAL&#x27;</span>;<br><span class="hljs-keyword">var</span> obj = &#123;<br>  <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;OBJ&#x27;</span>,<br>  <span class="hljs-attr">a</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span>);<br>  &#125;,<br>  <span class="hljs-attr">b</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span>);<br>  &#125;<br>&#125;;<br>obj.<span class="hljs-title function_">a</span>();    <span class="hljs-comment">// &#x27;OBJ&#x27;</span><br>obj.<span class="hljs-title function_">b</span>();    <span class="hljs-comment">// &#x27;GLOBAL&#x27;</span><br><span class="hljs-keyword">new</span> obj.<span class="hljs-title function_">a</span>()  <span class="hljs-comment">// undefined</span><br><span class="hljs-keyword">new</span> obj.<span class="hljs-title function_">b</span>()  <span class="hljs-comment">// Uncaught TypeError: obj.b is not a constructor</span><br></code></pre></td></tr></table></figure><p>对象obj的方法b是使用箭头函数定义的，这个函数中的this就永远指向它定义时所处的全局执行环境中的this，即便这个函数是作为对象obj的方法调用，this依旧指向Window对象。需要注意，定义对象的大括号{}是无法形成一个单独的执行环境的，它依旧是处于全局执行环境中。<br><strong>④call、apply、bind等方法不能改变箭头函数中this的指向</strong><br>只传入了参数，对this没有影响。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> id = <span class="hljs-string">&#x27;Global&#x27;</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-title function_">fun1</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span>)<br>&#125;;<br><span class="hljs-title function_">fun1</span>();                     <span class="hljs-comment">// &#x27;Global&#x27;</span><br>fun1.<span class="hljs-title function_">call</span>(&#123;<span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;Obj&#x27;</span>&#125;);     <span class="hljs-comment">// &#x27;Global&#x27;</span><br>fun1.<span class="hljs-title function_">apply</span>(&#123;<span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;Obj&#x27;</span>&#125;);    <span class="hljs-comment">// &#x27;Global&#x27;</span><br>fun1.<span class="hljs-title function_">bind</span>(&#123;<span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;Obj&#x27;</span>&#125;)();   <span class="hljs-comment">// &#x27;Global&#x27;</span><br></code></pre></td></tr></table></figure><p><strong>⑤箭头函数不能作为构造函数使用</strong>：<br>构造函数在new的步骤在上面已经说过了，实际上第二步就是将函数中的this指向该对象。 但是由于箭头函数时没有自己的this的，且this指向外层的执行环境，且不能改变指向，所以不能当做构造函数使用，不能使用new。<br><strong>⑥箭头函数没有自己的arguments</strong>：<br>箭头函数没有自己的arguments对象。在箭头函数中访问arguments实际上获得的是它外层函数的arguments值。用rest参数解决。<br><strong>⑦箭头函数没有prototype</strong>：<br>没有原型属性，不能简单的返回对象的字面量。<br><strong>⑧箭头函数不能用作Genterator函数，不能使用yeild关键字</strong></p><h3 id="9-2-箭头函数特点"><a href="#9-2-箭头函数特点" class="headerlink" title="9.2 箭头函数特点"></a>9.2 箭头函数特点</h3><p>一、箭头函数只能用赋值式写法，不能用声明式写法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">test</span> = (<span class="hljs-params">name</span>) =&gt; &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name)<br>&#125;<br><span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;Jerry&#x27;</span>)<br></code></pre></td></tr></table></figure><p>二、如果参数只有一个，可以不加括号，如果没有参数或者参数多于一个就需要加括号。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">test</span> = name =&gt; &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name)<br>&#125;<br><span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;Jerry&#x27;</span>)<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">test2</span> = (<span class="hljs-params">name1, name2</span>) =&gt; &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name1 + <span class="hljs-string">&#x27; and &#x27;</span> + name2)<br>&#125;<br><span class="hljs-title function_">test2</span>(<span class="hljs-string">&#x27;Tom&#x27;</span>, <span class="hljs-string">&#x27;Jerry&#x27;</span>)<br></code></pre></td></tr></table></figure><p>三、人函数体只有一句话，可以不加花括号。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">test</span> = name =&gt; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name)<br></code></pre></td></tr></table></figure><p>四、如果函数体没有括号，可以不写return，箭头函数会帮你return</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">add</span> = (<span class="hljs-params">p1, p2</span>) =&gt; p1 + p2<br><span class="hljs-title function_">add</span>(<span class="hljs-number">10</span>, <span class="hljs-number">25</span>)<br></code></pre></td></tr></table></figure><h3 id="9-3-箭头函数中的this"><a href="#9-3-箭头函数中的this" class="headerlink" title="9.3 箭头函数中的this"></a>9.3 箭头函数中的this</h3><h2 id="十、DOM和BOM"><a href="#十、DOM和BOM" class="headerlink" title="十、DOM和BOM"></a>十、DOM和BOM</h2><h3 id="10-1-BOM"><a href="#10-1-BOM" class="headerlink" title="10.1 BOM"></a>10.1 BOM</h3><p>BOM 指的是<strong>浏览器对象模型</strong>，它指的是把浏览器当做一个对象来对待，这个对象主要定义了与浏览器进行交互的法和接口。BOM的核心是 window，而 window 对象具有双重角色，它既是通过 js 访问浏览器窗口的一个接口，又是一个 Global（全局）对象。这意味着在网页中定义的任何对象，变量和函数，都作为全局对象的一个属性或者方法存在。window 对象含有 location 对象、navigator 对象、screen 对象等子对象，并且 DOM 的最根本的对象 document 对象也是 BOM 的 window 对象的子对象。<br><strong>常见操作</strong>：<br>把窗口移动到指定坐标位置（左上角0,0）：window.moveTo(x,y)<br>把窗口移动指定像素：window.moveBy(x,y)<br>窗口大小：window.innerWidth,window.innerHeight<br>视口滚动指定像素：window.scrollBy(x,y)<br>视口滚动到指定坐标：window.scrollTo(x,y)<br>打开指定窗口：window.open(url,”wroxWindow”,style)</p><h3 id="10-2-DOM"><a href="#10-2-DOM" class="headerlink" title="10.2 DOM"></a>10.2 DOM</h3><p>DOM 指的是文档对象模型，它指的是把文档当做一个对象，这个对象主要定义了处理网页内容的方法和接口。<br><strong>常见操作</strong>：<br>根据ID获取元素：document.getElementById(name)<br>创建元素：document.createElement(“div”)</p><h1 id="三-五-性能优化"><a href="#三-五-性能优化" class="headerlink" title="三.五 性能优化"></a>三.五 性能优化</h1><h2 id="一、节流与防抖"><a href="#一、节流与防抖" class="headerlink" title="一、节流与防抖"></a>一、节流与防抖</h2><h3 id="1-对节流与防抖的理解"><a href="#1-对节流与防抖的理解" class="headerlink" title="1. 对节流与防抖的理解"></a>1. 对节流与防抖的理解</h3><ul><li><p>函数防抖是指在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。这可以使用在一些点击请求的事件上，避免因为用户的多次点击向后端发送多次请求。</p></li><li><p>函数节流是指规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。节流可以使用在 scroll 函数的事件监听上，通过事件节流来降低事件调用的频率。</p><p><strong>防抖函数的应用场景：</strong></p></li><li><p>按钮提交场景：防⽌多次提交按钮，只执⾏最后提交的⼀次</p></li><li><p>服务端验证场景：表单验证需要服务端配合，只执⾏⼀段连续的输⼊事件的最后⼀次，还有搜索联想词功能类似⽣存环境请⽤lodash.debounce</p><p><strong>节流函数的适⽤场景：</strong></p></li><li><p>拖拽场景：固定时间内只执⾏⼀次，防⽌超⾼频次触发位置变动</p></li><li><p>缩放场景：监控浏览器resize</p></li><li><p>动画场景：避免短时间内多次触发动画引起性能问题</p></li></ul><h3 id="2-实现节流函数和防抖函数"><a href="#2-实现节流函数和防抖函数" class="headerlink" title="2. 实现节流函数和防抖函数"></a>2. 实现节流函数和防抖函数</h3><p><strong>函数防抖的实现：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">fn, wait</span>) &#123;<br>  <span class="hljs-keyword">var</span> timer = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> context = <span class="hljs-variable language_">this</span>,<br>      args = [...<span class="hljs-variable language_">arguments</span>];<br>    <span class="hljs-comment">// 如果此时存在定时器的话，则取消之前的定时器重新记时</span><br>    <span class="hljs-keyword">if</span> (timer) &#123;<br>      <span class="hljs-built_in">clearTimeout</span>(timer);<br>      timer = <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-comment">// 设置定时器，使事件间隔指定事件后执行</span><br>    timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      fn.<span class="hljs-title function_">apply</span>(context, args);<br>    &#125;, wait);<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>函数节流的实现：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 时间戳版</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">fn, delay</span>) &#123;<br>  <span class="hljs-keyword">var</span> preTime = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> context = <span class="hljs-variable language_">this</span>,<br>      args = [...<span class="hljs-variable language_">arguments</span>],<br>      nowTime = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<br>    <span class="hljs-comment">// 如果两次时间间隔超过了指定时间，则执行函数。</span><br>    <span class="hljs-keyword">if</span> (nowTime - preTime &gt;= delay) &#123;<br>      preTime = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<br>      <span class="hljs-keyword">return</span> fn.<span class="hljs-title function_">apply</span>(context, args);<br>    &#125;<br>  &#125;;<br>&#125;<br><span class="hljs-comment">// 定时器版</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span> (fun, wait)&#123;<br>  <span class="hljs-keyword">let</span> timeout = <span class="hljs-literal">null</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">let</span> context = <span class="hljs-variable language_">this</span><br>    <span class="hljs-keyword">let</span> args = [...<span class="hljs-variable language_">arguments</span>]<br>    <span class="hljs-keyword">if</span>(!timeout)&#123;<br>      timeout = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        fun.<span class="hljs-title function_">apply</span>(context, args)<br>        timeout = <span class="hljs-literal">null</span><br>      &#125;, wait)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二、图片优化"><a href="#二、图片优化" class="headerlink" title="二、图片优化"></a>二、图片优化</h2><h3 id="2-1-如何对项目中的图片进行优化"><a href="#2-1-如何对项目中的图片进行优化" class="headerlink" title="2.1 如何对项目中的图片进行优化"></a>2.1 如何对项目中的图片进行优化</h3><ol><li>不用图片。很多时候会使用到很多修饰类图片，其实这类修饰图片完全可以用 CSS 去代替。</li><li>对于移动端来说，屏幕宽度就那么点，完全没有必要去加载原图浪费带宽。一般图片都用 CDN 加载，可以计算出适配屏幕的宽度，然后去请求相应裁剪好的图片。</li><li>小图使用 base64 格式</li><li>将多个图标文件整合到一张图片中（雪碧图）</li><li>选择正确的图片格式：<ul><li>对于能够显示 WebP 格式的浏览器尽量使用 WebP 格式。因为 WebP 格式具有更好的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量，缺点就是兼容性并不好</li><li>小图使用 PNG，其实对于大部分图标这类图片，完全可以使用 SVG 代替</li><li>照片使用 JPEG</li></ul></li></ol><h3 id="2-2-常见图片格式"><a href="#2-2-常见图片格式" class="headerlink" title="2.2 常见图片格式"></a>2.2 常见图片格式</h3><p>（1）<strong>BMP</strong>，是无损的、既支持索引色也支持直接色的点阵图。这种图片格式几乎没有对数据进行压缩，所以BMP格式的图片通常是较大的文件。<br>（2）<strong>GIF</strong>是无损的、采用索引色的点阵图。采用LZW压缩算法进行编码。文件小，是GIF格式的优点，同时，GIF格式还具有支持动画以及透明的优点。但是GIF格式仅支持8bit的索引色，所以GIF格式适用于对色彩要求不高同时需要文件体积较小的场景。<br>（3）<strong>JPEG</strong>是有损的、采用直接色的点阵图。JPEG的图片的优点是采用了直接色，得益于更丰富的色彩，JPEG非常适合用来存储照片，与GIF相比，JPEG不适合用来存储企业Logo、线框类的图。因为有损压缩会导致图片模糊，而直接色的选用，又会导致图片文件较GIF更大。<br>（4）<strong>PNG-8</strong>是无损的、使用索引色的点阵图。PNG是一种比较新的图片格式，PNG-8是非常好的GIF格式替代者，在可能的情况下，应该尽可能的使用PNG-8而不是GIF，因为在相同的图片效果下，PNG-8具有更小的文件体积。除此之外，PNG-8还支持透明度的调节，而GIF并不支持。除非需要动画的支持，否则没有理由使用GIF而不是PNG-8。<br>（5）<strong>PNG-24</strong>是无损的、使用直接色的点阵图。PNG-24的优点在于它压缩了图片的数据，使得同样效果的图片，PNG-24格式的文件大小要比BMP小得多。当然，PNG24的图片还是要比JPEG、GIF、PNG-8大得多。<br>（6）<strong>SVG</strong>是无损的矢量图。SVG是矢量图意味着SVG图片由直线和曲线以及绘制它们的方法组成。当放大SVG图片时，看到的还是线和曲线，而不会出现像素点。这意味着SVG图片在放大时，不会失真，所以它非常适合用来绘制Logo、Icon等。<br>（7）<strong>WebP</strong>是谷歌开发的一种新图片格式，WebP是同时支持有损和无损压缩的、使用直接色的点阵图。从名字就可以看出来它是为Web而生的，什么叫为Web而生呢？就是说相同质量的图片，WebP具有更小的文件体积。现在网站上充满了大量的图片，如果能够降低每一个图片的文件大小，那么将大大减少浏览器和服务器之间的数据传输量，进而降低访问延迟，提升访问体验。目前只有Chrome浏览器和Opera浏览器支持WebP格式，兼容性不太好。</p><ul><li>在无损压缩的情况下，相同质量的WebP图片，文件大小要比PNG小26%；</li><li>在有损压缩的情况下，具有相同图片精度的WebP图片，文件大小要比JPEG小25%~34%；</li><li>WebP图片格式支持图片透明度，一个无损压缩的WebP图片，如果要支持透明度只需要22%的格外文件大小。</li></ul>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3.无重复字符的最长子串</title>
    <link href="/2022/07/11/3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
    <url>/2022/07/11/3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。</p><p>输入: s &#x3D; “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>使用滑动窗口，分别设置左指针和右指针，指向数组开头。<br>设置一个集合，用于记录每个字符在窗口中出现的次数。开始右指针向右移动一位，并将窗口中增加的字符出现的次数加一，若该次数大于1，则出现重复，将左指针右移并将每次移出窗口的字符出现次数减一，直到所有字符出现次数都不大于一。记录此时窗口大小，并判断是否要更新最大值。<br>然后循环，每次将右指针向右移动一位。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> lengthOfLongestSubstring = <span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable language_">window</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br>    <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> maxlen = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> right=<span class="hljs-number">0</span>;right&lt;s.<span class="hljs-property">length</span>;right++)&#123;<br>        <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">set</span>(s[right],<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">has</span>(s[right])?<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">get</span>(s[right])+<span class="hljs-number">1</span>:<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">while</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">get</span>(s[right])&gt;<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">set</span>(s[left],<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">get</span>(s[left])-<span class="hljs-number">1</span>);<br>            left++;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(right-left+<span class="hljs-number">1</span>&gt;maxlen)&#123;<br>            maxlen = right-left+<span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> maxlen;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>数组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>438.找到字符串中所有字母的异位词</title>
    <link href="/2022/07/11/438-%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E7%9A%84%E5%BC%82%E4%BD%8D%E8%AF%8D/"/>
    <url>/2022/07/11/438-%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E7%9A%84%E5%BC%82%E4%BD%8D%E8%AF%8D/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。<br>异位词 指由相同字母重排列形成的字符串（包括相同的字符串）。</p><p>输入: s &#x3D; “cbaebabacd”, p &#x3D; “abc”<br>输出: [0,6]<br>解释:<br>起始索引等于 0 的子串是 “cba”, 它是 “abc” 的异位词。<br>起始索引等于 6 的子串是 “bac”, 它是 “abc” 的异位词。</p><p>1 &lt;&#x3D; s.length, p.length &lt;&#x3D; 3 * 104s 和 p 仅包含小写字母</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>首先建立一个数组，统计s1中每个字符出现的次数，均设置为负值，表示要用来填补的次数。<br>设置左右指针，开始右指针右移，每个字符都要在统计数组对应处加一，若加一后该处值为正值，则要进行左指针右移，同时每个字符都要在统计数组中对应处减一（满足时数组所有值为0，不应有大于0的值），直到该处值为0。<br>若该次循环后窗口大小等于s1长度，则匹配成功，将左指针加入到结果数组中，继续进行循环。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> findAnagrams = <span class="hljs-keyword">function</span>(<span class="hljs-params">s, p</span>) &#123;<br>    <span class="hljs-keyword">let</span> res = [];<br>    <span class="hljs-keyword">const</span> n = s.<span class="hljs-property">length</span>,m = p.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">if</span>(m&gt;n)&#123;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">const</span> count = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">26</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>        count[p[i].<span class="hljs-title function_">charCodeAt</span>()-<span class="hljs-string">&#x27;a&#x27;</span>.<span class="hljs-title function_">charCodeAt</span>()]--;<br>    &#125;<br>    <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> right=<span class="hljs-number">0</span>;right&lt;n;right++)&#123;<br>        <span class="hljs-keyword">const</span> x = s[right].<span class="hljs-title function_">charCodeAt</span>() - <span class="hljs-string">&#x27;a&#x27;</span>.<span class="hljs-title function_">charCodeAt</span>();<br>        count[x]++;<br>        <span class="hljs-keyword">while</span>(count[x]&gt;<span class="hljs-number">0</span>)&#123;<br>            count[s[left].<span class="hljs-title function_">charCodeAt</span>()-<span class="hljs-string">&#x27;a&#x27;</span>.<span class="hljs-title function_">charCodeAt</span>()]--;<br>            left++;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(right-left+<span class="hljs-number">1</span>===m)&#123;<br>            res.<span class="hljs-title function_">push</span>(left);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>数组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>567.字符串的排列</title>
    <link href="/2022/07/11/567-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/"/>
    <url>/2022/07/11/567-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你两个字符串 s1 和 s2 ，写一个函数来判断 s2 是否包含 s1 的排列。如果是，返回 true ；否则，返回 false 。<br>换句话说，s1 的排列之一是 s2 的 子串 。</p><p>输入：s1 &#x3D; “ab” s2 &#x3D; “eidbaooo”<br>输出：true<br>解释：s2 包含 s1 的排列之一 (“ba”).</p><p>1 &lt;&#x3D; s1.length, s2.length &lt;&#x3D; 10000<br>s1 和 s2 仅包含小写字母</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>首先建立一个数组，统计s1中每个字符出现的次数，均设置为负值，表示要用来填补的次数。<br>设置左右指针，开始右指针右移，每个字符都要在统计数组对应处加一，若加一后该处值为正值，则要进行左指针右移，同时每个字符都要在统计数组中对应处减一（满足时数组所有值为0，不应有大于0的值），直到该处值为0。<br>若该次循环后窗口大小等于s1长度，则匹配成功，否则继续进行循环。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> checkInclusion = <span class="hljs-keyword">function</span>(<span class="hljs-params">s1, s2</span>) &#123;<br>    <span class="hljs-keyword">const</span> n = s1.<span class="hljs-property">length</span>, m = s2.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">if</span>(n&gt;m)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">const</span> count = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">26</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        count[s1[i].<span class="hljs-title function_">charCodeAt</span>()-<span class="hljs-string">&#x27;a&#x27;</span>.<span class="hljs-title function_">charCodeAt</span>()]--;<br>    &#125;<br>    <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> right=<span class="hljs-number">0</span>;right&lt;m;right++)&#123;<br>        <span class="hljs-keyword">const</span> x = s2[right].<span class="hljs-title function_">charCodeAt</span>() - <span class="hljs-string">&#x27;a&#x27;</span>.<span class="hljs-title function_">charCodeAt</span>();<br>        count[x]++;<br>        <span class="hljs-keyword">while</span>(count[x]&gt;<span class="hljs-number">0</span>)&#123;<br>            count[s2[left].<span class="hljs-title function_">charCodeAt</span>()-<span class="hljs-string">&#x27;a&#x27;</span>.<span class="hljs-title function_">charCodeAt</span>()]--;<br>            left++;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(right-left+<span class="hljs-number">1</span>===n)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>数组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>76.最小覆盖子串</title>
    <link href="/2022/07/11/76-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2/"/>
    <url>/2022/07/11/76-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 “” 。</p><p>注意：<br>对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。<br>如果 s 中存在这样的子串，我们保证它是唯一的答案。</p><p>输入：s &#x3D; “ADOBECODEBANC”, t &#x3D; “ABC”<br>输出：”BANC”</p><p>1 &lt;&#x3D; s.length, t.length &lt;&#x3D; 105s 和 t 由英文字母组成</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>使用滑动窗口，先将左右指针指向开头，同时用一个集合记录t中每个字母出现次数。<br>向右移动右指针，遇到需要的字母集合中该字母的记录就减一，直到集合中所有字母的记录都小于等于0。此时再将左指针向右移动，遇到需要的字母集合中该字母的记录就加一，直到集合中所有字母的记录中出现大于0的项。此时判断该字符串是否为最小字符串，若是，则更新最小字符串。<br>重复这个过程直到右指针指向结尾。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> minWindow = <span class="hljs-keyword">function</span>(<span class="hljs-params">s, t</span>) &#123;<br>    <span class="hljs-keyword">let</span> l=<span class="hljs-number">0</span>,r=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">const</span> need = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> c <span class="hljs-keyword">of</span> t)&#123;<br>        need.<span class="hljs-title function_">set</span>(c,need.<span class="hljs-title function_">has</span>(c)? need.<span class="hljs-title function_">get</span>(c)+<span class="hljs-number">1</span>:<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">let</span> needSize = need.<span class="hljs-property">size</span>;<br>    <span class="hljs-keyword">let</span> res=<span class="hljs-string">&#x27;&#x27;</span>;<br>    <span class="hljs-keyword">while</span>(r&lt;s.<span class="hljs-property">length</span>)&#123;<br>        <span class="hljs-keyword">let</span> c = s[r];<br>        <span class="hljs-keyword">if</span>(need.<span class="hljs-title function_">has</span>(c))&#123;<br>            need.<span class="hljs-title function_">set</span>(c,need.<span class="hljs-title function_">get</span>(c)-<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span>(need.<span class="hljs-title function_">get</span>(c)===<span class="hljs-number">0</span>)&#123;<br>                needSize--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(needSize===<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">const</span> newRes = s.<span class="hljs-title function_">substring</span>(l,r+<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span>(!res||newRes.<span class="hljs-property">length</span>&lt;res.<span class="hljs-property">length</span>)&#123;<br>                res = newRes;<br>            &#125;<br>            <span class="hljs-keyword">const</span> c2 = s[l];<br>            <span class="hljs-keyword">if</span>(need.<span class="hljs-title function_">has</span>(c2))&#123;<br>                need.<span class="hljs-title function_">set</span>(c2,need.<span class="hljs-title function_">get</span>(c2)+<span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span>(need.<span class="hljs-title function_">get</span>(c2) === <span class="hljs-number">1</span>)&#123;<br>                    needSize += <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>            l++;<br>        &#125;<br>        r++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>数组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>59.螺旋矩阵II</title>
    <link href="/2022/07/11/59-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5II/"/>
    <url>/2022/07/11/59-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5II/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。</p><p>输入：n &#x3D; 3<br>输出：[[1,2,3],[8,9,4],[7,6,5]]</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>设置上下左右边界，每次循环走最外边一圈，同时要判断边界是否正常。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> generateMatrix = <span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>) &#123;<br>    <span class="hljs-keyword">let</span> left=<span class="hljs-number">0</span>,right=n-<span class="hljs-number">1</span>,up=<span class="hljs-number">0</span>,down=n-<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">let</span> res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(n).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>).<span class="hljs-title function_">map</span>(<span class="hljs-function">()=&gt;</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(n).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">let</span> i=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;=n*n)&#123;<br>        <span class="hljs-keyword">if</span>(up&lt;=down)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j=left;j&lt;=right;j++)&#123;<br>                res[up][j] = i;<br>                i++;<br>            &#125;<br>            up++;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(left&lt;=right)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j=up;j&lt;=down;j++)&#123;<br>                res[j][right] = i;<br>                i++<br>            &#125;<br>            right--;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(up&lt;=down)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j=right;j&gt;=left;j--)&#123;<br>                res[down][j] = i;<br>                i++;<br>            &#125;<br>            down--;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(left&lt;=right)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j=down;j&gt;=up;j--)&#123;<br>                res[j][left] = i;<br>                i++;<br>            &#125;<br>            left++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>数组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>54.螺旋矩阵</title>
    <link href="/2022/07/11/54-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/"/>
    <url>/2022/07/11/54-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。</p><p>输入：matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]<br>输出：[1,2,3,6,9,8,7,4,5]</p><p>m &#x3D;&#x3D; matrix.length<br>n &#x3D;&#x3D; matrix[i].length<br>1 &lt;&#x3D; m, n &lt;&#x3D; 10<br>-100 &lt;&#x3D; matrix[i][j] &lt;&#x3D; 100</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>设置四个边界，分别代表上下左右。<br>每次循环走完最外面一圈，注意走的时候先看边界上&lt;下、左&lt;右是否满足。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> spiralOrder = <span class="hljs-keyword">function</span>(<span class="hljs-params">matrix</span>) &#123;<br>    <span class="hljs-keyword">const</span> m=matrix.<span class="hljs-property">length</span>,n=matrix[<span class="hljs-number">0</span>].<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">let</span> left=<span class="hljs-number">0</span>,right=n-<span class="hljs-number">1</span>,up=<span class="hljs-number">0</span>,down=m-<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">let</span> res = [];<br>    <span class="hljs-keyword">while</span>(res.<span class="hljs-property">length</span>&lt;m*n)&#123;<br>        <span class="hljs-keyword">if</span>(up&lt;=down)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=left;i&lt;=right;i++)&#123;<br>                res.<span class="hljs-title function_">push</span>(matrix[up][i]);<br>            &#125;<br>            up++;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(left&lt;=right)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=up;i&lt;=down;i++)&#123;<br>                res.<span class="hljs-title function_">push</span>(matrix[i][right]);<br>            &#125;<br>            right--;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(up&lt;=down)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=right;i&gt;=left;i--)&#123;<br>                res.<span class="hljs-title function_">push</span>(matrix[down][i]);<br>            &#125;<br>            down--;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(left&lt;=right)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=down;i&gt;=up;i--)&#123;<br>                res.<span class="hljs-title function_">push</span>(matrix[i][left]);<br>            &#125;<br>            left++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>数组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>48.旋转图像</title>
    <link href="/2022/07/11/48-%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/"/>
    <url>/2022/07/11/48-%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。<br>你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。<br>输入：matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]<br>输出：[[7,4,1],[8,5,2],[9,6,3]]</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>先把矩阵沿从左上到右下的对角线对称，然后把矩阵沿中间竖线对称。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> rotate = <span class="hljs-keyword">function</span>(<span class="hljs-params">matrix</span>) &#123;<br>    <span class="hljs-keyword">const</span> n = matrix.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j=<span class="hljs-number">0</span>;j&lt;i;j++)&#123;<br>            [matrix[i][j],matrix[j][i]] = [matrix[j][i],matrix[i][j]];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j=<span class="hljs-number">0</span>;j&lt;(n-<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>;j++)&#123;<br>            [matrix[i][j],matrix[i][n-<span class="hljs-number">1</span>-j]] = [matrix[i][n-<span class="hljs-number">1</span>-j],matrix[i][j]];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> matrix;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>数组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1094.拼车</title>
    <link href="/2022/07/11/1094-%E6%8B%BC%E8%BD%A6/"/>
    <url>/2022/07/11/1094-%E6%8B%BC%E8%BD%A6/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>车上最初有 capacity 个空座位。车 只能 向一个方向行驶（也就是说，不允许掉头或改变方向）<br>给定整数 capacity 和一个数组 trips ,  trip[i] &#x3D; [numPassengersi, fromi, toi] 表示第 i 次旅行有 numPassengersi 乘客，接他们和放他们的位置分别是 fromi 和 toi 。这些位置是从汽车的初始位置向东的公里数。<br>当且仅当你可以在所有给定的行程中接送所有乘客时，返回 true，否则请返回 false。</p><p>输入：trips &#x3D; [[2,1,5],[3,3,7]], capacity &#x3D; 4<br>输出：false</p><p>1 &lt;&#x3D; trips.length &lt;&#x3D; 1000<br>trips[i].length &#x3D;&#x3D; 3<br>1 &lt;&#x3D; numPassengersi &lt;&#x3D; 100<br>0 &lt;&#x3D; fromi &lt; toi &lt;&#x3D; 1000<br>1 &lt;&#x3D; capacity &lt;&#x3D; 105</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>构建差分数组，记录上车和下车的时间节点，最后依次求得到达每个站台的人数。注意，此题目中站台从0开始，需要看开始时人数是否超标；下车点时该车上要减去相应人数，不用等到下一个点再减去。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> carPooling = <span class="hljs-keyword">function</span>(<span class="hljs-params">trips, capacity</span>) &#123;<br>    <span class="hljs-keyword">let</span> nums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">1000</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> seat <span class="hljs-keyword">of</span> trips)&#123;<br>        nums[seat[<span class="hljs-number">1</span>]] += seat[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">if</span>(seat[<span class="hljs-number">2</span>]&lt;=<span class="hljs-number">1000</span>)&#123;<br>            nums[seat[<span class="hljs-number">2</span>]] -= seat[<span class="hljs-number">0</span>];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(nums[<span class="hljs-number">0</span>]&gt;capacity)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125; <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">1</span>;i&lt;<span class="hljs-number">1001</span>;i++)&#123;<br>        nums[i] += nums[i-<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span>(nums[i]&gt;capacity)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125; <br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>数组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1109.航班预订统计</title>
    <link href="/2022/07/11/1109-%E8%88%AA%E7%8F%AD%E9%A2%84%E8%AE%A2%E7%BB%9F%E8%AE%A1/"/>
    <url>/2022/07/11/1109-%E8%88%AA%E7%8F%AD%E9%A2%84%E8%AE%A2%E7%BB%9F%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>这里有 n 个航班，它们分别从 1 到 n 进行编号。<br>有一份航班预订表 bookings ，表中第 i 条预订记录 bookings[i] &#x3D; [firsti, lasti, seatsi] 意味着在从 firsti 到 lasti （包含 firsti 和 lasti ）的 每个航班 上预订了 seatsi 个座位。<br>请你返回一个长度为 n 的数组 answer，里面的元素是每个航班预定的座位总数。</p><p>输入：bookings &#x3D; [[1,2,10],[2,3,20],[2,5,25]], n &#x3D; 5<br>输出：[10,55,45,25,25]<br>解释：<br>航班编号        1   2   3   4   5<br>预订记录 1 ：   10  10<br>预订记录 2 ：       20  20<br>预订记录 3 ：       25  25  25  25<br>总座位数：      10  55  45  25  25<br>因此，answer &#x3D; [10,55,45,25,25]</p><p>1 &lt;&#x3D; n &lt;&#x3D; 2 * 104<br>1 &lt;&#x3D; bookings.length &lt;&#x3D; 2 * 104<br>bookings[i].length &#x3D;&#x3D; 3<br>1 &lt;&#x3D; firsti &lt;&#x3D; lasti &lt;&#x3D; n<br>1 &lt;&#x3D; seatsi &lt;&#x3D; 104</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>直接设置一个长度为n值为0的数组作为差分数组，每次增加座位数，就是把差分数组对应开头加上座位数，然后在结尾的下一个元素再减去座位数。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> corpFlightBookings = <span class="hljs-keyword">function</span>(<span class="hljs-params">bookings, n</span>) &#123;<br>    <span class="hljs-keyword">let</span> nums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(n).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> seat <span class="hljs-keyword">of</span> bookings)&#123;<br>        nums[seat[<span class="hljs-number">0</span>]-<span class="hljs-number">1</span>] += seat[<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">if</span>(seat[<span class="hljs-number">1</span>]&lt;n)&#123;<br>            nums[seat[<span class="hljs-number">1</span>]] -= seat[<span class="hljs-number">2</span>];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>        nums[i] += nums[i-<span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-keyword">return</span> nums;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>数组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>应用层(HTTP+DNS)</title>
    <link href="/2022/07/06/%E5%BA%94%E7%94%A8%E5%B1%82-HTTP/"/>
    <url>/2022/07/06/%E5%BA%94%E7%94%A8%E5%B1%82-HTTP/</url>
    
    <content type="html"><![CDATA[<h2 id="一、HTTP请求方法"><a href="#一、HTTP请求方法" class="headerlink" title="一、HTTP请求方法"></a>一、HTTP请求方法</h2><ul><li>GET：使用url从指定的资源请求数据，只是检索数据，不会对数据产生其他影响。请求的数据量有限，请求的数据放在url里，例如&#x2F;test&#x2F;demo.php?name1&#x3D;value1&amp;name2&#x3D;value2。处理敏感数据时不可以用GET，<strong>请求可以被缓存</strong>。</li><li>POST：向指定的资源提交要被处理的数据，用以创建或更新资源，对数据长度没有限制，无法被缓存。</li><li>HEAD：获取报文首部，与GET相同，没有响应体，只传输状态行和标题部分，只返回HTTP报头。</li><li>PUT：用于将数据发送到服务器以创建或更新资源，用上传的内容替换目标资源中所有当前内容。会将包含的元素放在所提供的url下，如果url指示的是当前资源，则会发生改变。如果url未指示当前资源，则服务器可以使用该url创建资源。</li><li>DELETE：用来删除指定资源，删除url给出的目标资源的所有当前内容。</li><li>CONNECT：建立到给定url表示的服务器隧道，把请求连接转换到透明的TCP&#x2F;IP通道。</li><li>OPTIONS：返回服务器支持的HTTP方法，用来跨域请求。</li><li>TRACE：沿到目标资源的路径执行消息环回测试（从通信设备发出的信号又返回原处）。</li><li>PATCH：对PUT的补充，对已知资源进行<strong>局部</strong>更新。</li></ul><h2 id="二、HTTP请求报文和响应报文的格式"><a href="#二、HTTP请求报文和响应报文的格式" class="headerlink" title="二、HTTP请求报文和响应报文的格式"></a>二、HTTP请求报文和响应报文的格式</h2> <img src="/2022/07/06/%E5%BA%94%E7%94%A8%E5%B1%82-HTTP/%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87.png" class="" title="请求报文的格式"> <h3 id="请求报文：请求行-首部行-空行-请求体"><a href="#请求报文：请求行-首部行-空行-请求体" class="headerlink" title="请求报文：请求行+首部行+空行+请求体"></a>请求报文：请求行+首部行+空行+请求体</h3><ul><li>请求行：方法、URL、HTTP版本（所用的协议）。</li><li>首部行（请求头信息）：多组键值对，首部3字段名+值，包括请求体的长度等等。</li><li>请求体：GET时为空，POST时不空。</li></ul><h3 id="响应报文：响应行-响应头信息-空行-主体信息"><a href="#响应报文：响应行-响应头信息-空行-主体信息" class="headerlink" title="响应报文：响应行+响应头信息+空行+主体信息"></a>响应报文：响应行+响应头信息+空行+主体信息</h3><ul><li>响应行：协议、状态码、状态文字，如HTTP&#x2F;1.1 200 OK</li><li>响应头信息：键值对</li><li>主体信息：可能为空，服务器相应的数据</li></ul><h2 id="三、HTTP和HTTPS的区别"><a href="#三、HTTP和HTTPS的区别" class="headerlink" title="三、HTTP和HTTPS的区别"></a>三、HTTP和HTTPS的区别</h2><ul><li>HTTP是一种超文本传输协议，基于TCP协议。</li><li>HTTP明文传输，数据都是未加密的，可以直接获取其中消息，安全性较差，HTTPS数据传输过程是ssl加密的，安全性较好。</li><li>HTTPS协议需要到CA证书，费用较高，HTTP不需要。</li><li>HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li><li>HTTP的连接很简单，是无状态的331，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比HTTP协议安全。</li><li>HTTP页面相应速度比HTTPS快，主要是因为HTTP使用TCP三次握手建立连接，客户端和服务器需要交换三个包。而HTTPS除了TCP的三个包，还要加上SSL握手需要的9个包，一共是12个包。</li><li>HTTPS就是构建在SSL&#x2F;TLS之上的HTTP协议，所以HTTPS比HTTP更耗费服务器资源。</li></ul><h2 id="★四、HTTP的状态码"><a href="#★四、HTTP的状态码" class="headerlink" title="★四、HTTP的状态码"></a>★四、HTTP的状态码</h2><p>1xx：提示信息，是协议处理的中间状态，还需要后续的操作</p><p>2xx：表示服务器成功处理了客户端的请求，报文已经收到并被正确处理</p><p>3xx：重定向，表示客户端请求的资源发生了变动，需要客户端用新的url重亲发送请求获取资源</p><p>4xx：表示客户端发送的报文有误</p><p>5xx：表示客户端请求报文正确，但是服务器处理时内部发生了错误</p><h3 id="1xx：提示信息，是协议处理的中间状态，还需要后续的操作"><a href="#1xx：提示信息，是协议处理的中间状态，还需要后续的操作" class="headerlink" title="1xx：提示信息，是协议处理的中间状态，还需要后续的操作"></a>1xx：提示信息，是协议处理的中间状态，还需要后续的操作</h3><ul><li>100 Continue：继续，客户端应继续其请求。</li><li>101 Switching Protocols：服务器根据客户端请求切换协议，只能切换到更高级的协议，例如切换到HTTP新版本的协议。</li></ul><h3 id="2xx：表示服务器成功处理了客户端的请求，报文已经收到并被正确处理"><a href="#2xx：表示服务器成功处理了客户端的请求，报文已经收到并被正确处理" class="headerlink" title="2xx：表示服务器成功处理了客户端的请求，报文已经收到并被正确处理"></a>2xx：表示服务器成功处理了客户端的请求，报文已经收到并被正确处理</h3><ul><li>200 OK：成功状态码，表示一切正常。非HEAD请求时服务器返回的响应头会有body数据。</li><li>201 Created：已创建，成功请求并创建了新的资源。</li><li>202 Accepted：已接收，已经接收请求，但未处理完成。</li><li>203 Non-Authoritative Information：非授权信息，请求成功但返回的meta信息不在原始的服务器，而是一个副本。</li><li>204 No Content：成功状态码，响应头没有body数据。</li><li>205 Reset Content：请求成功，但响应报文不含实体的主体部分，但与204不同的是要求请求方重置内容。</li><li>206 Partial Content：应用于HTTP分块下载或断点续传，表示响应返回的body数据并不是资源的全部，只是其中一部分。</li></ul><h3 id="3xx：重定向，表示客户端请求的资源发生了变动，需要客户端用新的url重亲发送请求获取资源"><a href="#3xx：重定向，表示客户端请求的资源发生了变动，需要客户端用新的url重亲发送请求获取资源" class="headerlink" title="3xx：重定向，表示客户端请求的资源发生了变动，需要客户端用新的url重亲发送请求获取资源"></a>3xx：重定向，表示客户端请求的资源发生了变动，需要客户端用新的url重亲发送请求获取资源</h3><ul><li>301 Moved Permanently：永久重定向，说明请求资源已经不存在了，需改用新的URL再次访问。</li><li>302 Found：临时重定向，说明请求的资源还在，但暂时需要用另一个URL访问。</li><li>303 see other：表示资源存在另一个url，应使用GET方法获取资源。</li><li>304 Not Modified：未修改，自从上次请求后，请求的网页未修改过。</li><li>305 Use Proxy：使用代理，请求者只能使用代理访问请求的网页。</li><li>306 Unused：已经被废弃的HTTP状态码。</li><li>307 Temporary Redirect：临时重定向，类似302，但是期望客户端保持请求方法不变向新地址发出请求。</li></ul><h3 id="4xx：表示客户端发送的报文有误"><a href="#4xx：表示客户端发送的报文有误" class="headerlink" title="4xx：表示客户端发送的报文有误"></a>4xx：表示客户端发送的报文有误</h3><ul><li>400 Bad Request：表示客户端请求的报文有误。</li><li>401 Unauthorized：表示发送的请求需要有通过HTTP认证的认证信息。</li><li>402 Payment Required：保留，将来使用。</li><li>403 Forbidden：表示服务器禁止访问资源。</li><li>404 Not Found：表示请求的资源在服务器上不存在或未找到。</li><li>405 Method Not Allowed：客户端请求中的方法被禁止。</li><li>406 Not Acceptable：服务器无法根据客户端请求的内容特性完成请求。</li><li>407: Proxy Authentication Required：请求要求代理的身份认证，类似401，但请求者应当使用代理进行授权。</li><li>408 Request Time-out：服务器等待客户端发送的请求时间过长，超时。</li><li>409 Confilct：服务器完成客户端的PUT请求时可能返回此代码，服务器处理请求时发生了冲突。</li><li>410 Gone：客户端请求的资源已经不存在。资源以前有现在被永久删除了。</li><li>411 Length Required：服务器无法处理客户端发送的不带Content-Length的请求信息。</li><li>412 Precondition Failed：客户端请求信息的先决条件错误。</li><li>413 Request Entity Too Large：由于请求实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息。</li><li>414 Request-URI Too Large：请求的URI过长，服务器无法处理。</li><li>415 Unsupported Media Type：服务器无法处理请求附带的媒体格式。</li><li>416 Requested Range Not Satisfiable：客户端请求的范围无效。</li><li>417 Expectation Failed：服务器无法满足Expect的请求头消息。</li></ul><h3 id="5xx：表示客户端请求报文正确，但是服务器处理时内部发生了错误"><a href="#5xx：表示客户端请求报文正确，但是服务器处理时内部发生了错误" class="headerlink" title="5xx：表示客户端请求报文正确，但是服务器处理时内部发生了错误"></a>5xx：表示客户端请求报文正确，但是服务器处理时内部发生了错误</h3><ul><li>500 Internal Server Error：服务器发生错误。</li><li>501 Not Implemented：表示客户端请求的功能还不支持。</li><li>502 Bad Gateway：通常是在服务器作为网关或代理时，服务器自身工作正常，访问后端服务器发生错误。</li><li>503 Service Unavailable：表示服务器当前忙，暂时无法相应服务器。</li><li>504 Gateway Time-out：充当网关或代理的服务器未及时从远端服务器获取请求。</li><li>505 HTTP Version not supported：服务器不支持请求的HTTP协议的版本，无法完成处理。</li></ul><h2 id="五、HTTP原理和优缺点"><a href="#五、HTTP原理和优缺点" class="headerlink" title="五、HTTP原理和优缺点"></a>五、HTTP原理和优缺点</h2><h3 id="5-1-HTTP原理"><a href="#5-1-HTTP原理" class="headerlink" title="5.1 HTTP原理"></a>5.1 HTTP原理</h3><p>1、客户端浏览器首先通过网络与服务器建立连接，该连接通过TCP完成，端口号一般为80。建立连接环后客户端发送一个请求给服务器，请求方式的格式为：URL、协议版本号、MIME信息（包括请求修饰符、客户机信息和许可内容）。<br>2、服务器接收到请求后，返回对应的相应信息，格式为状态行（协议版本号、状态码）、MIME信息（服务器信息和可能的内容）</p><h3 id="5-2-HTTP的优点和缺点"><a href="#5-2-HTTP的优点和缺点" class="headerlink" title="5.2 HTTP的优点和缺点"></a>5.2 HTTP的优点和缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>支持客户端&#x2F;服务器模式</li><li><strong>简单快捷</strong>：客户端向服务器请求服务时，只需传送请求方法和路径。由于HTTP协议简单，使得HTTP服务器程序规模小，因此通信速度很快。</li><li><strong>无连接</strong>：限制每次连接只处理一个请求，服务器处理完客户的请求，并收到客户的应答后，即断开连接，采用这种方式可以节省传输时间。</li><li><strong>无状态</strong>：状态是指通信过程的上下文信息。缺少状态意味着如果后续处理需要前面的信息，它必须重传，这样可能会导致每次连接传送的数据量增大。但服务器不需要前面信息时它应答的就比较快。</li><li><strong>灵活</strong>：HTTP允许传输任意类型的数据对象，正在传输的类型由 Content-Type 加以标记。<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4></li><li><strong>无状态</strong>：HTTP是无状态的协议，HTTP服务器不会保存关于客户的任何消息。</li><li><strong>明文传输</strong>：协议中的报文使用的是文本形式，直接暴露给外界。</li><li><strong>不安全</strong>：通信使用明文，内容可能会被窃听；不验证通信方的身份，因此可能遭遇伪装；无法证明报文完整性，报文可能被篡改。</li></ul><h2 id="六、不同版本的HTTP"><a href="#六、不同版本的HTTP" class="headerlink" title="六、不同版本的HTTP"></a>六、不同版本的HTTP</h2><h3 id="6-1-HTTP-1-0和HTTP-1-1-区别"><a href="#6-1-HTTP-1-0和HTTP-1-1-区别" class="headerlink" title="6.1 HTTP 1.0和HTTP 1.1 区别"></a>6.1 HTTP 1.0和HTTP 1.1 区别</h3><ul><li><strong>连接</strong>：HTTP 1.0使用非持久连接，每次发送数据都会经过TCP的三次握手和四次挥手，效率较低。HTTP 1.1使用持久连接，一次建立可以传输多次数据，避免使用持久连接时每次需要建立连接的时延。</li><li><strong>资源请求方面</strong>：HTTP 1.0 不支持断点续传，每次都会传送全部的页面和数据；HTTP 1.1支持断点续传，在请求头引入了range，方便开发者自由选择以便充分利用带宽和连接。</li><li><strong>缓存方面</strong>：HTTP 1.0中只使用了header里的If-Modifed-Since和Expries作为缓存失效的标准；HTTP 1.1中增加了更多的缓存控制策略，例如E-tag、If-Unmodified-Since、If-Match、If-None-Match等缓存头来控制缓存策略。</li><li><strong>身份验证</strong>：HTTP 1.0仅仅提供了最基本的认证，这时候用户名和密码还未加密，很容易被窥探；HTTP 1.1使用摘要算法来进行身份验证。 </li><li><strong>IP地址</strong>：HTTP 1.0认为每台计算机都绑定唯一的一个IP，所以请求消息中的URL并没有传递主机名；HTTP 1.1使用了虚拟网络，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个IP地址，增加了host字段，可以将请求发往同一台服务器的不同网站。</li><li><strong>请求方法</strong>：HTTP 1.1比HTTP 1.0新增了很多请求方法，如PUT、HEAD、OPTIONS。<h3 id="6-2-HTTP-2-0与HTTP-1-1"><a href="#6-2-HTTP-2-0与HTTP-1-1" class="headerlink" title="6.2 HTTP 2.0与HTTP 1.1"></a>6.2 HTTP 2.0与HTTP 1.1</h3></li><li><strong>头部压缩</strong>：HTTP 1.1协议不带状态，每次请求必须附上所有信息，浪费带宽，影响速度。HTTP 2.0使用了HPACK算法进行了压缩，同时客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不用发送同样字段只用发索引号。</li><li><strong>多路复用</strong>：HTTP 2.0中每一个请求都是用作连接共享，一个请求对应一个id，一个连接上可以有多个请求，一个连接里客户端和服务器都可以同时发送多个请求或回应，避免了队头堵塞问题。</li><li><strong>二进制协议</strong>：在HTTP 1.1中报文的头信息必须是ASCII码，数据体可以是文本，也可以是二进制。HTTP 2.0中头信息和数据体都是二进制，提升了解析效率。</li><li><strong>数据流</strong>：HTTP 2.0使用了数据流，因为HTTP 2.0的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的请求。HTTP2.0将每个请求或回应的所有数据包称为一个数据流，每个数据流都有唯一的编号，数据包发送时必须标记数据流ID来区分数据哪个数据流。</li><li><strong>服务器推送</strong>：HTTP2.0允许服务器未经请求，主动向客户端发送资源。使用服务器推送提前给客户端推送必要的资源，减少延迟时间。这里推送的是静态资源。</li></ul><h3 id="6-3-HTTP-3-0"><a href="#6-3-HTTP-3-0" class="headerlink" title="6.3 HTTP 3.0"></a>6.3 HTTP 3.0</h3><p>HTTP3.0基于UDP协议实现了类似于TCP的多路复用数据流、传输可靠性等功能，使用了QUIC协议。</p><ul><li><strong>多路复用</strong>：TCP协议没有多路复用功能，QUIC实现了这个功能，并且传输单个数据流可以保证有序交付且不会影响其它的数据流，解决了TCP存在的问题。</li><li><strong>0~1RTT</strong>：使用类似TCP快速打开的技术，缓存当前会话的上下文，下次恢复会话时只需将之前缓存传递给服务器端验证通过就可以进行传输了。使用TLS1.3减少握手花费的RTT数。</li><li><strong>流量控制、传输可靠性功能</strong>：QUIC在UDP的基础上增加了一层来保证数据传输的可靠性，它提供了数据包重传、拥塞控制等TCP中的特性。</li></ul><h2 id="七、即时通讯中短轮询、长轮询、SSE和websocket的区别"><a href="#七、即时通讯中短轮询、长轮询、SSE和websocket的区别" class="headerlink" title="七、即时通讯中短轮询、长轮询、SSE和websocket的区别"></a>七、即时通讯中短轮询、长轮询、SSE和websocket的区别</h2><ul><li><strong>短轮询</strong>：浏览器每隔一段时间向服务器发送http请求，服务器收到请求后，不论是否有数据更新，都直接进行响应。这种方式实现的即时通信，本质上还是浏览器发送请求，服务器接受请求的一个过程，通过让客户端不断的进行请求，使得客户端能够模拟实时地收到服务器端的数据的变化。这种方式的优点是比较简单，易于理解。缺点是这种方式由于需要不断的建立 http 连接，严重浪费了服务器端和客户端的资源。当用户增加时，服务器端的压力就会变大。</li><li><strong>长轮询</strong>：首先由客户端向服务器发起请求，当服务器收到客户端发来的请求后，服务器端不会直接进行响应，而是先将这个请求挂起，然后判断服务器端数据是否有更新。如果有更新，则进行响应，如果一直没有数据，则到达一定的时间限制才返回。客户端 JavaScript 响应处理函数会在处理完服务器返回的信息后，再次发出请求，重新建立连接。长轮询和短轮询比起来，它的优点是明显减少了很多不必要的 http 请求次数，相比之下节约了资源。长轮询的缺点在于，连接挂起也会导致资源的浪费。</li><li><strong>SSE</strong>：服务器使用流信息向服务器推送信息。严格地说，http 协议无法做到服务器主动推送信息。办法是服务器向客户端声明，接下来要发送的是流信息。发送的不是一次性的数据包，而是一个数据流，会连续不断地发送过来。这时，客户端不会关闭连接，会一直等着服务器发过来的新的数据流，视频播放就是这样的例子。SSE 就是利用这种机制，使用流信息向浏览器推送信息。它基于 http 协议，目前除了 IE&#x2F;Edge，其他浏览器都支持。它相对于前面两种方式来说，不需要建立过多的 http 请求，相比之下节约了资源。</li><li><strong>websocket</strong>：HTTP5新定义的协议，允许服务器主动向客户端推送信息，缺点是服务器端的配置比较复杂。websocket是一个全双工的协议，通信双方是平等的，可以互相发送消息，SSE是单向的，只能从服务器向客户端推送信息，客户端需要发送信息就属于下一个HTTP请求了。</li><li>短轮询、长轮询、SSE是基于HTTP协议，性能上来看后比前好，兼容性前比后好。</li></ul><h2 id="八、常见请求头和响应头"><a href="#八、常见请求头和响应头" class="headerlink" title="八、常见请求头和响应头"></a>八、常见请求头和响应头</h2><p>请求和响应的首部分为请求首部和响应首部，部分首部两者通用。</p><h3 id="8-1-通用首部"><a href="#8-1-通用首部" class="headerlink" title="8.1 通用首部"></a>8.1 通用首部</h3><table><thead><tr><th>通用字段</th><th>作用</th></tr></thead><tbody><tr><td>Cache-Control</td><td>控制缓存的行为。Cache-Control 是一个通用标头，他可以出现在请求标头和响应标头中，Cache-Control 的种类比较多，虽然说这是一个通用标头，但是又一些特性是请求标头具有的，有一些是响应标头才有的。主要大类有 可缓存性、阈值性、 重新验证并重新加载 和其他特性</td></tr><tr><td>Connection</td><td>浏览器想要优先使用的连接类型，比如 keep-alive。  Connection 决定当前事务（一次三次握手和四次挥手）完成后，是否会关闭网络连接。Connection 有两种，一种是持久性连接，即一次事务完成后不关闭网络连接  Connection: keep-alive   另一种是非持久性连接，即一次事务完成后关闭网络连接  Connection: close</td></tr><tr><td>Date</td><td>创建报文时间。表示的是格林威治标准时间，这个时间要比北京时间慢八个小时</td></tr><tr><td>Pragma</td><td>报文指令</td></tr><tr><td>Via</td><td>代理服务器相关信息</td></tr><tr><td>Transfer-Encoding</td><td>传输编码方式</td></tr><tr><td>Upgrade</td><td>要求客户端升级协议</td></tr><tr><td>Warning</td><td>在内容中可能存在错误</td></tr></tbody></table><h3 id="8-2-请求首部"><a href="#8-2-请求首部" class="headerlink" title="8.2 请求首部"></a>8.2 请求首部</h3><ul><li>Accept:浏览器能够处理的内容类型</li><li>Accept-Charset:浏览器能够显示的字符集</li><li>Accept-Encoding：浏览器能够处理的压缩编码</li><li>Accept-Language：浏览器当前设置的语言</li><li>Connection：浏览器与服务器之间连接的类型</li><li>Cookie：当前页面设置的任何Cookie</li><li>Host：发出请求的页面所在的域</li><li>Referer：发出请求的页面的URL</li><li>User-Agent：浏览器的用户代理字符串<h3 id="8-3-响应首部"><a href="#8-3-响应首部" class="headerlink" title="8.3 响应首部"></a>8.3 响应首部</h3></li><li>Date：表示消息发送的时间，时间的描述格式由rfc822定义</li><li>server:服务器名称</li><li>Connection：浏览器与服务器之间连接的类型</li><li>Cache-Control：控制HTTP缓存</li><li>content-type:表示后面的文档属于什么MIME类型<br>常见的 Content-Type 属性值有以下四种：<br>（1）application&#x2F;x-www-form-urlencoded：浏览器的原生 form 表单，如果不设置 enctype 属性，那么最终就会以 application&#x2F;x-www-form-urlencoded 方式提交数据。该种方式提交的数据放在 body 里面，数据按照 key1&#x3D;val1&amp;key2&#x3D;val2 的方式进行编码，key 和 val 都进行了 URL转码。<br>（2）multipart&#x2F;form-data：该种方式也是一个常见的 POST 提交方式，通常表单上传文件时使用该种方式。<br>（3）application&#x2F;json：服务器消息主体是序列化后的 JSON 字符串。<br>（4）text&#x2F;xml：该种方式主要用来提交 XML 格式的数据。<h3 id="8-4-实体首部"><a href="#8-4-实体首部" class="headerlink" title="8.4 实体首部"></a>8.4 实体首部</h3><table><thead><tr><th>实体首部</th><th>作用</th></tr></thead><tbody><tr><td>Allow</td><td>资源的正确请求方式</td></tr><tr><td>Content-Encoding</td><td>内容的编码格式。  这个实体报头用来压缩媒体类型。Content-Encoding 指示对实体应用了何种编码。  常见的内容编码有这几种： gzip、compress、deflate、identity ，这个属性可以应用在请求报文和响应报文中</td></tr><tr><td>Content-Language</td><td>内容使用的语言</td></tr><tr><td>Content-Length</td><td>request body 长度</td></tr><tr><td>Content-Location</td><td>返回数据的备用地址</td></tr><tr><td>Content-MD5</td><td>Base64加密格式的内容 MD5检验值</td></tr><tr><td>Content-Range</td><td>内容的位置范围</td></tr><tr><td>Content-Type</td><td>内容的媒体类型</td></tr><tr><td>Expires</td><td>内容的过期时间</td></tr><tr><td>Last_modified</td><td>内容的最后修改时间</td></tr></tbody></table></li></ul><h2 id="九、HTTP协议的性能"><a href="#九、HTTP协议的性能" class="headerlink" title="九、HTTP协议的性能"></a>九、HTTP协议的性能</h2><p>HTTP基于TCP&#x2F;IP，并且使用了请求-应答的通信模式。</p><ul><li><strong>持久连接</strong>：HTTP有两种连接模式，持久和非持久连接。非持久连接是指服务器必须为每一个请求的对象建立和维护一个全新的链接。持久连接默认不关闭，可以被多个请求复用。采用持久连接可以避免每次建立TCP三次握手所花费的时间。<br>在HTTP 1.0时采用非持久连接，HTTP 1.1采用持久连接。</li><li><strong>管道网络传输</strong>：HTTP 1.1采用了长链接的方式，这使得管道网络传输成为可能。管道（pipeline）网络传输是指：可以在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。但是服务器还是按照顺序回应请求。如果前面的回应特别慢，后面就会有许多请求排队等着。这称为队头堵塞。</li><li><strong>队头堵塞</strong>：HTTP 传输的报文必须是一发一收，但是，里面的任务被放在一个任务队列中串行执行，一旦队首的请求处理太慢，就会阻塞后面请求的处理。这就是HTTP队头阻塞问题。<br><strong>队头阻塞的解决方案：</strong> （1）并发连接：对于一个域名允许分配多个长连接，那么相当于增加了任务队列，不至于一个队伍的任务阻塞其它所有任务。 （2）域名分片：将域名分出很多二级域名，它们都指向同样的一台服务器，能够并发的长连接数变多，解决了队头阻塞的问题。</li></ul><h2 id="十、GET请求和POST请求区别"><a href="#十、GET请求和POST请求区别" class="headerlink" title="十、GET请求和POST请求区别"></a>十、GET请求和POST请求区别</h2><ul><li><strong>提交</strong>：GET提交请求的数据会放在URL之后，以？分割URL和传输数据，多个参数用&amp;连接，如login.action?name&#x3D;hybdd&amp;password&#x3D;input。如果数据是英文字母&#x2F;数字，原样发送，如果是空格，转换为+，如果是<strong>中文&#x2F;其他字符，则直接把字符串用BASE64加密</strong>，得出如： %E4%BD%A0%E5%A5 %BD ，其中％XX中的XX为该符号以16进制表示的ASCII。<br>POST请求把提交的数据放置在HTTP报文实体部分，GET提交的数据会在地址栏显示出来，POST提交地址栏不会改变。</li><li><strong>传输数据大小</strong>：特定浏览器和服务器对URL长度有限制，GET请求发送数据的长度有限制。POST理论上数据长度不受限制。</li><li><strong>安全性</strong>：GET请求将请求参数放在url中，且请求的url会保留在历史记录中，不安全。</li><li><strong>参数类型</strong>：post 的参数传递支持更多的数据类型。</li><li><strong>发送的报文格式：</strong> Get 请求的报文中实体部分为空，Post 请求的报文中实体部分一般为向服务器发送的数据。</li><li><strong>应用场景：</strong> GET 请求是一个幂等的请求，一般 Get 请求用于对服务器资源不会产生影响的场景，比如说请求一个网页的资源。而 Post 不是一个幂等的请求，一般用于对服务器资源会产生影响的情景，比如注册用户这一类的操作。</li><li><strong>是否缓存：</strong> 因为两者应用场景不同，浏览器一般会对 Get 请求缓存，但很少对 Post 请求缓存。</li></ul><h2 id="十一、无状态协议HTTP"><a href="#十一、无状态协议HTTP" class="headerlink" title="十一、无状态协议HTTP"></a>十一、无状态协议HTTP</h2><p>无状态协议就是指浏览器对于事务的处理没有记忆能力。比如客户请求获得网页之后关闭浏览器，然后再次启动浏览器，登录该网站，但是服务器并不知道客户关闭了一次浏览器。<br><strong>HTTP 就是一种无状态的协议</strong>，他对用户的操作没有记忆能力。每次输入用户名和密码登陆一个网站后，下次登陆就不再重新输入用户名和密码了。这其实是一个叫做 小甜饼(Cookie) 的机制。它能够让浏览器具有记忆能力。<br>当向服务端发送请求时，服务端会给你发送一个认证信息，服务器第一次接收到请求时，开辟了一块 Session 空间（创建了Session对象），同时生成一个 sessionId ，并通过响应头的 <strong>Set-Cookie：JSESSIONID&#x3D;XXXXXXX</strong>命令，向客户端发送要求设置 Cookie 的响应； 客户端收到响应后，在本机客户端设置了一个 <strong>JSESSIONID&#x3D;XXXXXXX</strong>的 Cookie 信息，该 Cookie 的过期时间为浏览器会话结束；接下来客户端每次向同一个网站发送请求时，请求头都会带上该 Cookie信息（包含 sessionId ）， 然后，服务器通过读取请求头中的 Cookie 信息，获取名称为 JSESSIONID 的值，得到此次请求的 sessionId。这样，你的浏览器才具有了记忆能力。<br>还有一种方式是使用 JWT 机制，它也是能够让你的浏览器具有记忆能力的一种机制。与 Cookie 不同，JWT 是保存在客户端的信息，它广泛的应用于单点登录的情况。JWT 具有两个特点：<br>JWT 的 Cookie 信息存储在客户端，而不是服务端内存中。也就是说，JWT 直接本地进行验证就可以，验证完毕后，这个 Token 就会在 Session 中随请求一起发送到服务器，通过这种方式，可以节省服务器资源，并且 token 可以进行多次验证。<br>JWT 支持跨域认证，Cookies 只能用在单个节点的域或者它的子域中有效。如果它们尝试通过第三个节点访问，就会被禁止。使用 JWT 可以解决这个问题，使用 JWT 能够通过多个节点进行用户认证，也就是我们常说的跨域认证。</p><h2 id="十二、URL组成部分"><a href="#十二、URL组成部分" class="headerlink" title="十二、URL组成部分"></a>十二、URL组成部分</h2><p>如：<a href="http://www.aspxfans.com:8080/news/index.asp?boardID=5">http://www.aspxfans.com:8080/news/index.asp?boardID=5</a></p><ul><li><strong>协议部分</strong>：该URL的协议部分为“http：”，这代表网页使用的是HTTP协议。在Internet中可以使用多种协议，如HTTP，FTP等等本例中使用的是HTTP协议。在”HTTP”后面的“&#x2F;&#x2F;”为分隔符；</li><li><strong>域名部分</strong>：该URL的域名部分为“<a href="http://www.aspxfans.com”.一个url中,也可以使用ip地址作为域名使用./">www.aspxfans.com”。一个URL中，也可以使用IP地址作为域名使用。</a></li><li><strong>端口部分</strong>：跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口（HTTP协议默认端口是80，HTTPS协议默认端口是443）；</li><li><strong>虚拟目录部分</strong>：从域名后的第一个“&#x2F;”开始到最后一个“&#x2F;”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“&#x2F;news&#x2F;”；</li><li><strong>文件名部分</strong>：从域名后的最后一个“&#x2F;”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“&#x2F;”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“&#x2F;”开始到结束，都是文件名部分。本例中的文件名是“index.asp”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名；</li><li><strong>锚部分</strong>：从“#”开始到最后，都是锚部分。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分；</li><li><strong>参数部分</strong>：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。本例中的参数部分为“boardID&#x3D;5&amp;ID&#x3D;24618&amp;page&#x3D;1”。参数可以允许有多个参数，参数与参数之间用“&amp;”作为分隔符。</li></ul><h2 id="★十三、输入URL发生什么"><a href="#★十三、输入URL发生什么" class="headerlink" title="★十三、输入URL发生什么"></a>★十三、输入URL发生什么</h2><ol><li><strong>解析URL</strong>：首先对URL进行解析，分析所需要使用的传输协议和请求资源的路径。如果输入的URL协议或主机名不合法，将会把地址栏中输入的内容传递给搜索引擎。如果没有问题，浏览器会检查URL中是否出现非法字符，若存在则对非法字符进行转义。</li><li><strong>缓存判断</strong>：浏览器判断所请求的资源是否在缓存里，如果在缓存里且没有失效就会直接使用，否则向服务器发起新的请求。</li><li><strong>DNS解析</strong>：首先判断本地是否有该域名的IP地址的缓存，如果有则使用，没有就向本地DNS服务器发起请求。本地DNS服务器先检查是否存在缓存，如果没有先向根域名服务器发起请求，获得负责的顶级域名服务器的地址后，再向顶级域名服务器请求，然后获得负责权威域名服务器的地址后，再向权威域名服务器发起请求，最终获得域名的IP地址后，本地DNS服务器再将这个IP地址返回给请求的用户。用户向本地 DNS 服务器发起请求属于递归请求，本地 DNS 服务器向各级域名服务器发起请求属于迭代请求。</li><li><strong>获取MAC地址</strong>：当浏览器得到 IP 地址后，数据传输还需要知道目的主机 MAC 地址，因为应用层下发数据给传输层，TCP 协议会指定源端口号和目的端口号，然后下发给网络层。网络层会将本机地址作为源地址，获取的 IP 地址作为目的地址。然后将下发给数据链路层，数据链路层的发送需要加入通信双方的 MAC 地址，本机的 MAC 地址作为源 MAC 地址，目的 MAC 地址需要分情况处理。</li><li><strong>TCP三次握手</strong>：客户端发送SYN包（SYN &#x3D; 1, seq &#x3D; x）至服务端，并处于SYN_SENT状态，等待服务器确认。服务端解析SYN，并发送SYN + ACK（SYN &#x3D; 1, ACK &#x3D; x + 1, seq &#x3D; y） 包至客户端，并处于SYN_RECV状态，允许建立链接）。客户端获取SYN + ACK 并发送ACK（ACK &#x3D; y + 1， seq &#x3D; z）包至服务端，链接建立成功。</li><li><strong>HTTPS握手</strong>：如果使用的是 HTTPS 协议，在通信前还存在 TLS 的一个四次握手的过程。首先由客户端向服务器端发送使用的协议的版本号、一个随机数和可以使用的加密方法。服务器端收到后，确认加密的方法，也向客户端发送一个随机数和自己的数字证书。客户端收到后，首先检查数字证书是否有效，如果有效，则再生成一个随机数，并使用证书中的公钥对随机数加密，然后发送给服务器端，并且还会提供一个前面所有内容的 hash 值供服务器端检验。服务器端接收后，使用自己的私钥对数据解密，同时向客户端发送一个前面所有内容的 hash 值供客户端检验。这个时候双方都有了三个随机数，按照之前所约定的加密方法，使用这三个随机数生成一把秘钥，以后双方通信前，就使用这个秘钥对数据进行加密后再传输。</li><li><strong>返回数据</strong>：页面请求发送到服务器端后，服务器端会返回一个html文件作为响应，浏览器接收到响应后，开始对html文件进行解析，开始页面的渲染过程。</li><li><strong>页面渲染</strong>：浏览器首先解析HTML，构建DOM树（深度优先），根据解析的CSS文件生成CSS规则树，如果遇到script标签，判断是否有defer或async属性，否则暂停执行。合并DOM树和CSS规则，生成render渲染树。渲染树构建好后，会根据渲染树进行布局，包括回流、重排，负责各元素尺寸、位置计算。布局完成后，绘制渲染树，绘制页面像素信息，最后显示到屏幕上。</li><li><strong>TCP四次挥手</strong>：若客户端认为数据发送完成，则需要向服务端发送连接释放请求。经过四次挥手过程，连接断开。</li></ol><h2 id="十四、页面有多张图片，HTTP怎样加载"><a href="#十四、页面有多张图片，HTTP怎样加载" class="headerlink" title="十四、页面有多张图片，HTTP怎样加载"></a>十四、页面有多张图片，HTTP怎样加载</h2><ul><li>在HTTP 1中，浏览器对一个域名下最大TCP连接数为6，会请求多次，可以用多域名部署解决，这样可以提高同时请求的数目，加快页面的获取速度。</li><li>在HTTP 2中，可以一瞬间加载很多资源，因为HTTP 2支持多路复用，可以在一个TCP连接中发送多个HTTP请求。<h2 id="十五、keep-alive"><a href="#十五、keep-alive" class="headerlink" title="十五、keep-alive"></a>十五、keep-alive</h2>短连接：每次请求&#x2F;应答时客户端和服务端都要新建一个连接，完成后立即断开。<br>长连接：客户端与服务端的连接持久有效，当出现对服务器的后继请求时，keep-alive功能避免了建立或重新建立连接。</li><li>HTTP1.0版本是默认没有Keep-alive的（也就是默认会发送keep-alive），所以要想连接得到保持，必须手动配置发送<code>Connection: keep-alive</code>字段。若想断开keep-alive连接，需发送<code>Connection:close</code>字段；</li><li>HTTP1.1规定了默认保持长连接，数据传输完成了保持TCP连接不断开，等待在同域名下继续用这个通道传输数据。如果需要关闭，需要客户端发送<code>Connection：close</code>首部字段。<br><strong>keep-alive的建立过程</strong>：</li><li>客户端向服务器在发送请求报文同时在首部添加发送Connection字段</li><li>服务器收到请求并处理 Connection字段</li><li>服务器回送Connection:Keep-Alive字段给客户端</li><li>客户端接收到Connection字段</li><li>Keep-Alive连接建立成功<br><strong>服务器自动断开过程（没有keep-alive）</strong>：</li><li>客户端向服务器只是发送内容报文（不包含Connection字段）</li><li>服务器收到请求并处理</li><li>服务器返回客户端请求的资源并关闭连接</li><li>客户端接收资源，发现没有Connection字段，断开连接<br><strong>客户端请求断开连接过程</strong>：</li><li>客户端向服务器发送Connection:close字段</li><li>服务器收到请求并处理connection字段</li><li>服务器回送响应资源并断开连接</li><li>客户端接收资源并断开连接<br><strong>优点</strong>：</li><li>较少的CPU和内存的使⽤（由于同时打开的连接的减少了）；</li><li>允许请求和应答的HTTP管线化；</li><li>降低拥塞控制 （TCP连接减少了）；</li><li>减少了后续请求的延迟（⽆需再进⾏握⼿）；</li><li>报告错误⽆需关闭TCP连；<br><strong>缺点</strong>：长时间的TCP连接容易导致系统资源无效占用，浪费系统资源。</li></ul><h2 id="十六、SSL-TLS"><a href="#十六、SSL-TLS" class="headerlink" title="十六、SSL+TLS"></a>十六、SSL+TLS</h2><p><strong>TLS&#x2F;SSL</strong>全称安全传输层协议，是介于TCP和HTTP之间的一层安全协议，不影响原有的TCP协议和HTTP协议。<br>SSL即安全套接字层，它在OSI七层网络模型中处于第五层，TLS是SSL的后续版本。<br>TLS&#x2F;SSL的功能实现主要依赖三类基本算法：散列函数hash、对称加密、非对称加密，作用是：</p><ul><li>基于散列函数验证信息的完整性</li><li>对称加密算法采用协商的秘钥对数据加密</li><li>非对称加密实现身份认证和秘钥协商<h3 id="16-1-散列函数hash"><a href="#16-1-散列函数hash" class="headerlink" title="16.1 散列函数hash"></a>16.1 散列函数hash</h3>常见的散列函数有MD5、SHA1、SHA256。该函数的特点是单向不可逆，对输入数据非常敏感，输出的长度固定，任何数据的修改都会改变散列函数的结果，可以用于防止信息篡改并验证数据的完整性。<br><strong>特点：</strong> 在信息传输过程中，散列函数不能三都实现信息防篡改，由于传输是明文传输，中间人可以修改信息后重新计算信息的摘要，所以需要对传输的信息和信息摘要进行加密。<h3 id="16-2-对称加密"><a href="#16-2-对称加密" class="headerlink" title="16.2 对称加密"></a>16.2 对称加密</h3>双方使用同一个密钥对数据进行加密和解密，常见的对称加密算法有AES-CBC、DES、3DES、AES-GCM等。相同的秘钥可以用于信息的加密和解密。掌握秘钥才能获取信息，防止信息窃听，其通讯方式是一对一。<br>加密方必须对原始数据进行加密，然后再把密钥交给解密方解密，然后才能解密数据，但是密钥传送过程可能被暴露，存在风险。<h3 id="16-3-非对称加密"><a href="#16-3-非对称加密" class="headerlink" title="16.3 非对称加密"></a>16.3 非对称加密</h3>有两个密钥，一个是公钥，一个是私钥。公钥是公开的，私钥是保密的。用私钥加密的数据只有用对应的公钥才能解开。公钥可以公布，使用公钥加密的文本只能使用私钥解密，同时，使用私钥加密的文本也可以使用公钥解密。因此掌握公钥的不同客户端之间不能相互解密信息，只能和服务器进行加密通信，服务器可以实现一对多的的通信，客户端也可以用来验证掌握私钥的服务器的身份。<br><strong>特点：</strong> 非对称加密的特点就是信息一对多，服务器只需要维持一个私钥就可以和多个客户端进行通信，但服务器发出的信息能够被所有的客户端解密，且该算法的计算复杂，加密的速度慢。<h3 id="16-4-混合加密"><a href="#16-4-混合加密" class="headerlink" title="16.4 混合加密"></a>16.4 混合加密</h3>RSA 的运算速度非常慢，而 AES 的加密速度比较快，而 TLS 正是使用了这种混合加密方式。在通信刚开始的时候使用非对称算法，比如 RSA、ECDHE ，首先解决密钥交换的问题。然后用随机数产生对称算法使用的会话密钥（session key），再用公钥加密。对方拿到密文后用私钥解密，取出会话密钥。这样，双方就实现了对称密钥的安全交换。<br>在机密性的基础上还要加上完整性、身份认证的特性，才能实现真正的安全。而实现完整性的主要手段是摘要算法。</li></ul><h2 id="十七、HTTPS做了什么"><a href="#十七、HTTPS做了什么" class="headerlink" title="十七、HTTPS做了什么"></a>十七、HTTPS做了什么</h2><p>HTTPS协议提供了三个关键指标：</p><p><strong>加密</strong>：HTTPS通过对数据进行加密来使其免受窃听者对数据的监听，意味着当用户浏览网站时，没有人能够监听他和网站之间的信息交换，或者跟踪用户的活动、访问记录等，从而窃取用户信息。</p><p><strong>数据一致性</strong>：数据在传输的过程中不会被窃听者所修改，用户方发送的数据会完整的传输到服务端，保证服务器接收的和用户发送的一致。</p><p><strong>身份认证</strong>：确认对方真实身份，防止中间人攻击并建立用户信任。<br>HTTPS在协议名称、默认端口号、语法和语义上与HTTP一样，关键是通过SSL&#x2F;TLS来保证安全性。</p><p><strong>过程</strong>：</p><ol><li><p>客户端向服务区发起请求，请求中包含使用的协议版本号、生成的一个随机数、以及客户端支持的加密算法。</p></li><li><p>服务器接收到请求后，确认双方使用的加密方法、给出服务器的证书、服务器生成的随机数。</p></li><li><p>客户端确认服务器证书有效后，生成一个新的随机数，并使用数字证书中的公钥，加密这个随机数，然后发给服务器，并且会提供一个前面所有内容的hash值，来供服务器检验。</p></li><li><p>服务器使用自己的私钥，来解密客户端发来的随机数，并提供前面所有内容的hash值来供客户端检验。</p></li><li><p>客户端和服务器根据约定的加密方法使用前面的三个随机数，生成对话秘钥，以后对话过程都使用这个秘钥来加密信息。<br>为防止中间人攻击，HTTPS使用认证的方式，证明身份，防止被中间人攻击。</p></li></ol><h2 id="十八、HTTPS的优缺点"><a href="#十八、HTTPS的优缺点" class="headerlink" title="十八、HTTPS的优缺点"></a>十八、HTTPS的优缺点</h2><h5 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h5><ul><li>使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器。</li><li>HTTPS协议是由SSL+HTTP协议构成的可进行加密传输、身份认证的网络协议，比HTTP协议更安全，可防止数据在传输过程中不被窃取、修改，确保数据的完整性。</li><li>HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但大幅增加了中间人的攻击成本。</li></ul><h5 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h5><ul><li>HTTPS协议握手阶段比较费事，会使页面加载时间延长。</li><li>HTTPS连接缓存不如HTTP高效，会增加数据开销，甚至已有的安全措施也会因此而受到影响。</li><li>HTTPS协议的安全是有范围的，在黑客攻击、拒绝服务攻击和服务器劫持等方面几乎起不到什么作用。</li><li>SSL证书通常需要绑定IP，不能在同一个IP上绑定多个域名，IPv4资源不可能支撑这个消耗。</li><li>成本增加。部署HTTPS后，因为HTTPS协议的工作要增加额外的计算资源消耗。例如SSL协议加密算法和SSL交互次数将占用一定的计算资源和服务器成本。</li><li>HTTPS协议的加密范围也比较有限。SSL正式的信用链体系并不安全，中间人攻击一样可行。</li></ul><h2 id="十九、DHCP（动态主机配置协议）"><a href="#十九、DHCP（动态主机配置协议）" class="headerlink" title="十九、DHCP（动态主机配置协议）"></a>十九、DHCP（动态主机配置协议）</h2><img src="/2022/07/06/%E5%BA%94%E7%94%A8%E5%B1%82-HTTP/DHCP.png" class="" title="DHCP"> <ul><li>作用：为网络内的主机提供动态ip地址分配服务，客户登陆服务器时就可以自动获得服务器分配的IP地址和子网掩码。</li><li>先告诉服务器可以分配的ip地址范围 ，  DHCP客户先广播一个请求，发现DHCP服务器。DHCP服务器表示可以提供，客户发送请求表示将其选择，服务器确认并分配地址。</li></ul><h2 id="二十、HTTPS通信过程"><a href="#二十、HTTPS通信过程" class="headerlink" title="二十、HTTPS通信过程"></a>二十、HTTPS通信过程</h2><ol><li>客户端向服务器发起请求，请求中包含使用的协议版本号、生成的一个随机数、以及客户端支持的加密方法。</li><li>服务器端接收到请求后，确认双方使用的加密方法、并给出服务器的证书、以及一个服务器生成的随机数。</li><li>客户端确认服务器证书有效后，生成一个新的随机数，并使用数字证书中的公钥，加密这个随机数，然后发给服务器。并且还会提供一个前面所有内容的 hash 的值，用来供服务器检验。</li><li>服务器使用自己的私钥，来解密客户端发送过来的随机数。并提供前面所有内容的 hash 值来供客户端检验。</li><li>客户端和服务器端根据约定的加密方法使用前面的三个随机数，生成对话秘钥，以后的对话过程都使用这个秘钥来加密信息。<h2 id="二十一、什么是DNS协议"><a href="#二十一、什么是DNS协议" class="headerlink" title="二十一、什么是DNS协议"></a>二十一、什么是DNS协议</h2><strong>概念</strong>： DNS 是域名系统 (Domain Name System) 的缩写，提供的是一种主机名到 IP 地址的转换服务，就是我们常说的域名系统。它是一个由分层的 DNS 服务器组成的分布式数据库，是定义了主机如何查询这个分布式数据库的方式的应用层协议。能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。<br><strong>作用</strong>： 将域名解析为IP地址，客户端向DNS服务器（DNS服务器有自己的IP地址）发送域名查询请求，DNS服务器告知客户机Web服务器的 IP 地址。<h2 id="二十二、DNS同时使用TCP和UDP协议？"><a href="#二十二、DNS同时使用TCP和UDP协议？" class="headerlink" title="二十二、DNS同时使用TCP和UDP协议？"></a>二十二、DNS同时使用TCP和UDP协议？</h2><strong>DNS占用53号端口，同时使用TCP和UDP协议。</strong><br>（1）在区域传输的时候使用TCP协议</li></ol><ul><li>辅域名服务器会定时（一般3小时）向主域名服务器进行查询以便了解数据是否有变动。如有变动，会执行一次区域传送，进行数据同步。区域传送使用TCP而不是UDP，因为数据同步传送的数据量比一个请求应答的数据量要多得多。</li><li>TCP是一种可靠连接，保证了数据的准确性。<br>（2）在域名解析的时候使用UDP协议</li><li>客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。不用经过三次握手，这样DNS服务器负载更低，响应更快。理论上说，客户端也可以指定向DNS服务器查询时用TCP，但事实上，很多DNS服务器进行配置的时候，仅支持UDP查询包。<h2 id="二十三、DNS完整的查询过程"><a href="#二十三、DNS完整的查询过程" class="headerlink" title="二十三、DNS完整的查询过程"></a>二十三、DNS完整的查询过程</h2>DNS服务器解析域名的过程：</li><li>首先会在<strong>浏览器的缓存</strong>中查找对应的IP地址，如果查找到直接返回，若找不到继续下一步</li><li>将请求发送给<strong>本地DNS服务器</strong>，在本地域名服务器缓存中查询，如果查找到，就直接将查找结果返回，若找不到继续下一步</li><li>本地DNS服务器向<strong>根域名服务器</strong>发送请求，根域名服务器会返回一个所查询域的顶级域名服务器地址</li><li>本地DNS服务器向<strong>顶级域名服务器</strong>发送请求，接受请求的服务器查询自己的缓存，如果有记录，就返回查询结果，如果没有就返回相关的下一级的权威域名服务器的地址</li><li>本地DNS服务器向<strong>权威域名服务器</strong>发送请求，域名服务器返回对应的结果</li><li>本地DNS服务器将返回结果保存在缓存中，便于下次使用</li><li>本地DNS服务器将返回结果返回给浏览器<h2 id="二十四、迭代查询和递归查询"><a href="#二十四、迭代查询和递归查询" class="headerlink" title="二十四、迭代查询和递归查询"></a>二十四、迭代查询和递归查询</h2>实际上，DNS解析是一个包含迭代查询和递归查询的过程。</li><li><strong>递归查询</strong>指的是查询请求发出后，域名服务器代为向下一级域名服务器发出请求，最后向用户返回查询的最终结果。使用递归查询，用户只需要发出一次查询请求。</li><li><strong>迭代查询</strong>指的是查询请求后，域名服务器返回单次查询的结果。下一级的查询由用户自己请求。使用迭代查询，用户需要发出 多次的查询请求。<br>一般我们向本地 DNS 服务器发送请求的方式就是递归查询，因为我们只需要发出一次请求，然后本地 DNS 服务器返回给我 们最终的请求结果。而本地 DNS 服务器向其他域名服务器请求的过程是迭代查询的过程，因为每一次域名服务器只返回单次 查询的结果，下一级的查询由本地 DNS 服务器自己进行。<h2 id="二十五、DNS记录和报文"><a href="#二十五、DNS记录和报文" class="headerlink" title="二十五、DNS记录和报文"></a>二十五、DNS记录和报文</h2>DNS 服务器中以资源记录的形式存储信息，每一个 DNS 响应报文一般包含多条资源记录。一条资源记录的具体的格式为<figure class="highlight delphi"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs delphi">（<span class="hljs-keyword">Name</span>，Value，<span class="hljs-keyword">Type</span>，TTL）<br>复制代码<br></code></pre></td></tr></table></figure>其中 TTL 是资源记录的生存时间，它定义了资源记录能够被其他的 DNS 服务器缓存多长时间。<br>常用的一共有四种 Type 的值，分别是 A、NS、CNAME 和 MX ，不同 Type 的值，对应资源记录代表的意义不同：</li><li>如果 Type &#x3D; A，则 Name 是主机名，Value 是主机名对应的 IP 地址。因此一条记录为 A 的资源记录，提供了标 准的主机名到 IP 地址的映射。</li><li>如果 Type &#x3D; NS，则 Name 是个域名，Value 是负责该域名的 DNS 服务器的主机名。这个记录主要用于 DNS 链式 查询时，返回下一级需要查询的 DNS 服务器的信息。</li><li>如果 Type &#x3D; CNAME，则 Name 为别名，Value 为该主机的规范主机名。该条记录用于向查询的主机返回一个主机名 对应的规范主机名，从而告诉查询主机去查询这个主机名的 IP 地址。主机别名主要是为了通过给一些复杂的主机名提供 一个便于记忆的简单的别名。</li><li>如果 Type &#x3D; MX，则 Name 为一个邮件服务器的别名，Value 为邮件服务器的规范主机名。它的作用和 CNAME 是一 样的，都是为了解决规范主机名不利于记忆的缺点。</li></ul><h2 id="二十六、Websocket"><a href="#二十六、Websocket" class="headerlink" title="二十六、Websocket"></a>二十六、Websocket</h2><h3 id="26-1-什么是websocket"><a href="#26-1-什么是websocket" class="headerlink" title="26.1 什么是websocket"></a>26.1 什么是websocket</h3><p>是HTML5提供的一种浏览器与服务器进行全双工通讯的协议。它基于TCP协议，并复用HTTP的握手通道。浏览器和服务器只需要进行一次握手就可以创建持久性的链接，并进行双向数据传输。<br><strong>特点</strong>：</p><ul><li>支持双向通信，实时性更强</li><li>可以发送文本，也可以发送二进制数据</li><li>建立在TCP协议之上，服务端的实现比较容易</li><li>数据格式比较轻量，性能开销小，通信高效</li><li>没有同源限制，客户端可以与任意服务器通信</li><li>协议标识符是ws（如果加密，则为wss），服务器网址就是 URL</li><li>与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。</li></ul><h3 id="26-2-websocket优点"><a href="#26-2-websocket优点" class="headerlink" title="26.2 websocket优点"></a>26.2 websocket优点</h3><ul><li>通过第一次HTTP Request建立了连接之后，后续的数据交换都不用再重新发送HTTP Request，节省了带宽资源；</li><li>WebSocket的连接是双向通信的连接，在同一个TCP连接上，既可以发送，也可以接收;</li><li>具有多路复用的功能，几个不同的URI可以复用同一个WebSocket连接。</li></ul><h3 id="26-3-心跳机制"><a href="#26-3-心跳机制" class="headerlink" title="26.3 心跳机制"></a>26.3 心跳机制</h3><p>心跳机制是每隔一段时间会向服务器发送一个数据包： 告诉服务器（后台）自己还活着，同时客户端（浏览器）会确认服务器端是否还活着。如果还活着的话，就会回传一个数据包给客户端。服务端断开连接了。客户端需要重连。<strong>默认超时时间1分钟</strong></p><h2 id="二十七、即时通讯中短轮询、长轮询、SSE和websocket的区别"><a href="#二十七、即时通讯中短轮询、长轮询、SSE和websocket的区别" class="headerlink" title="二十七、即时通讯中短轮询、长轮询、SSE和websocket的区别"></a>二十七、即时通讯中短轮询、长轮询、SSE和websocket的区别</h2><ul><li><strong>短轮询</strong>：浏览器每隔一段时间向服务器发送http请求，服务器收到请求后，不论是否有数据更新，都直接进行响应。这种方式实现的即时通信，本质上还是浏览器发送请求，服务器接受请求的一个过程，通过让客户端不断的进行请求，使得客户端能够模拟实时地收到服务器端的数据的变化。这种方式的优点是比较简单，易于理解。缺点是这种方式由于需要不断的建立 http 连接，严重浪费了服务器端和客户端的资源。当用户增加时，服务器端的压力就会变大。</li><li><strong>长轮询</strong>：首先由客户端向服务器发起请求，当服务器收到客户端发来的请求后，服务器端不会直接进行响应，而是先将这个请求挂起，然后判断服务器端数据是否有更新。如果有更新，则进行响应，如果一直没有数据，则到达一定的时间限制才返回。客户端 JavaScript 响应处理函数会在处理完服务器返回的信息后，再次发出请求，重新建立连接。长轮询和短轮询比起来，它的优点是明显减少了很多不必要的 http 请求次数，相比之下节约了资源。长轮询的缺点在于，连接挂起也会导致资源的浪费。</li><li><strong>SSE</strong>：服务器使用流信息向服务器推送信息。严格地说，http 协议无法做到服务器主动推送信息。办法是服务器向客户端声明，接下来要发送的是流信息。发送的不是一次性的数据包，而是一个数据流，会连续不断地发送过来。这时，客户端不会关闭连接，会一直等着服务器发过来的新的数据流，视频播放就是这样的例子。SSE 就是利用这种机制，使用流信息向浏览器推送信息。它基于 http 协议，目前除了 IE&#x2F;Edge，其他浏览器都支持。它相对于前面两种方式来说，不需要建立过多的 http 请求，相比之下节约了资源。</li><li><strong>websocket</strong>：HTTP5新定义的协议，允许服务器主动向客户端推送信息，缺点是服务器端的配置比较复杂。websocket是一个全双工的协议，通信双方是平等的，可以互相发送消息，SSE是单向的，只能从服务器向客户端推送信息，客户端需要发送信息就属于下一个HTTP请求了。</li><li>短轮询、长轮询、SSE是基于HTTP协议，性能上来看后比前好，兼容性前比后好。</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>webpack</title>
    <link href="/2022/06/26/webpack/"/>
    <url>/2022/06/26/webpack/</url>
    
    <content type="html"><![CDATA[<h3 id="一、webpack打包流程"><a href="#一、webpack打包流程" class="headerlink" title="一、webpack打包流程"></a>一、webpack打包流程</h3><ol><li>新建项目空白目录（纯英文），并运行npm init -y命令，初始化包管理配置文件package.json，记录安装的包。</li><li>全局安装webpack以及webpack-cli，安装到项目依赖中。<br>-D表示这些包只是开发时使用，上线时不用。<br>-S表示这些包开发时要用到，上线部署的时候也要用到。<figure class="highlight cmake"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> webpack -D<br>npm <span class="hljs-keyword">install</span> webpack-cli -D<br></code></pre></td></tr></table></figure></li><li>在项目根目录中创建webpack.config.js作为webpack的配置文件。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);  <span class="hljs-comment">//导入node.js中专门操作路径的模块。</span><br><span class="hljs-keyword">const</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack&#x27;</span>);<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">HtmlPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;html-webpack-plugin&#x27;</span>);  <span class="hljs-comment">//导入HTML插件</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">WebpackDevServer</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack-dev-server&#x27;</span>);<br><span class="hljs-keyword">const</span> &#123; <span class="hljs-title class_">CleanWebpackPlugin</span> &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;clean-webpack-plugin&#x27;</span>)<br><span class="hljs-keyword">const</span> cleanPlugin = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CleanWebpackPlugin</span>()<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>    <span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;development&#x27;</span>,  <span class="hljs-comment">//指定构建模式，可选development开发模式和production生产模式。</span><br>    <span class="hljs-attr">entry</span>: path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&#x27;./src/index.js&#x27;</span>), <span class="hljs-comment">//指定打包入口文件的路径。</span><br>    <span class="hljs-attr">output</span>: &#123;<br>        <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&#x27;./dist&#x27;</span>),   <span class="hljs-comment">//指定打包输出路径</span><br>        <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;bundle.js&#x27;</span>   <span class="hljs-comment">//指定打包输出文件名</span><br>    &#125;，<br>    <span class="hljs-attr">plugins</span>: [htmlPlugin, cleanPlugin,[<span class="hljs-string">&#x27;@babel/plugin-proposal-decorators&#x27;</span>, &#123; <span class="hljs-attr">legacy</span>: <span class="hljs-literal">true</span> &#125;]],  <br>    <span class="hljs-comment">//通过plugins节点，使htmlPlugin插件生效。</span><br>    <span class="hljs-attr">devServer</span>: &#123;<br>        <span class="hljs-attr">open</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">//初次打包完成后自动打开浏览器</span><br>        <span class="hljs-attr">host</span>: <span class="hljs-string">&#x27;127.0.0.1&#x27;</span>,<br>        <span class="hljs-attr">port</span>: <span class="hljs-number">80</span>,<br>        <span class="hljs-attr">hot</span>: <span class="hljs-literal">true</span>,  <span class="hljs-comment">//启动热更新</span><br>    &#125;,<br>    <span class="hljs-attr">module</span>: &#123;   <span class="hljs-comment">//所有第三方文件模块的匹配规则</span><br>        <span class="hljs-attr">rules</span>: [<br>            &#123; <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.css$/</span>, <span class="hljs-attr">use</span>: [<span class="hljs-string">&#x27;style-loader&#x27;</span>, <span class="hljs-string">&#x27;css-loader&#x27;</span>]&#125;,<br>            &#123; <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.less$/</span>, <span class="hljs-attr">use</span>: [<span class="hljs-string">&#x27;style-loader&#x27;</span>, <span class="hljs-string">&#x27;css-loader&#x27;</span>, <span class="hljs-string">&#x27;less-loader&#x27;</span>]&#125;,<br>            &#123; <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.jpg|png|gif$/</span>, <span class="hljs-attr">use</span>: <span class="hljs-string">&#x27;url-loader?limit=22229&#x27;</span>&#125;,   <span class="hljs-comment">//limit只的是限制文件大小。</span><br>            &#123; <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.js$/</span>, <span class="hljs-attr">use</span>: <span class="hljs-string">&#x27;babel-loader&#x27;</span>, <span class="hljs-attr">exclude</span>: <span class="hljs-regexp">/node_modules/</span>&#125;<br>        ]<br>    &#125;,<br>    <span class="hljs-comment">//配置路径</span><br>    <span class="hljs-attr">resolve</span>: &#123;<br>        <span class="hljs-attr">alias</span>: &#123;<br>            <span class="hljs-string">&#x27;@&#x27;</span>: path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&#x27;./src/&#x27;</span>)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>安装html-webpack-plugin，是webpack的html插件，可以通过此插件自定制index.html页面的内容，自动注入打包的bundle.js文件。<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> html-webpack-plugin -D<br></code></pre></td></tr></table></figure></li><li>安装copy-webpack-plugin，每次打包发布时，自动清理dist目录中的旧文件。<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> clean-webpack-plugin -D<br></code></pre></td></tr></table></figure></li><li>安装style-loader和css-loader，打包处理CSS文件；less-loader打包处理less文件；url-loader打包处理url相关文件；babel-loader打包处理高级js语法。<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">npm <span class="hljs-keyword">install </span>style-loader -D<br>npm <span class="hljs-keyword">install </span>css-loader -D<br>npm <span class="hljs-keyword">install </span>less-loader -D<br>npm <span class="hljs-keyword">install </span>less -D<br>npm <span class="hljs-keyword">install </span>url-loader -D<br>npm <span class="hljs-keyword">install </span>file-loader -D<br>npm <span class="hljs-keyword">install </span><span class="hljs-keyword">babel-loader </span>-D<br>npm i <span class="hljs-keyword">babel-loader@8.2.2 </span>@<span class="hljs-keyword">babel/core@7.14.6 </span>@<span class="hljs-keyword">babel/plugin-proposal-decorators@7.14.5 </span>-D<br></code></pre></td></tr></table></figure></li><li>安装webpack-dev-server：每当修改了源代码，webpack会自动进行项目的打包和构建，此时打包生成的js文件没有放在物理磁盘实际上是放在内存中的，可以一边修改一边在页面中查看修改后的样式。<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">npm install webpack-dev-<span class="hljs-keyword">server</span> -D<br></code></pre></td></tr></table></figure>修改package.json-&gt;scripts中<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-string">&quot;scripts&quot;</span> : &#123;<br>    <span class="hljs-string">&quot;dev&quot;</span> <span class="hljs-string">&quot;webpack serve&quot;</span>,  <span class="hljs-regexp">//</span>开发环境运行用dev<br>    <span class="hljs-string">&quot;build&quot;</span>: <span class="hljs-string">&quot;webpack --mode production&quot;</span> <span class="hljs-regexp">//</span>项目发布时，用build。<br>&#125;<br></code></pre></td></tr></table></figure></li><li>启动项目npm run dev</li></ol>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数组</title>
    <link href="/2022/06/25/%E6%95%B0%E7%BB%84/"/>
    <url>/2022/06/25/%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h4 id="一、数组去重"><a href="#一、数组去重" class="headerlink" title="一、数组去重"></a>一、数组去重</h4><ul><li><strong>方法一</strong>：定义一个新数组(非递增！！！），存放原数组的第一个元素，然后将原数组一一和新数组的元素对比，若不同则存放在新数组中。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">unique</span>(<span class="hljs-params">arr</span>)&#123;<br>    <span class="hljs-keyword">let</span> newArr = [arr[<span class="hljs-number">0</span>]];<br>    <span class="hljs-keyword">let</span> a=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">1</span>;i&lt;arr.<span class="hljs-property">length</span>;i++)&#123;<br>        <span class="hljs-keyword">let</span> repeat=<span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j=<span class="hljs-number">0</span>;j&lt;newArr.<span class="hljs-property">length</span>;j++)&#123;<br>            <span class="hljs-keyword">if</span>(arr[i]===newArr[j])&#123;<br>                repeat=<span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!repeat)&#123;<br>            newArr.<span class="hljs-title function_">push</span>(arr[i]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> newArr;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>方法二</strong>：先将原数组排序，再与新数组进行比较，若不同则存入新数组。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">unique</span>(<span class="hljs-params">arr</span>)&#123;<br>    <span class="hljs-keyword">var</span> formArr = arr.<span class="hljs-title function_">sort</span>();<br>    <span class="hljs-keyword">var</span> newArr = [formArr[<span class="hljs-number">0</span>]];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">1</span>;i&lt;formArr.<span class="hljs-property">length</span>;i++)&#123;<br>        <span class="hljs-keyword">if</span>(formArr[i]!==forArr[i-<span class="hljs-number">1</span>])&#123;<br>            newArr.<span class="hljs-title function_">push</span>(formArr[i]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> newArr;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>方法三</strong>：利用对象属性存在的特性，如果没有该属性则存入新数组。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">unique</span>(<span class="hljs-params">arr</span>)&#123;<br>    <span class="hljs-keyword">var</span> obj = &#123;&#125;;<br>    <span class="hljs-keyword">var</span> newArr = [];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;arr.<span class="hljs-property">length</span>;i++)&#123;<br>        <span class="hljs-keyword">if</span>(!obj[arr[i])&#123;<br>            obj[arr[i]]=<span class="hljs-number">1</span>;<br>            newArr.<span class="hljs-title function_">push</span>(arr[i]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> newArr;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>方法四</strong>：利用数组的indexOf下标属性来查询。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">unique</span>(<span class="hljs-params">arr</span>)&#123;<br>    <span class="hljs-keyword">var</span> newArr = [];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>;i&lt;arr.<span class="hljs-property">length</span>;i++)&#123;<br>        <span class="hljs-keyword">if</span>(newArr.<span class="hljs-title function_">indexOf</span>(<span class="hljs-params">arr[i]===-<span class="hljs-number">1</span></span>)&#123;<br>            newArr.<span class="hljs-title function_">push</span>(arr[i])<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> newArr;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>方法五</strong>：利用数组原型对象上的includes方法。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">unique</span>(<span class="hljs-params">arr</span>)&#123;<br>    <span class="hljs-keyword">var</span> newArr = [];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>;i&lt;arr.<span class="hljs-property">length</span>;i++)&#123;<br>        <span class="hljs-keyword">if</span>(!newArr.<span class="hljs-title function_">includes</span>(<span class="hljs-params">arr[i]</span>)&#123;<br>            newArr.<span class="hljs-title function_">push</span>(arr[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> newArr;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>方法六</strong>：利用数组原型对象上的filter和includes方法。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">unique</span>(<span class="hljs-params">arr</span>)&#123;<br>    <span class="hljs-keyword">var</span> newArr = [];<br>    newArr= arr.<span class="hljs-title function_">filter</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>)&#123;<br>        <span class="hljs-keyword">return</span> newArr.<span class="hljs-title function_">includes</span>(item)?<span class="hljs-string">&#x27;&#x27;</span>:newArr.<span class="hljs-title function_">push</span>(item);<br>    &#125;)<br>    <span class="hljs-keyword">return</span> newArr;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>方法七</strong>：利用数组原型对象上的forEach和includes方法。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">unique</span>(<span class="hljs-params">arr</span>)&#123;<br>    <span class="hljs-keyword">let</span> newArr = [];<br>    arr.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span>&#123;<br>        <span class="hljs-keyword">return</span> newArr.<span class="hljs-title function_">includes</span>(item)?<span class="hljs-string">&#x27;&#x27;</span>:newArr.<span class="hljs-title function_">push</span>(item);<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>方法八</strong>：利用数组原型对象上的splice方法。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">unique</span>(<span class="hljs-params">arr</span>)&#123;<br>    <span class="hljs-keyword">var</span> i,j,len=arr.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j=i+<span class="hljs-number">1</span>;j&lt;len;j++)&#123;<br>            <span class="hljs-keyword">if</span>(arr[i]===arr[j])&#123;<br>                arr.<span class="hljs-title function_">splice</span>(j,<span class="hljs-number">1</span>);<br>                len--;<br>                j--;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>方法九</strong>：利用数组原型对象上的lastIndexOf方法。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">unique</span>(<span class="hljs-params">arr</span>)&#123;<br>    <span class="hljs-keyword">var</span> newArr = [];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;arr.<span class="hljs-property">length</span>;i++)&#123;<br>        newArr.<span class="hljs-title function_">lastIndexOf</span>(arr[i])!==-<span class="hljs-number">1</span>? <span class="hljs-string">&#x27;&#x27;</span> : newArr.<span class="hljs-title function_">push</span>(arr[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> newArr;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>方法十</strong>：利用ES6的set方法。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">unique</span>(<span class="hljs-params">arr</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(arr));<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>方法十一</strong>：时间复杂度为O(n)。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">unique</span>(<span class="hljs-params">arr</span>)&#123;<br>    <span class="hljs-keyword">var</span> newArr = [];<br>    <span class="hljs-keyword">return</span> arr.<span class="hljs-title function_">filter</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">item,index,array</span>)&#123;<br>        <span class="hljs-keyword">return</span> newArr.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-keyword">typeof</span> item+item)? <span class="hljs-literal">false</span> : (newArr[<span class="hljs-keyword">typeof</span> item+item]) = <span class="hljs-literal">true</span>);<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>优点：hasOwnProperty是对象的属性（名称）存在性检查方法，对象的属性可以基于hash表实现，因此对属性进行访问的时间复杂度可以达到O(1)。filter是数组迭代的方法，内部还是一个for循环，所以时间复杂度是O(n)。<br>缺点：不兼容IE9以下浏览器，解决办法是把filter方法用for循环代替或自己模拟一个filter方法。</p><h4 id="二、实现数组的全排列"><a href="#二、实现数组的全排列" class="headerlink" title="二、实现数组的全排列"></a>二、实现数组的全排列</h4><p>每次从数组中取出一个，然后将剩余的再进行排列。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">perm</span>(<span class="hljs-params">arr</span>)&#123;<br>    <span class="hljs-keyword">let</span> res = [];<br>    <span class="hljs-keyword">if</span>(arr.<span class="hljs-property">length</span>&lt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> [arr];<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;arr.<span class="hljs-property">length</span>;i++)&#123;<br>            <span class="hljs-keyword">let</span> first = arr[i], sec=arr.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>,i).<span class="hljs-title function_">concat</span>(arr.<span class="hljs-title function_">slice</span>(i+<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">let</span> re = <span class="hljs-title function_">perm</span>(sec);<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j=<span class="hljs-number">0</span>;j&lt;re.<span class="hljs-property">length</span>;j++)&#123;<br>                res.<span class="hljs-title function_">push</span>(re[j].<span class="hljs-title function_">unshift</span>(first));<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> [...<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(res)];<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="三、合并两个有序数组"><a href="#三、合并两个有序数组" class="headerlink" title="三、合并两个有序数组"></a>三、合并两个有序数组</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">mergeArray</span>(<span class="hljs-params">arr1,arr2</span>)&#123;<br>    <span class="hljs-keyword">var</span> arr = [];<br>    <span class="hljs-keyword">while</span>(arr1.<span class="hljs-property">length</span>&gt;<span class="hljs-number">0</span>&amp;&amp;arr2.<span class="hljs-property">length</span>&gt;<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">if</span>(arr1[<span class="hljs-number">0</span>]&lt;arr2[<span class="hljs-number">0</span>])&#123;<br>            arr.<span class="hljs-title function_">push</span>(arr1[<span class="hljs-number">0</span>]);<br>            arr1.<span class="hljs-title function_">shift</span>();<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            arr.<span class="hljs-title function_">push</span>(arr2[<span class="hljs-number">0</span>]);<br>            arr2.<span class="hljs-title function_">shift</span>();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(arr1.<span class="hljs-property">length</span>&gt;<span class="hljs-number">0</span>)&#123;<br>        arr.<span class="hljs-title function_">concat</span>(arr1);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(arr2.<span class="hljs-property">length</span>&gt;<span class="hljs-number">0</span>)&#123;<br>        arr.<span class="hljs-title function_">concat</span>(arr2);<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="四、将数组中所有的数连接成一个最大的数"><a href="#四、将数组中所有的数连接成一个最大的数" class="headerlink" title="四、将数组中所有的数连接成一个最大的数"></a>四、将数组中所有的数连接成一个最大的数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">largestNumber</span>(<span class="hljs-params">nums</span>)&#123;<br>    nums.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a,b</span>)=&gt;</span>&#123;<br>        <span class="hljs-keyword">let</span> t1 = a + <span class="hljs-string">&#x27;&#x27;</span> + b;<br>        <span class="hljs-keyword">let</span> t2 = b + <span class="hljs-string">&#x27;&#x27;</span> + a;<br>        <span class="hljs-keyword">if</span>(t1&lt;t2)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t1&gt;t2)&#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">let</span> ans = nums.<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;&#x27;</span>);<br>    <span class="hljs-keyword">return</span> ans[<span class="hljs-number">0</span>]===<span class="hljs-string">&#x27;0&#x27;</span> ? <span class="hljs-string">&#x27;0&#x27;</span> : ans;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="五、将数组中所有的数连接成一个最小的数"><a href="#五、将数组中所有的数连接成一个最小的数" class="headerlink" title="五、将数组中所有的数连接成一个最小的数"></a>五、将数组中所有的数连接成一个最小的数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">largestNumber</span>(<span class="hljs-params">nums</span>)&#123;<br>    nums.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a,b</span>)=&gt;</span>&#123;<br>        <span class="hljs-keyword">let</span> t1 = a + <span class="hljs-string">&#x27;&#x27;</span> + b;<br>        <span class="hljs-keyword">let</span> t2 = b + <span class="hljs-string">&#x27;&#x27;</span> + a;<br>        <span class="hljs-keyword">if</span>(t1&lt;t2)&#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t1&gt;t2)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">let</span> ans = nums.<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;&#x27;</span>);<br>    <span class="hljs-keyword">return</span> ans[<span class="hljs-number">0</span>]===<span class="hljs-string">&#x27;0&#x27;</span> ? <span class="hljs-string">&#x27;0&#x27;</span> : ans;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="六、最长连续递增子数组"><a href="#六、最长连续递增子数组" class="headerlink" title="六、最长连续递增子数组"></a>六、最长连续递增子数组</h4><p>每当后面的数小于前面的数时，直接count++，否则重置为1，最终保存的最大count就是结果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">findLength</span>(<span class="hljs-params">nums</span>)&#123;<br>    <span class="hljs-keyword">if</span>(nums.<span class="hljs-property">length</span>===<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">let</span> res=<span class="hljs-number">1</span>,count=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-property">length</span>;i++)&#123;<br>        <span class="hljs-keyword">if</span>(nums[i]&lt;nums[i+<span class="hljs-number">1</span>])&#123;<br>            count++;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            count = <span class="hljs-number">1</span>;<br>        &#125;<br>        res = res &gt;count ? res : count;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="七、数组中找三个数和为指定值"><a href="#七、数组中找三个数和为指定值" class="headerlink" title="七、数组中找三个数和为指定值"></a>七、数组中找三个数和为指定值</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">threeSum</span>(<span class="hljs-params">nums,key</span>)&#123;<br>    <span class="hljs-keyword">let</span> res = [];<br>    <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;<br>    nums = nums.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a,b</span>)=&gt;</span>&#123;<br>        <span class="hljs-keyword">return</span> a-b;<br>    &#125;<br>    <span class="hljs-keyword">const</span> len = nums.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;len-<span class="hljs-number">2</span>;i++)&#123;<br>        <span class="hljs-keyword">let</span> j=i+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">let</span> k=len-<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//如果遇到重复的数字，则跳过。</span><br>        <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span>&amp;&amp;nums[i]===nums[i-<span class="hljs-number">1</span>])&#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(j&lt;k)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i]+nums[j]+nums[k]&lt;key)&#123;<br>                j++;<br>                <span class="hljs-keyword">while</span>(j&lt;k&amp;&amp;nums[j]===nums[j-<span class="hljs-number">1</span>])&#123;<br>                    j++;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[i]+nums[j]+nums[k]&gt;key)&#123;<br>                k--;<br>                <span class="hljs-keyword">while</span>(j&lt;k&amp;&amp;nums[k]===nums<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="八、寻找数组中三个数的最大乘积"><a href="#八、寻找数组中三个数的最大乘积" class="headerlink" title="八、寻找数组中三个数的最大乘积"></a>八、寻找数组中三个数的最大乘积</h4><p>先对数组进行排序，若全是正数或全是负数，则最后三个数的乘积最大。若存在负数和正数，则前两个数必然是最小的负数，将前两个数与最后一个数相乘，再与最后三个数的乘积比较大小。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">maxProduct</span>(<span class="hljs-params">nums</span>)&#123;<br>    nums.<span class="hljs-title function_">sort</span>();<br>    <span class="hljs-keyword">let</span> num1 = nums[<span class="hljs-number">0</span>]*nums[<span class="hljs-number">1</span>]*nums[nums.<span class="hljs-property">length</span>-<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">let</span> num2 = nums[nums.<span class="hljs-property">length</span>-<span class="hljs-number">3</span>]*nums[nums.<span class="hljs-property">length</span>-<span class="hljs-number">2</span>]*nums[nums.<span class="hljs-property">length</span>-<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(num1,num2)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="九、连续子数组的最大和"><a href="#九、连续子数组的最大和" class="headerlink" title="九、连续子数组的最大和"></a>九、连续子数组的最大和</h4><p> 遍历数组，若数组累加和为负，则放弃之前的累加，重新开始累加，并记录该过程的最大值。<br> 用sum记录最终返回的最大和，用temp记录当前累加值。<br>对于数组中的一个数array[i]，若其前面的累加和为非负，则加上array[i]，<br>判断此时temp的值是否大于sum，若大于则替换。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">findMax</span>(<span class="hljs-params">array</span>)&#123;<br>    <span class="hljs-keyword">if</span>(array.<span class="hljs-property">length</span>&lt;=<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">let</span> sum=array[<span class="hljs-number">0</span>],temp=array[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;array.<span class="hljs-property">length</span>;i++)&#123;<br>        <span class="hljs-keyword">if</span>(temp&lt;<span class="hljs-number">0</span>)&#123;<br>            temp = array[i];<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            temp = temp + array[i];<br>        &#125;<br>        <span class="hljs-keyword">if</span>(temp&gt;sum)&#123;<br>            sum = temp;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="★十、打平数组"><a href="#★十、打平数组" class="headerlink" title="★十、打平数组"></a>★十、打平数组</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">flat</span>(<span class="hljs-params">arr</span>)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> item <span class="hljs-keyword">of</span> arr)&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(item))&#123;<br>            <span class="hljs-title function_">flat</span>(item);<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            res.<span class="hljs-title function_">add</span>(item);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">let</span> data = [...res];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<br></code></pre></td></tr></table></figure><h4 id="十一、最大连续递增子序列"><a href="#十一、最大连续递增子序列" class="headerlink" title="十一、最大连续递增子序列"></a>十一、最大连续递增子序列</h4><p>遍历数组，当遇到某个位置不满足递增时，以该点为开头重新计算最长递增序列。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> findLengthOfLCIS = <span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) &#123;<br>    <span class="hljs-keyword">let</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">const</span> n = nums.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">let</span> start = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] &lt;= nums[i - <span class="hljs-number">1</span>]) &#123;<br>            start = i;<br>        &#125;<br>        ans = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(ans, i - start + <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="十二、滑动窗口的最大值"><a href="#十二、滑动窗口的最大值" class="headerlink" title="十二、滑动窗口的最大值"></a>十二、滑动窗口的最大值</h4><p>给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。<br><strong>思路</strong>：<br>首先将数组每k个一组进行分组，并求nums[i]到nums[i+k-1]的最大值。<br>若i是k的倍数，那么nums[i]到nums[i+k-1]恰好是一个分组，只要预处理每个分组中最大值。<br>若不是k的倍数，那么从前一个分组后缀最大值和后一个分组前缀最大值中获取。<br>设prefixMax[i]是以i结尾前缀最大值，suffixMax[i]是以i开始的后缀最大值。<br>prefixMax[i] &#x3D; max{prefixMax[i-1],nums[i]}(i不是k的倍数，否则为nums[i]）<br>suffixMax[i] &#x3D; max{suffixMax[i+1],nums[i]}(i不是k的倍数，否则为nums[i])<br>i不是k的倍数时，窗口最大值为max{suffixMax[i],prefixMax{i+k-1]}</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> maxSlidingWindow = <span class="hljs-keyword">function</span>(<span class="hljs-params">nums, k</span>) &#123;<br>    <span class="hljs-keyword">const</span> n = nums.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">const</span> prefixMax = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(n).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">const</span> suffixMax = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(n).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (i % k === <span class="hljs-number">0</span>) &#123;<br>            prefixMax[i] = nums[i];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            prefixMax[i] = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(prefixMax[i - <span class="hljs-number">1</span>], nums[i]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>        <span class="hljs-keyword">if</span> (i === n || (i + <span class="hljs-number">1</span>) % k === <span class="hljs-number">0</span>) &#123;<br>            suffixMax[i] = nums[i];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            suffixMax[i] = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(suffixMax[i + <span class="hljs-number">1</span>], nums[i]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">const</span> ans = [];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n - k + <span class="hljs-number">1</span>; i++) &#123;<br>        ans.<span class="hljs-title function_">push</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(suffixMax[i], prefixMax[i + k - <span class="hljs-number">1</span>]));<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="十三、最多包含两个不同字符的最长子串"><a href="#十三、最多包含两个不同字符的最长子串" class="headerlink" title="十三、最多包含两个不同字符的最长子串"></a>十三、最多包含两个不同字符的最长子串</h4><p>返回该子串长度，如ece<br><strong>思路</strong>：双指针，先一个向右走，直到超过，再左指针也向右，直到不超过，重复。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">maxLength</span>(<span class="hljs-params">s</span>)&#123;<br>    <span class="hljs-keyword">let</span> strlen = s.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">if</span>(strlen&lt;<span class="hljs-number">3</span>)&#123;<br>        <span class="hljs-keyword">return</span> strlen;<br>    &#125;<br>    <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br>    <span class="hljs-keyword">let</span> maxlen = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(right&lt;strlen)&#123;<br>        <span class="hljs-keyword">if</span>(map.<span class="hljs-title function_">has</span>(<span class="hljs-params">s[right]</span>)&#123;<br>            map.<span class="hljs-title function_">set</span>(s[right],map.<span class="hljs-title function_">get</span>(s[right])+<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            map.<span class="hljs-title function_">set</span>(s[right],<span class="hljs-number">1</span>);<br>        &#125;<br>        right++;<br>        <span class="hljs-keyword">while</span>(map.<span class="hljs-property">size</span>===<span class="hljs-number">3</span>)&#123;<br>            <span class="hljs-keyword">if</span>(map.<span class="hljs-title function_">get</span>(<span class="hljs-params">s[left]&gt;<span class="hljs-number">1</span></span>)&#123;<br>                map.<span class="hljs-title function_">set</span>(s[left],map.<span class="hljs-title function_">get</span>(s[left])-<span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(map.<span class="hljs-title function_">get</span>(s[left])===<span class="hljs-number">1</span>)&#123;<br>                map.<span class="hljs-title function_">delete</span>(s[left]);<br>            &#125;<br>            left++;<br>        &#125;<br>        maxlen = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(maxlen,right-left);<br>    &#125; <br>    <span class="hljs-keyword">return</span> maxlen;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>304.二维区域和检索-矩阵不可变</title>
    <link href="/2022/06/20/304-%E4%BA%8C%E7%BB%B4%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2-%E7%9F%A9%E9%98%B5%E4%B8%8D%E5%8F%AF%E5%8F%98/"/>
    <url>/2022/06/20/304-%E4%BA%8C%E7%BB%B4%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2-%E7%9F%A9%E9%98%B5%E4%B8%8D%E5%8F%AF%E5%8F%98/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个二维矩阵 matrix，以下类型的多个请求：<br>计算其子矩形范围内元素的总和，该子矩阵的 左上角 为 (row1, col1) ，右下角 为 (row2, col2) 。<br>实现 NumMatrix 类：<br>NumMatrix(int[][] matrix) 给定整数矩阵 matrix 进行初始化<br>int sumRegion(int row1, int col1, int row2, int col2) 返回 左上角 (row1, col1) 、右下角 (row2, col2) 所描述的子矩阵的元素 总和 。<br>输入:<br>[“NumMatrix”,”sumRegion”,”sumRegion”,”sumRegion”]<br>[[[[3,0,1,4,2],[5,6,3,2,1],[1,2,0,1,5],[4,1,0,1,7],[1,0,3,0,5]]],[2,1,4,3],[1,1,2,2],[1,2,2,4]]<br>输出:<br>[null, 8, 11, 12]<br>解释:<br>NumMatrix numMatrix &#x3D; new NumMatrix([[3,0,1,4,2],[5,6,3,2,1],[1,2,0,1,5],[4,1,0,1,7],[1,0,3,0,5]]);<br>numMatrix.sumRegion(2, 1, 4, 3); &#x2F;&#x2F; return 8 (红色矩形框的元素总和)<br>numMatrix.sumRegion(1, 1, 2, 2); &#x2F;&#x2F; return 11 (绿色矩形框的元素总和)<br>numMatrix.sumRegion(1, 2, 2, 4); &#x2F;&#x2F; return 12 (蓝色矩形框的元素总和)</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>首先找以每个节点为尾左上角所有元素的总和，然后指定的值等于：<br> <img src="/2022/06/20/304-%E4%BA%8C%E7%BB%B4%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2-%E7%9F%A9%E9%98%B5%E4%B8%8D%E5%8F%AF%E5%8F%98/%E5%92%8C.png" class=""></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> <span class="hljs-title class_">NumMatrix</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">matrix</span>) &#123;<br>    <span class="hljs-keyword">const</span> m = matrix.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">if</span>(m&gt;<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">const</span> n = matrix[<span class="hljs-number">0</span>].<span class="hljs-property">length</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">sums</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(m+<span class="hljs-number">1</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>).<span class="hljs-title function_">map</span>(<span class="hljs-function">()=&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(n+<span class="hljs-number">1</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>                <span class="hljs-variable language_">this</span>.<span class="hljs-property">sums</span>[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>] = matrix[i][j] + <span class="hljs-variable language_">this</span>.<span class="hljs-property">sums</span>[i][j+<span class="hljs-number">1</span>] + <span class="hljs-variable language_">this</span>.<span class="hljs-property">sums</span>[i+<span class="hljs-number">1</span>][j] - <span class="hljs-variable language_">this</span>.<span class="hljs-property">sums</span>[i][j];<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br><span class="hljs-title class_">NumMatrix</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sumRegion</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">row1, col1, row2, col2</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">sums</span>[row2+<span class="hljs-number">1</span>][col2+<span class="hljs-number">1</span>] + <span class="hljs-variable language_">this</span>.<span class="hljs-property">sums</span>[row1][col1] - <span class="hljs-variable language_">this</span>.<span class="hljs-property">sums</span>[row1][col2+<span class="hljs-number">1</span>] - <span class="hljs-variable language_">this</span>.<span class="hljs-property">sums</span>[row2+<span class="hljs-number">1</span>][col1];<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>数组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>矩阵不可变</title>
    <link href="/2022/06/20/%E7%9F%A9%E9%98%B5%E4%B8%8D%E5%8F%AF%E5%8F%98/"/>
    <url>/2022/06/20/%E7%9F%A9%E9%98%B5%E4%B8%8D%E5%8F%AF%E5%8F%98/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>303.区域和检索-数组不可变</title>
    <link href="/2022/06/20/303-%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2-%E6%95%B0%E7%BB%84%E4%B8%8D%E5%8F%AF%E5%8F%98/"/>
    <url>/2022/06/20/303-%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2-%E6%95%B0%E7%BB%84%E4%B8%8D%E5%8F%AF%E5%8F%98/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个整数数组  nums，处理以下类型的多个查询:<br>计算索引 left 和 right （包含 left 和 right）之间的 nums 元素的 和 ，其中 left &lt;&#x3D; right<br>实现 NumArray 类：<br>NumArray(int[] nums) 使用数组 nums 初始化对象<br>int sumRange(int i, int j) 返回数组 nums 中索引 left 和 right 之间的元素的 总和 ，包含 left 和 right 两点（也就是 nums[left] + nums[left + 1] + … + nums[right] )<br>输入：<br>[“NumArray”, “sumRange”, “sumRange”, “sumRange”]<br>[[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]<br>输出：<br>[null, 1, -1, -3]<br>解释：<br>NumArray numArray &#x3D; new NumArray([-2, 0, 3, -5, 2, -1]);<br>numArray.sumRange(0, 2); &#x2F;&#x2F; return 1 ((-2) + 0 + 3)<br>numArray.sumRange(2, 5); &#x2F;&#x2F; return -1 (3 + (-5) + 2 + (-1))<br>numArray.sumRange(0, 5); &#x2F;&#x2F; return -3 ((-2) + 0 + 3 + (-5) + 2 + (-1))</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>直接记录以每个元素为结尾到第一个元素的和。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> <span class="hljs-title class_">NumArray</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) &#123;<br>    <span class="hljs-keyword">const</span> n =nums.<span class="hljs-property">length</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">sums</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(n+<span class="hljs-number">1</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">sums</span>[i+<span class="hljs-number">1</span>] = <span class="hljs-variable language_">this</span>.<span class="hljs-property">sums</span>[i] + nums[i];<br>    &#125;<br>&#125;;<br><br><span class="hljs-title class_">NumArray</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sumRange</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">left, right</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">sums</span>[right+<span class="hljs-number">1</span>] - <span class="hljs-variable language_">this</span>.<span class="hljs-property">sums</span>[left];<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>数组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5.最长回文子串</title>
    <link href="/2022/06/20/5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
    <url>/2022/06/20/5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个字符串 s，找到 s 中最长的回文子串。<br>输入：s &#x3D; “babad”<br>输出：”bab”<br>解释：”aba” 同样是符合题意的答案。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>从头开始，以每一个或两个元素为中心向两侧延伸。<br>如果延伸后两侧相等，继续延伸，直到不能延伸。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> longestPalindrome = <span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) &#123;<br>    <span class="hljs-keyword">let</span> start=<span class="hljs-number">0</span>,end=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;s.<span class="hljs-property">length</span>;i++)&#123;<br>        <span class="hljs-keyword">let</span> [left1,right1]=<span class="hljs-title function_">expand</span>(s,i,i);<br>        <span class="hljs-keyword">let</span> [left2,right2]=<span class="hljs-title function_">expand</span>(s,i,i+<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span>(right1-left1&gt;end-start)&#123;<br>            start = left1;<br>            end = right1;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(right2-left2&gt;end-start)&#123;<br>            start = left2;<br>            end = right2;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> s.<span class="hljs-title function_">slice</span>(start,end+<span class="hljs-number">1</span>);<br>&#125;;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">expand</span>(<span class="hljs-params">s,left,right</span>)&#123;<br>    <span class="hljs-keyword">while</span>(left&gt;=<span class="hljs-number">0</span> &amp;&amp; right&lt;s.<span class="hljs-property">length</span>&amp;&amp;s[left]===s[right])&#123;<br>        left--;<br>        right++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> [left+<span class="hljs-number">1</span>,right-<span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>数组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>167.两数之和2-输入有序数组</title>
    <link href="/2022/06/20/167-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C2-%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
    <url>/2022/06/20/167-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C2-%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个下标从 1 开始的整数数组 numbers ，该数组已按 非递减顺序排列  ，请你从数组中找出满足相加之和等于目标数 target 的两个数。如果设这两个数分别是 numbers[index1] 和 numbers[index2] ，则 1 &lt;&#x3D; index1 &lt; index2 &lt;&#x3D; numbers.length 。<br>以长度为 2 的整数数组 [index1, index2] 的形式返回这两个整数的下标 index1 和 index2。<br>你可以假设每个输入 只对应唯一的答案 ，而且你 不可以 重复使用相同的元素。<br>你所设计的解决方案必须只使用常量级的额外空间。<br>输入：numbers &#x3D; [2,7,11,15], target &#x3D; 9<br>输出：[1,2]<br>解释：2 与 7 之和等于目标数 9 。因此 index1 &#x3D; 1, index2 &#x3D; 2 。返回 [1, 2] 。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>直接建立两个指针，一个指向头一个指向尾巴。因为数组是递增的，所以两个指针的和比目标值小时，前一个指针向后移；比目标值大时，后一个指针前移。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> twoSum = <span class="hljs-keyword">function</span>(<span class="hljs-params">numbers, target</span>) &#123;<br>    <span class="hljs-keyword">let</span> left=<span class="hljs-number">0</span>, right=numbers.<span class="hljs-property">length</span>-<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(left&lt;right)&#123;<br>        <span class="hljs-keyword">let</span> sum = numbers[left] + numbers[right];<br>        <span class="hljs-keyword">if</span>(sum===target)&#123;<br>            <span class="hljs-keyword">return</span> [left+<span class="hljs-number">1</span>, right+<span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sum&lt;target)&#123;<br>            left++;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sum&gt;target)&#123;<br>            right--;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> [-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>];<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>数组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>283.移动零</title>
    <link href="/2022/06/20/283-%E7%A7%BB%E5%8A%A8%E9%9B%B6/"/>
    <url>/2022/06/20/283-%E7%A7%BB%E5%8A%A8%E9%9B%B6/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。请注意 ，必须在不复制数组的情况下原地对数组进行操作。<br>输入: nums &#x3D; [0,1,0,3,12]输出: [1,3,12,0,0]</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> moveZeroes = <span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) &#123;<br>    <span class="hljs-keyword">const</span> len=nums.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">let</span> slow=<span class="hljs-number">0</span>, fast=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(fast&lt;len)&#123;<br>        <span class="hljs-keyword">if</span>(nums[fast]!==<span class="hljs-number">0</span>)&#123;<br>            nums[slow]=nums[fast];<br>            slow++;<br>        &#125;<br>        fast++;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(slow&lt;len)&#123;<br>        nums[slow]=<span class="hljs-number">0</span>;<br>        slow++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> nums;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>数组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>27.移除元素</title>
    <link href="/2022/06/20/27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/"/>
    <url>/2022/06/20/27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。<br>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。<br>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。<br>输入：nums &#x3D; [3,2,2,3], val &#x3D; 3<br>输出：2, nums &#x3D; [2,2]<br>解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums &#x3D; [2,2,3,3] 或 nums &#x3D; [2,2,0,0]，也会被视作正确答案。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>直接设置两个指针，一个遍历所有元素，不等于指定值时另一个指针才后移，并存下新值。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> removeElement = <span class="hljs-keyword">function</span>(<span class="hljs-params">nums, val</span>) &#123;<br>    <span class="hljs-keyword">let</span> len = nums.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">if</span>(len===<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">let</span> all = <span class="hljs-number">0</span>,cur = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(cur&lt;len)&#123;<br>        <span class="hljs-keyword">if</span>(nums[cur]!=val)&#123;<br>            nums[all] = nums[cur];<br>            all++;<br>        &#125;<br>        cur++;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(cur&gt;all)&#123;<br>        nums.<span class="hljs-title function_">pop</span>();<br>        cur--;<br>    &#125;<br>    <span class="hljs-keyword">return</span> all;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>数组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>26.【双指针】删除有序数组中的重复项</title>
    <link href="/2022/06/20/26-%E3%80%90%E5%8F%8C%E6%8C%87%E9%92%88%E3%80%91%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/"/>
    <url>/2022/06/20/26-%E3%80%90%E5%8F%8C%E6%8C%87%E9%92%88%E3%80%91%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。<br>由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有 k 个元素，那么 nums 的前 k 个元素应该保存最终结果。<br>将最终结果插入 nums 的前 k 个位置后返回 k 。<br>输入：nums &#x3D; [1,1,2]<br>输出：2, nums &#x3D; [1,2]</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>设置两个节点slow和fast，都从第一个元素开始。fast每次后移一个，当fast发现目前的元素与slow的元素不同时，将slow后移一个，并保存fast的元素。最后将slow之后的元素都删掉，并返回slow的长度。 </p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> removeDuplicates = <span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) &#123;<br>    <span class="hljs-keyword">const</span> len = nums.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">if</span>(len&lt;=<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br>    <span class="hljs-keyword">let</span> slow=<span class="hljs-number">0</span>,fast=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(fast&lt;len)&#123;<br>        <span class="hljs-keyword">if</span>(nums[fast]!==nums[slow])&#123;<br>            slow++;<br>            nums[slow] = nums[fast];<br>        &#125;<br>        fast++;<br>    &#125;<br>    fast--;<br>    <span class="hljs-keyword">while</span>(fast&gt;slow)&#123;<br>        nums.<span class="hljs-title function_">pop</span>();<br>        fast--;<br>    &#125;<br>    <span class="hljs-keyword">return</span> slow+<span class="hljs-number">1</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>数组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>83.【双指针】删除排序链表中的重复元素</title>
    <link href="/2022/06/20/83-%E3%80%90%E5%8F%8C%E6%8C%87%E9%92%88%E3%80%91%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/"/>
    <url>/2022/06/20/83-%E3%80%90%E5%8F%8C%E6%8C%87%E9%92%88%E3%80%91%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个已排序的链表的头 head ， 删除所有重复的元素，使每个元素只出现一次 。返回 已排序的链表 。<br>输入：head &#x3D; [1,1,2]<br>输出：[1,2]</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>直接从起点出发设置两个节点slow和fast，当fast的值与slow不同时，将slow的下一个节点指向fast。<strong>最后链表尾部要指向null</strong></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> deleteDuplicates = <span class="hljs-keyword">function</span>(<span class="hljs-params">head</span>) &#123;<br>    <span class="hljs-keyword">let</span> slow = head,fast = head;<br>    <span class="hljs-keyword">if</span>(!head)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    fast = fast.<span class="hljs-property">next</span>;<br>    <span class="hljs-keyword">while</span>(fast)&#123;<br>        <span class="hljs-keyword">if</span>(fast.<span class="hljs-property">val</span>!==slow.<span class="hljs-property">val</span>)&#123;<br>            slow.<span class="hljs-property">next</span> = fast;<br>            slow = slow.<span class="hljs-property">next</span>;<br>        &#125;<br>        fast = fast.<span class="hljs-property">next</span>;<br>    &#125;<br>    slow.<span class="hljs-property">next</span> = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">return</span> head;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>链表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>234.【双指针】回文链表</title>
    <link href="/2022/06/20/234-%E3%80%90%E5%8F%8C%E6%8C%87%E9%92%88%E3%80%91%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/"/>
    <url>/2022/06/20/234-%E3%80%90%E5%8F%8C%E6%8C%87%E9%92%88%E3%80%91%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>分为三步：<br>①找中心结点，将原链表二分。从起点出发，慢的结点一次走一步，快的一次走两步，并记录另一个节点pre作为slow的前一个节点。当快的走到末尾且后一个为空时，说明有奇数个节点，此时slow向后取一个。当fast最后走了一步后面就没有了的时候，说明有偶数个节点。<br>②从slow开始，与前面的链表截断，并翻转slow开始的后半段链表。<br>③同时遍历快和慢两个链表，如果一直相同，则为true；出现不同就停止，为false。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> isPalindrome = <span class="hljs-keyword">function</span>(<span class="hljs-params">head</span>) &#123;<br>    <span class="hljs-keyword">let</span> pre = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>,head);<br>    <span class="hljs-keyword">let</span> slow = head, fast=head;<br>    <span class="hljs-keyword">while</span>(fast.<span class="hljs-property">next</span>)&#123;<br>        fast = fast.<span class="hljs-property">next</span>.<span class="hljs-property">next</span>;<br>        slow = slow.<span class="hljs-property">next</span>;<br>        pre = pre.<span class="hljs-property">next</span>;<br>        <span class="hljs-keyword">if</span>(!fast)&#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(fast)&#123;<br>        pre=pre.<span class="hljs-property">next</span>;<br>        slow=slow.<span class="hljs-property">next</span>;<br>    &#125;<br>    pre.<span class="hljs-property">next</span> = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">let</span> first=head,second=<span class="hljs-title function_">reverse</span>(slow);<br>    <span class="hljs-keyword">while</span>(second)&#123;<br>        <span class="hljs-keyword">if</span>(first.<span class="hljs-property">val</span>!=second.<span class="hljs-property">val</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        first=first.<span class="hljs-property">next</span>;<br>        second=second.<span class="hljs-property">next</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">reverse</span>(<span class="hljs-params">head</span>)&#123;<br>    <span class="hljs-keyword">let</span> pre = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">let</span> cur=head, nxt=head;<br>    <span class="hljs-keyword">while</span>(cur)&#123;<br>        nxt = nxt.<span class="hljs-property">next</span>;<br>        cur.<span class="hljs-property">next</span> = pre;<br>        pre = cur;<br>        cur = nxt;<br>    &#125;<br>    <span class="hljs-keyword">return</span> pre;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>链表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>25.K个一组翻转链表</title>
    <link href="/2022/06/17/25-K%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <url>/2022/06/17/25-K%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你链表的头节点 head ，每 k 个节点一组进行翻转，请你返回修改后的链表。k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。<br>输入：head &#x3D; [1,2,3,4,5], k &#x3D; 2<br>输出：[2,1,4,3,5]<br>输入：head &#x3D; [1,2,3,4,5], k &#x3D; 3<br>输出：[3,2,1,4,5]</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>先设置一个函数，用于翻转a到b之内的链表。然后依次每k个结点进行翻转，再递归剩下的链表，最后连起来。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> reverseKGroup = <span class="hljs-keyword">function</span>(<span class="hljs-params">head, k</span>) &#123;<br>    <span class="hljs-keyword">let</span> a=head,b=head;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;k;i++)&#123;<br>        <span class="hljs-keyword">if</span>(!b)&#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        b = b.<span class="hljs-property">next</span>;<br>    &#125;<br>    <span class="hljs-keyword">let</span> newhead = <span class="hljs-title function_">reverse</span>(a,b);<br>    a.<span class="hljs-property">next</span> = <span class="hljs-title function_">reverseKGroup</span>(b,k);<br>    <span class="hljs-keyword">return</span> newhead;<br>&#125;;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">reverse</span>(<span class="hljs-params">a,b</span>)&#123;<br>    <span class="hljs-keyword">let</span> pre=<span class="hljs-literal">null</span>,cur=a,nxt=a;<br>    <span class="hljs-keyword">while</span>(cur!==b)&#123;<br>        nxt = cur.<span class="hljs-property">next</span>;<br>        cur.<span class="hljs-property">next</span> = pre;<br>        pre = cur;<br>        cur = nxt;<br>    &#125;<br>    <span class="hljs-keyword">return</span> pre;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>链表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>92.反转链表2</title>
    <link href="/2022/06/17/92-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A82/"/>
    <url>/2022/06/17/92-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A82/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你单链表的头指针 head 和两个整数 left 和 right ，其中 left &lt;&#x3D; right 。请你反转从位置 left 到位置 right 的链表节点，返回反转后的链表。</p><p>输入：head &#x3D; [1,2,3,4,5], left &#x3D; 2, right &#x3D; 4<br>输出：[1,4,3,2,5]</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>在头结点前插入一个结点，可以省去好多情况的讨论。<br>找到反转部分的前一个节点、第一个节点、最后一个节点、最后节点再往后一个节点。<br>将反转区域截取出来，单独进行反转，再拼接回去。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> reverseBetween = <span class="hljs-keyword">function</span>(<span class="hljs-params">head, left, right</span>) &#123;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">reverse</span>(<span class="hljs-params">head</span>)&#123;<br>        <span class="hljs-keyword">if</span>(!head || !head.<span class="hljs-property">next</span>)&#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        <span class="hljs-keyword">let</span> last = <span class="hljs-title function_">reverse</span>(head.<span class="hljs-property">next</span>);<br>        head.<span class="hljs-property">next</span>.<span class="hljs-property">next</span> = head;<br>        head.<span class="hljs-property">next</span> = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">return</span> last;<br>    &#125;<br>    <span class="hljs-keyword">const</span> fistnode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>    fistnode.<span class="hljs-property">next</span> = head;<br>    <span class="hljs-keyword">let</span> pre = fistnode;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;left-<span class="hljs-number">1</span>;i++)&#123;<br>        pre = pre.<span class="hljs-property">next</span>;<br>    &#125;<br>    <span class="hljs-keyword">let</span> rightnode = pre;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;right-left+<span class="hljs-number">1</span>;i++)&#123;<br>        rightnode = rightnode.<span class="hljs-property">next</span>;<br>    &#125;<br>    <span class="hljs-keyword">let</span> leftnode = pre.<span class="hljs-property">next</span>;<br>    <span class="hljs-keyword">let</span> curr=rightnode.<span class="hljs-property">next</span>;<br>    pre.<span class="hljs-property">next</span>=<span class="hljs-literal">null</span>;<br>    rightnode.<span class="hljs-property">next</span>=<span class="hljs-literal">null</span>;<br>    pre.<span class="hljs-property">next</span>=<span class="hljs-title function_">reverse</span>(leftnode);<br>    leftnode.<span class="hljs-property">next</span>=curr;<br>    <span class="hljs-keyword">return</span> fistnode.<span class="hljs-property">next</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>链表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>206.反转链表</title>
    <link href="/2022/06/17/206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <url>/2022/06/17/206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。<br>输入：head &#x3D; [1,2,3,4,5]<br>输出：[5,4,3,2,1]</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>当head为空，直接返回。<br>当head下一个节点没有时，为末尾节点，直接返回。<br>last指的是翻转后的头结点（原尾结点）。<br>head.next.next指的是已经翻转结点的末尾下一个指向自己。<br> <img src="/2022/06/17/206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8.png" class=""></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> reverseList = <span class="hljs-keyword">function</span>(<span class="hljs-params">head</span>) &#123;<br>    <span class="hljs-keyword">if</span>(!head || !head.<span class="hljs-property">next</span>)&#123;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>    <span class="hljs-keyword">let</span> last = <span class="hljs-title function_">reverseList</span>(head.<span class="hljs-property">next</span>);<br>    head.<span class="hljs-property">next</span>.<span class="hljs-property">next</span>=head;<br>    head.<span class="hljs-property">next</span>=<span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">return</span> last;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>链表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>160.【双指针】相交链表</title>
    <link href="/2022/06/16/160-%E3%80%90%E5%8F%8C%E6%8C%87%E9%92%88%E3%80%91%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/"/>
    <url>/2022/06/16/160-%E3%80%90%E5%8F%8C%E6%8C%87%E9%92%88%E3%80%91%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。<br>输入：intersectVal &#x3D; 8, listA &#x3D; [4,1,8,4,5], listB &#x3D; [5,6,1,8,4,5], skipA &#x3D; 2, skipB &#x3D; 3<br>输出：Intersected at ‘8’<br>解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。<br>从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。<br>在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>如果两个链表都不为空，且相交，则有两个结点分别从两个链表上开始，当到达结尾时跳到另一个链表上，就能同时在交点相遇。<br> <img src="/2022/06/16/160-%E3%80%90%E5%8F%8C%E6%8C%87%E9%92%88%E3%80%91%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/%E9%93%BE%E8%A1%A8.png" class=""></p><p>如果不相遇，在各自走完一圈后同时到达null，结束。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> getIntersectionNode = <span class="hljs-keyword">function</span>(<span class="hljs-params">headA, headB</span>) &#123;<br>    <span class="hljs-keyword">if</span>(!headA || !headB)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-keyword">let</span> pA = headA, pB = headB;<br>    <span class="hljs-keyword">while</span>(pA!==pB)&#123;<br>        pA=pA===<span class="hljs-literal">null</span>?<span class="hljs-attr">headB</span>:pA.<span class="hljs-property">next</span>;<br>        pB=pB===<span class="hljs-literal">null</span>?<span class="hljs-attr">headA</span>:pB.<span class="hljs-property">next</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> pA;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>链表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>142.【双指针】环形链表2</title>
    <link href="/2022/06/16/142-%E3%80%90%E5%8F%8C%E6%8C%87%E9%92%88%E3%80%91%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A82/"/>
    <url>/2022/06/16/142-%E3%80%90%E5%8F%8C%E6%8C%87%E9%92%88%E3%80%91%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A82/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。<br>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。<br>不允许修改 链表。</p><p>输入：head &#x3D; [3,2,0,-4], pos &#x3D; 1<br>输出：返回索引为 1 的链表节点<br>解释：链表中有一个环，其尾部连接到第二个节点。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>直接先用一个一次走两步的快结点个一次走一步的慢结点同时从原点出发，若相遇则存在环。<br> <img src="/2022/06/16/142-%E3%80%90%E5%8F%8C%E6%8C%87%E9%92%88%E3%80%91%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A82/%E7%8E%AF.png" class=""><br>当相遇时，慢的走了a+b，快的走了a+n(b+c)+b&#x3D;a+(n+1)b+c，<br>a+(n+1)b+c&#x3D;2(a+b)<br>a&#x3D;c+(n-1)(b+c);<br>因此，若此时再从出发点开始一个结点，和c一起每次走1步，最后它们会在交点相遇。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> detectCycle = <span class="hljs-keyword">function</span>(<span class="hljs-params">head</span>) &#123;<br>        <span class="hljs-keyword">if</span> (head === <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-keyword">let</span> slow = head, fast = head;<br>    <span class="hljs-keyword">while</span> (fast !== <span class="hljs-literal">null</span>) &#123;<br>        slow = slow.<span class="hljs-property">next</span>;<br>        <span class="hljs-keyword">if</span> (fast.<span class="hljs-property">next</span> !== <span class="hljs-literal">null</span>) &#123;<br>            fast = fast.<span class="hljs-property">next</span>.<span class="hljs-property">next</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (fast === slow) &#123;<br>            <span class="hljs-keyword">let</span> ptr = head;<br>            <span class="hljs-keyword">while</span> (ptr !== slow) &#123;<br>                ptr = ptr.<span class="hljs-property">next</span>;<br>                slow = slow.<span class="hljs-property">next</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> ptr;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>链表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>141.【双指针】环形链表</title>
    <link href="/2022/06/16/141-%E3%80%90%E5%8F%8C%E6%8C%87%E9%92%88%E3%80%91%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/"/>
    <url>/2022/06/16/141-%E3%80%90%E5%8F%8C%E6%8C%87%E9%92%88%E3%80%91%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个链表的头节点 head ，判断链表中是否有环。<br>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。<br>如果链表中存在环 ，则返回 true 。 否则，返回 false 。<br>输入：head &#x3D; [3,2,0,-4], pos &#x3D; 1<br>输出：true<br>解释：链表中有一个环，其尾部连接到第二个节点。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>因为链表的环并不一定指向头结点，因此最快的判断方法还是用两个指针，一个一次跑一步，一个一次跑两步。如果跑到空，那就没有环，否则，相遇时有环。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> hasCycle = <span class="hljs-keyword">function</span>(<span class="hljs-params">head</span>) &#123;<br>    <span class="hljs-keyword">let</span> fast=head, slow=head;<br>    <span class="hljs-keyword">while</span>(fast)&#123;<br>        <span class="hljs-keyword">if</span>(!fast.<span class="hljs-property">next</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            fast = fast.<span class="hljs-property">next</span>.<span class="hljs-property">next</span>;<br>            slow = slow.<span class="hljs-property">next</span>;<br>            <span class="hljs-keyword">if</span>(fast===slow)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>链表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>876.【双指针】链表的中间结点</title>
    <link href="/2022/06/16/876-%E3%80%90%E5%8F%8C%E6%8C%87%E9%92%88%E3%80%91%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E7%BB%93%E7%82%B9/"/>
    <url>/2022/06/16/876-%E3%80%90%E5%8F%8C%E6%8C%87%E9%92%88%E3%80%91%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E7%BB%93%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个头结点为 head 的非空单链表，返回链表的中间结点。如果有两个中间结点，则返回第二个中间结点。<br>输入：[1,2,3,4,5]<br>输出：此列表中的结点 3 (序列化形式：[3,4,5])<br>返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。<br>注意，我们返回了一个 ListNode 类型的对象 ans，这样：<br>ans.val &#x3D; 3, ans.next.val &#x3D; 4, ans.next.next.val &#x3D; 5, 以及 ans.next.next.next &#x3D; NULL.</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>分别设置两个指针指向初始结点，然后第一个结点一次走一步，第二个结点一次走两步，当第二个结点到末尾的时候，第一个结点就是中心结点。<br>①若第二个结点到1+2n为尾，此时第一个节点在n+1，第二个结点往后为空，直接停止走。<br>②若第二个结点在走到2n-1，再走一步就到尾，此时第一个节点到n+1为中心，此时两个结点都往后走，直接第二个结点所处位置判空。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> middleNode = <span class="hljs-keyword">function</span>(<span class="hljs-params">head</span>) &#123;<br>    <span class="hljs-keyword">let</span> fast = head, slow = head;<br>    <span class="hljs-keyword">while</span>(fast.<span class="hljs-property">next</span>)&#123;<br>        fast = fast.<span class="hljs-property">next</span>.<span class="hljs-property">next</span>;<br>        slow = slow.<span class="hljs-property">next</span>;<br>        <span class="hljs-keyword">if</span>(!fast)&#123;<br>            <span class="hljs-keyword">return</span> slow;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> slow;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>链表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>19.【双指针】删除链表的倒数第N个结点</title>
    <link href="/2022/06/16/19-%E3%80%90%E5%8F%8C%E6%8C%87%E9%92%88%E3%80%91%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E7%BB%93%E7%82%B9/"/>
    <url>/2022/06/16/19-%E3%80%90%E5%8F%8C%E6%8C%87%E9%92%88%E3%80%91%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E7%BB%93%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。<br>输入：head &#x3D; [1,2,3,4,5], n &#x3D; 2<br>输出：[1,2,3,5]</p><p>链表中结点的数目为 sz<br>1 &lt;&#x3D; sz &lt;&#x3D; 30<br>0 &lt;&#x3D; Node.val &lt;&#x3D; 100<br>1 &lt;&#x3D; n &lt;&#x3D; sz</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>直接用两个指针，一个指向第一个，一个指向第n个，并一起向后移动。当后一个指针指向最后一个结点时，前一个指针指向倒数第n个结点。<br>由于是删除倒数第n个，所以直接找倒数第n+1个。如果在开始时找第二个结点时其已经超过最后一个结点，则直接删除第一个节点。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> removeNthFromEnd = <span class="hljs-keyword">function</span>(<span class="hljs-params">head, n</span>) &#123;<br>    <span class="hljs-keyword">let</span> fast=head, slow=head;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        fast = fast.<span class="hljs-property">next</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(!fast)&#123;<br>        <span class="hljs-keyword">return</span> slow.<span class="hljs-property">next</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(fast.<span class="hljs-property">next</span>)&#123;<br>        fast = fast.<span class="hljs-property">next</span>;<br>        slow = slow.<span class="hljs-property">next</span>;<br>    &#125;<br>    slow.<span class="hljs-property">next</span> = slow.<span class="hljs-property">next</span>.<span class="hljs-property">next</span>;<br>    <span class="hljs-keyword">return</span> head;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>链表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>86.分隔链表</title>
    <link href="/2022/06/16/86-%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8/"/>
    <url>/2022/06/16/86-%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个链表的头节点 head 和一个特定值 x ，请你对链表进行分隔，使得所有 小于 x 的节点都出现在 大于或等于 x 的节点之前。<br>你应当保留两个分区中每个节点的初始相对位置。<br>输入：head &#x3D; [1,4,3,2,5,2], x &#x3D; 3<br>输出：[1,2,2,4,3,5]</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>分别构建两个链表，储存大于x和小于x的节点，然后将它们连在一起。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> partition = <span class="hljs-keyword">function</span>(<span class="hljs-params">head, x</span>) &#123;<br>    <span class="hljs-keyword">let</span> small=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">let</span> big=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">const</span> smallHead=small, bigHead=big;<br>    <span class="hljs-keyword">while</span>(head)&#123;<br>        <span class="hljs-keyword">if</span>(head.<span class="hljs-property">val</span>&lt;x)&#123;<br>            small.<span class="hljs-property">next</span>=head;<br>            small=small.<span class="hljs-property">next</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            big.<span class="hljs-property">next</span>=head;<br>            big=big.<span class="hljs-property">next</span>;<br>        &#125;<br>        head=head.<span class="hljs-property">next</span>;<br>    &#125;<br>    big.<span class="hljs-property">next</span>=<span class="hljs-literal">null</span>;<br>    small.<span class="hljs-property">next</span>=bigHead.<span class="hljs-property">next</span>;<br>    <span class="hljs-keyword">return</span> smallHead.<span class="hljs-property">next</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>链表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21.合并两个有序链表</title>
    <link href="/2022/06/16/21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <url>/2022/06/16/21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><p>输入：l1 &#x3D; [1,2,4], l2 &#x3D; [1,3,4]<br>输出：[1,1,2,3,4,4]</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>放一个头节点和尾节点，开始让它们指向相同位置。然后头结点不动，尾结点一直变为下一个要插入的节点。<br><strong>给头节点随便设置一个初始值，最后返回它的下一个节点，就不用专门去找第一个节点</strong></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> mergeTwoLists = <span class="hljs-keyword">function</span>(<span class="hljs-params">list1, list2</span>) &#123;<br>    <span class="hljs-keyword">let</span> head=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">101</span>);<br>    <span class="hljs-keyword">let</span> next=head;<br>    <span class="hljs-keyword">while</span>(list1 &amp;&amp; list2)&#123;<br>        <span class="hljs-keyword">if</span>(list1.<span class="hljs-property">val</span>&gt;list2.<span class="hljs-property">val</span>)&#123;<br>            next.<span class="hljs-property">next</span> = list2;<br>            list2 = list2.<span class="hljs-property">next</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            next.<span class="hljs-property">next</span> = list1;<br>            list1 = list1.<span class="hljs-property">next</span>;<br>        &#125;<br>        next = next.<span class="hljs-property">next</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(list1)&#123;<br>        next.<span class="hljs-property">next</span> = list1;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(list2)&#123;<br>        next.<span class="hljs-property">next</span> = list2;<br>    &#125;<br>    <span class="hljs-keyword">return</span> head.<span class="hljs-property">next</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>链表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>222.完全二叉树的节点个数</title>
    <link href="/2022/06/16/222-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0/"/>
    <url>/2022/06/16/222-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。<br>完全二叉树 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点<br>输入：root &#x3D; [1,2,3,4,5,6]<br>输出：6</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>将完全二叉树从中间分开，只有两种情况：<br>①左子树为满二叉树，右子树为完全二叉树。<br>②左右子树均为满二叉树。<br>直接求做子树最左边深度和右子树最右边深度即可判断是否为满二叉树。<br>①左深右浅，左满右不满。<br>②左等于右，全为满。<br>满二叉树直接用2^n-1求，n为高度。完全二叉树递归求数量。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> countNodes = <span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) &#123;<br>    <span class="hljs-keyword">let</span> left=root,right=root;<br>    <span class="hljs-keyword">let</span> h1=<span class="hljs-number">0</span>,h2=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(left)&#123;<br>        left = left.<span class="hljs-property">left</span>;<br>        h1++;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(right)&#123;<br>        right = right.<span class="hljs-property">right</span>;<br>        h2++;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(h1==h2)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>(<span class="hljs-number">2</span>,h1)-<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + <span class="hljs-title function_">countNodes</span>(root.<span class="hljs-property">left</span>) + <span class="hljs-title function_">countNodes</span>(root.<span class="hljs-property">right</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>236.【最近公共祖先】二叉树的最近公共祖先</title>
    <link href="/2022/06/16/236-%E3%80%90%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%E3%80%91%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"/>
    <url>/2022/06/16/236-%E3%80%90%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%E3%80%91%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”<br>输入：root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 1<br>输出：3<br>解释：节点 5 和节点 1 的最近公共祖先是节点 3 。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>直接进行递归，从根结点判断左右子树是否含有指定节点。有几种情况<br>①两个节点分别在根节点左右子树上，则根节点是最近公共祖先。<br>②若根节点为一个目标节点，另一个节点在左子树或右子树上。<br>只有满足这些条件的才是最近公共祖先，将其返回。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> lowestCommonAncestor = <span class="hljs-keyword">function</span>(<span class="hljs-params">root, p, q</span>) &#123;<br>    <span class="hljs-keyword">let</span> ans;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">root,p,q</span>)&#123;<br>        <span class="hljs-keyword">if</span>(!root)<br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">const</span> left = <span class="hljs-title function_">dfs</span>(root.<span class="hljs-property">left</span>, p, q);<br>            <span class="hljs-keyword">const</span> right = <span class="hljs-title function_">dfs</span>(root.<span class="hljs-property">right</span>, p ,q);<br>            <span class="hljs-keyword">if</span>((left&amp;&amp;right)||((root.<span class="hljs-property">val</span>===p.<span class="hljs-property">val</span> || root.<span class="hljs-property">val</span>===q.<span class="hljs-property">val</span>)&amp;&amp;(left||right)))&#123;<br>                ans = root;<br>            &#125;<br>            <span class="hljs-keyword">return</span> left || right || root.<span class="hljs-property">val</span>===p.<span class="hljs-property">val</span> || root.<span class="hljs-property">val</span>===q.<span class="hljs-property">val</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-title function_">dfs</span>(root,p,q);<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>235.【最近公共祖先】二叉树的最近公共祖先</title>
    <link href="/2022/06/16/235-%E3%80%90%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%E3%80%91%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"/>
    <url>/2022/06/16/235-%E3%80%90%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%E3%80%91%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。<br>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p>输入: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5], p &#x3D; 2, q &#x3D; 8<br>输出: 6<br>解释: 节点 2 和节点 8 的最近公共祖先是 6。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>对于二叉搜索树来说，直接比较两个节点的值和根节点的值的关系。如果一大一小，则根节点为最近公共祖先；如果都小，则都在左子树上；如果都大，则都在右子树上。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> lowestCommonAncestor = <span class="hljs-keyword">function</span>(<span class="hljs-params">root, p, q</span>) &#123;<br>    <span class="hljs-keyword">if</span>(p.<span class="hljs-property">val</span>&lt;root.<span class="hljs-property">val</span>&amp;&amp;q.<span class="hljs-property">val</span>&lt;root.<span class="hljs-property">val</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">lowestCommonAncestor</span>(root.<span class="hljs-property">left</span>,p,q);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(p.<span class="hljs-property">val</span>&gt;root.<span class="hljs-property">val</span>&amp;&amp;q.<span class="hljs-property">val</span>&gt;root.<span class="hljs-property">val</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">lowestCommonAncestor</span>(root.<span class="hljs-property">right</span>,p,q);<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>341.【DFS】扁平化嵌套列表迭代器</title>
    <link href="/2022/06/15/341-%E3%80%90DFS%E3%80%91%E6%89%81%E5%B9%B3%E5%8C%96%E5%B5%8C%E5%A5%97%E5%88%97%E8%A1%A8%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
    <url>/2022/06/15/341-%E3%80%90DFS%E3%80%91%E6%89%81%E5%B9%B3%E5%8C%96%E5%B5%8C%E5%A5%97%E5%88%97%E8%A1%A8%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个嵌套的整数列表 nestedList 。每个元素要么是一个整数，要么是一个列表；该列表的元素也可能是整数或者是其他列表。请你实现一个迭代器将其扁平化，使之能够遍历这个列表中的所有整数。<br>实现扁平迭代器类 NestedIterator ：<br>NestedIterator(List<NestedInteger> nestedList) 用嵌套列表 nestedList 初始化迭代器。<br>int next() 返回嵌套列表的下一个整数。<br>boolean hasNext() 如果仍然存在待迭代的整数，返回 true ；否则，返回 false 。<br>你的代码将会用下述伪代码检测：<br>initialize iterator with nestedList<br>res &#x3D; []<br>while iterator.hasNext()<br>    append iterator.next() to the end of res<br>return res<br>如果 res 与预期的扁平化列表匹配，那么你的代码将会被判为正确。<br>输入：nestedList &#x3D; [[1,1],2,[1,1]]<br>输出：[1,1,2,1,1]<br>解释：通过重复调用 next 直到 hasNext 返回 false，next 返回的元素的顺序应该是: [1,1,2,1,1]。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>深度遍历数组，若遇到整数，加入到队列。若遇到数组，以该数组为起点进行遍历。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> <span class="hljs-title class_">NestedIterator</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">nestedList</span>) &#123;<br>    res=[];<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">nestedList</span>)&#123;<br>        <span class="hljs-keyword">for</span>(n <span class="hljs-keyword">of</span> nestedList)&#123;<br>            <span class="hljs-keyword">if</span>(n.<span class="hljs-title function_">isInteger</span>())&#123;<br>                res.<span class="hljs-title function_">push</span>(n.<span class="hljs-title function_">getInteger</span>());<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-title function_">dfs</span>(n.<span class="hljs-title function_">getList</span>());<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-title function_">dfs</span>(nestedList);<br>&#125;;<br><span class="hljs-title class_">NestedIterator</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">hasNext</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> res.<span class="hljs-property">length</span>&gt;<span class="hljs-number">0</span>;<br>&#125;;<br><span class="hljs-title class_">NestedIterator</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">next</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">shift</span>();<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>数组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>215.【堆排序】数组中的第K个最大元素</title>
    <link href="/2022/06/14/215-%E3%80%90%E5%A0%86%E6%8E%92%E5%BA%8F%E3%80%91%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/"/>
    <url>/2022/06/14/215-%E3%80%90%E5%A0%86%E6%8E%92%E5%BA%8F%E3%80%91%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p><p>输入: [3,2,1,5,6,4] 和 k &#x3D; 2<br>输出: 5</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>首先，从数组中间往前开始，依次遍历每个点，构建大顶堆。<br>然后，将堆顶（最大数）与数组末尾进行交换，将数组末尾之前的重置为大顶堆，再看倒数第二个….直到倒数第k个。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> findKthLargest = <span class="hljs-keyword">function</span>(<span class="hljs-params">nums, k</span>) &#123;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">heapify</span>(<span class="hljs-params">arr,x,len</span>)&#123;<br>        <span class="hljs-keyword">var</span> l=<span class="hljs-number">2</span>*x+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">var</span> r=<span class="hljs-number">2</span>*x+<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">var</span> largest=x;<br>        <span class="hljs-keyword">var</span> temp;<br>        <span class="hljs-keyword">if</span>(l&lt;len&amp;&amp;arr[l]&gt;arr[largest])&#123;<br>            largest=l;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(r&lt;len&amp;&amp;arr[r]&gt;arr[largest])&#123;<br>            largest=r;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(largest!=x)&#123;<br>            [arr[x],arr[largest]] = [arr[largest],arr[x]];<br>            <span class="hljs-title function_">heapify</span>(arr,largest,len);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">var</span> heapSize = nums.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(heapSize/<span class="hljs-number">2</span>)-<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>        <span class="hljs-title function_">heapify</span>(nums,i,heapSize);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j=heapSize-<span class="hljs-number">1</span>;j&gt;=heapSize-k;j--)&#123;<br>        [nums[<span class="hljs-number">0</span>],nums[j]] = [nums[j],nums[<span class="hljs-number">0</span>]];<br>        <span class="hljs-title function_">heapify</span>(nums,<span class="hljs-number">0</span>,j);<br>    &#125;<br>    <span class="hljs-keyword">return</span> nums[heapSize-k];<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>排序算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>95.【二叉搜索树】不同的二叉搜索树2</title>
    <link href="/2022/06/14/95-%E3%80%90%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E3%80%91%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%912/"/>
    <url>/2022/06/14/95-%E3%80%90%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E3%80%91%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%912/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数 n ，请你生成并返回所有由 n 个节点组成且节点值从 1 到 n 互不相同的不同 二叉搜索树 。可以按 任意顺序 返回答案。<br>输入：n &#x3D; 3<br>输出：[[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>以1到n每个节点作为根节点，划分后的左右数组作为左右子树，构建二叉树。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> generateTrees = <span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>) &#123;<br>    <span class="hljs-keyword">if</span>(n===<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span> [];<br>    &#125;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">getAllTrees</span>(<span class="hljs-params">low,high</span>)&#123;<br>        <span class="hljs-keyword">if</span>(low&gt;high)&#123;<br>            <span class="hljs-keyword">return</span> [<span class="hljs-literal">null</span>];<br>        &#125;<br>        <span class="hljs-keyword">if</span>(low===high)&#123;<br>            <span class="hljs-keyword">return</span> [<span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(low)];<br>        &#125;<br>        <span class="hljs-keyword">const</span> res=[];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=low;i&lt;=high;i++)&#123;<br>            <span class="hljs-keyword">const</span> leftTrees = <span class="hljs-title function_">getAllTrees</span>(low,i-<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">const</span> rightTrees = <span class="hljs-title function_">getAllTress</span>(i+<span class="hljs-number">1</span>,high);<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> leftress <span class="hljs-keyword">of</span> leftTrees)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> rightress <span class="hljs-keyword">of</span> rightTrees)&#123;<br>                    <span class="hljs-keyword">const</span> root = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(i);<br>                    root.<span class="hljs-property">left</span> = leftress;<br>                    root.<span class="hljs-property">right</span> = rightress;<br>                    res.<span class="hljs-title function_">push</span>(root);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">getAllTrees</span>(<span class="hljs-number">1</span>,n);<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>96.【二叉搜索树】不同的二叉搜索树</title>
    <link href="/2022/06/14/96-%E3%80%90%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E3%80%91%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <url>/2022/06/14/96-%E3%80%90%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E3%80%91%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。</p><p>输入：n &#x3D; 3<br>输出：5</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>先从1到n中选择一个数a作为根节点，并求其左子树1<del>a-1和右子树a+1</del>n的种树，然后再相乘。接着，把a从1到n的所有情况的种树相加。<br>F(i,n)是以i为根序列长为n的种树，G(n)是长度为n的序列能构成不同二叉搜索树的个数。<br>G(n)&#x3D;所有F(i,n)相加，G(0)&#x3D;G(1)&#x3D;1。<br>F(i,n)&#x3D;G(i-1)*G(n-i)</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> numTrees = <span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>) &#123;<br>    <span class="hljs-keyword">const</span> g = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(n+<span class="hljs-number">1</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>);<br>    g[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    g[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j=<span class="hljs-number">1</span>;j&lt;=i;j++)&#123;<br>            g[i] += g[j-<span class="hljs-number">1</span>]*g[i-j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> g[n];<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>450.【二叉搜索树】删除二叉搜索树中的节点</title>
    <link href="/2022/06/14/450-%E3%80%90%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E3%80%91%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/"/>
    <url>/2022/06/14/450-%E3%80%90%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E3%80%91%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p><p>一般来说，删除节点可分为两个步骤：<br>首先找到需要删除的节点；<br>如果找到了，删除它。</p><p>输入：root &#x3D; [5,3,6,2,4,null,7], key &#x3D; 3<br>输出：[5,4,6,2,null,null,7]<br>解释：给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。<br>一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。<br>另一个正确答案是 [5,2,6,null,4,null,7]。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>分情况进行判断：<br>1.若根节点为空，返回空指针。<br>2.若key小于根节点的值，则要删除的节点在左子树中，左子树等于删除后的左子树。<br>3.若key大于根节点的值，则要删除的节点在右子树中，右子树等于删除后的右子树。<br>4.若key等于根节点：<br>①若左子树为空，直接删除自己，返回右子树。<br>②若右子树为空，直接删除自己，返回左子树。<br>@左右子树都不为空，可以去找右子树的最小节点来与根节点交换，然后再将其删除。先在右子树上找到最小节点，然后使root的右子树等于删除最小节点后的状态，再将最小节点的左右子树指向root的左右子树，然后将root指向最小节点，并返回。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> deleteNode = <span class="hljs-keyword">function</span>(<span class="hljs-params">root, key</span>) &#123;<br>    <span class="hljs-keyword">if</span>(!root)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(root.<span class="hljs-property">val</span> === key)&#123;<br>        <span class="hljs-keyword">if</span>(!root.<span class="hljs-property">left</span>)&#123;<br>            <span class="hljs-keyword">return</span> root.<span class="hljs-property">right</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!root.<span class="hljs-property">right</span>)&#123;<br>            <span class="hljs-keyword">return</span> root.<span class="hljs-property">left</span>;<br>        &#125;<br>        <span class="hljs-keyword">let</span> node = root.<span class="hljs-property">right</span>;        <br>        <span class="hljs-keyword">while</span>(node.<span class="hljs-property">left</span>)&#123;<br>            node = node.<span class="hljs-property">left</span>;<br>        &#125;<br>        root.<span class="hljs-property">right</span> = <span class="hljs-title function_">deleteNode</span>(root.<span class="hljs-property">right</span>, node.<span class="hljs-property">val</span>);<br>        node.<span class="hljs-property">left</span> = root.<span class="hljs-property">left</span>;<br>        node.<span class="hljs-property">right</span> = root.<span class="hljs-property">right</span>;<br>        root = node;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root.<span class="hljs-property">val</span>&gt;key)&#123;<br>        root.<span class="hljs-property">left</span> = <span class="hljs-title function_">deleteNode</span>(root.<span class="hljs-property">left</span>,key);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root.<span class="hljs-property">val</span>&lt;key)&#123;<br>        root.<span class="hljs-property">right</span> = <span class="hljs-title function_">deleteNode</span>(root.<span class="hljs-property">right</span>,key);<br>    &#125;<br>    <span class="hljs-keyword">return</span> root;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>701.【二叉搜索树】二叉搜索树中的插入操作</title>
    <link href="/2022/06/14/701-%E3%80%90%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E3%80%91%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C/"/>
    <url>/2022/06/14/701-%E3%80%90%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E3%80%91%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定二叉搜索树（BST）的根节点 root 和要插入树中的值 value ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 保证 ，新值和原始二叉搜索树中的任意节点值都不同。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>遍历，若值大于根节点，往右子树上插入，若小于，则往左子树上插入。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> insertIntoBST = <span class="hljs-keyword">function</span>(<span class="hljs-params">root, val</span>) &#123;<br>    <span class="hljs-keyword">if</span>(!root)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(val);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(val&lt;root.<span class="hljs-property">val</span>)&#123;<br>        root.<span class="hljs-property">left</span> = <span class="hljs-title function_">insertIntoBST</span>(root.<span class="hljs-property">left</span>,val);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(val&gt;root.<span class="hljs-property">val</span>)&#123;<br>        root.<span class="hljs-property">right</span> = <span class="hljs-title function_">insertIntoBST</span>(root.<span class="hljs-property">right</span>,val);<br>    &#125;<br>    <span class="hljs-keyword">return</span> root;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>700.【二叉搜索树】二叉搜索树中的搜索</title>
    <link href="/2022/06/13/700-%E3%80%90%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E3%80%91%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2/"/>
    <url>/2022/06/13/700-%E3%80%90%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E3%80%91%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定二叉搜索树（BST）的根节点 root 和一个整数值 val。<br>你需要在 BST 中找到节点值等于 val 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 null。</p><p>输入：root &#x3D; [4,2,7,1,3], val &#x3D; 2<br>输出：[2,1,3]</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> searchBST = <span class="hljs-keyword">function</span>(<span class="hljs-params">root, val</span>) &#123;<br>    <span class="hljs-keyword">if</span>(!root)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(val===root.<span class="hljs-property">val</span>)&#123;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">searchBST</span>(val&lt;root.<span class="hljs-property">val</span> ? root.<span class="hljs-property">left</span> : root.<span class="hljs-property">right</span>, val);<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>98.【二叉搜索树】验证二叉搜索树</title>
    <link href="/2022/06/13/98-%E3%80%90%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E3%80%91%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <url>/2022/06/13/98-%E3%80%90%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E3%80%91%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。<br>有效 二叉搜索树定义如下：<br>节点的左子树只包含 小于 当前节点的数。<br>节点的右子树只包含 大于 当前节点的数。<br>所有左子树和右子树自身必须也是二叉搜索树。</p><p>输入：root &#x3D; [2,1,3]<br>输出：true</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>中序遍历二叉树，得到一个递增序列，判断是否严格递增。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> isValidBST = <span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) &#123;<br>    <span class="hljs-keyword">let</span> just = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">let</span> nums = [];<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">visited</span>(<span class="hljs-params">root</span>)&#123;<br>        <span class="hljs-keyword">if</span>(!root)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-title function_">visited</span>(root.<span class="hljs-property">left</span>);<br>        nums.<span class="hljs-title function_">push</span>(root.<span class="hljs-property">val</span>);<br>        <span class="hljs-title function_">visited</span>(root.<span class="hljs-property">right</span>);<br>    &#125;<br>    <span class="hljs-title function_">visited</span>(root);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-property">length</span>-<span class="hljs-number">1</span>;i++)&#123;<br>        <span class="hljs-keyword">if</span>(nums[i+<span class="hljs-number">1</span>]&lt;=nums[i])&#123;<br>            just = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> just;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>538.【二叉搜索树】把二叉搜索树转换为累加树</title>
    <link href="/2022/06/13/538-%E3%80%90%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E3%80%91%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91/"/>
    <url>/2022/06/13/538-%E3%80%90%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E3%80%91%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。<br>输入：[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]<br>输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>直接从右、中、左进行遍历，累积求和。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> convertBST = <span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) &#123;<br>    <span class="hljs-keyword">let</span> sum=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">newval</span>(<span class="hljs-params">root</span>)&#123;<br>        <span class="hljs-keyword">if</span>(!root)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-title function_">newval</span>(root.<span class="hljs-property">right</span>);<br>        sum=sum+root.<span class="hljs-property">val</span>;<br>        root.<span class="hljs-property">val</span>=sum;<br>        <span class="hljs-title function_">newval</span>(root.<span class="hljs-property">left</span>);<br>    &#125;<br>    <span class="hljs-title function_">newval</span>(root);<br>    <span class="hljs-keyword">return</span> root;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>230.【二叉搜索树】二叉搜索树中第k小的元素</title>
    <link href="/2022/06/13/230-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACk%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0/"/>
    <url>/2022/06/13/230-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACk%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个二叉搜索树的根节点 root ，和一个整数 k ，请你设计一个算法查找其中第 k 个最小元素（从 1 开始计数）</p><p>输入：root &#x3D; [3,1,4,null,2], k &#x3D; 1<br>输出：1</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>直接中序遍历，每访问一个节点k就减去1，直到k为0。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> kthSmallest = <span class="hljs-keyword">function</span>(<span class="hljs-params">root, k</span>) &#123; <br>    <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>; <br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">visited</span>(<span class="hljs-params">root</span>)&#123; <br>        <span class="hljs-keyword">if</span>(!root)&#123; <br>            <span class="hljs-keyword">return</span>; <br>        &#125; <br>        <span class="hljs-keyword">else</span>&#123; <br>            <span class="hljs-title function_">visited</span>(root.<span class="hljs-property">left</span>); <br>            <span class="hljs-keyword">if</span>(k===<span class="hljs-number">0</span>)&#123; <br>                <span class="hljs-keyword">return</span>; <br>            &#125; <br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(k===<span class="hljs-number">1</span>)&#123; <br>                res=root.<span class="hljs-property">val</span>; k--; <br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123; <br>                k--; <br>                <span class="hljs-title function_">visited</span>(root.<span class="hljs-property">right</span>); <br>            &#125; <br>         &#125; <br>    &#125; <br>    <span class="hljs-title function_">visited</span>(root); <br>    <span class="hljs-keyword">return</span> res; <br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>912.排序数组</title>
    <link href="/2022/06/12/912-%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
    <url>/2022/06/12/912-%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数数组 nums，请你将该数组升序排列。</p><p>输入：nums &#x3D; [5,2,3,1]<br>输出：[1,2,3,5]</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>归并排序：二分，各自排序，再合并排序。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> sortArray = <span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) &#123;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">binarySort</span>(<span class="hljs-params">left,right</span>)&#123;<br>        <span class="hljs-keyword">if</span>(left===right)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">const</span> mid = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((left+right)/<span class="hljs-number">2</span>);<br>            <span class="hljs-title function_">binarySort</span>(left,mid);<br>            <span class="hljs-title function_">binarySort</span>(mid+<span class="hljs-number">1</span>,right);<br>            <span class="hljs-keyword">let</span> i = left;<br>            <span class="hljs-keyword">let</span> j = mid+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">let</span> p = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">let</span> sorted = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(right-left+<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">while</span>(i&lt;=mid||j&lt;=right)&#123;<br>                <span class="hljs-keyword">if</span>(i&gt;mid)&#123;<br>                    sorted[p++] = nums[j++];<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j&gt;right)&#123;<br>                    sorted[p++] = nums[i++];<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[i]&lt;nums[j])<br>                &#123;<br>                    sorted[p++] = nums[i++];<br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    sorted[p++] = nums[j++];<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;sorted.<span class="hljs-property">length</span>;i++)&#123;<br>                nums[left+i] = sorted[i];<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-title function_">binarySort</span>(<span class="hljs-number">0</span>,nums.<span class="hljs-property">length</span>-<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> nums;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>排序算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>327.【归并排序】区间和的个数</title>
    <link href="/2022/06/12/327-%E5%8C%BA%E9%97%B4%E5%92%8C%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
    <url>/2022/06/12/327-%E5%8C%BA%E9%97%B4%E5%92%8C%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数数组 nums 以及两个整数 lower 和 upper 。求数组中，值位于范围 [lower, upper] （包含 lower 和 upper）之内的 区间和的个数 。<br>区间和 S(i, j) 表示在 nums 中，位置从 i 到 j 的元素之和，包含 i 和 j (i ≤ j)。</p><p>输入：nums &#x3D; [-2,5,-1], lower &#x3D; -2, upper &#x3D; 2<br>输出：3<br>解释：存在三个区间：[0,0]、[2,2] 和 [0,2] ，对应的区间和分别是：-2 、-1 、2 。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><strong>转化</strong>：先求以每个元素结尾到开头的区间和，这样问题就转化成了以j结尾的区间和与以i结尾的区间和差在指定范围内。<br>先求以每个元素结尾到开头的区间和数组sum。<strong>注意要加初始值0，因为如果只有一个数时，无法求差！！！</strong>。采用归并排序，将sum分为左右两个数组，先求左右数组满足条件的数量，然后对左右数组进行排序。接着从左数组第一个开始，从右数组第一个开始查找满足范围的，因为右数组是递增的，因此当出现不满足条件的时候，就进入左数组第二个，再从右数组第一个开始查找。求得这些数量后，对左右数组合并排序，再返回上一级。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> countRangeSum = <span class="hljs-keyword">function</span>(<span class="hljs-params">nums, lower, upper</span>) &#123;<br>    <span class="hljs-keyword">let</span> s = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">const</span> sum = [<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> v <span class="hljs-keyword">of</span> nums)&#123;<br>        s += v;<br>        sum.<span class="hljs-title function_">push</span>(s);<br>    &#125;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">countSum</span>(<span class="hljs-params">sum,left,right</span>)&#123;<br>        <span class="hljs-keyword">if</span>(left===right)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">const</span> mid = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((left+right)/<span class="hljs-number">2</span>);<br>            <span class="hljs-keyword">const</span> n1 = <span class="hljs-title function_">countSum</span>(sum,left,mid);<br>            <span class="hljs-keyword">const</span> n2 = <span class="hljs-title function_">countSum</span>(sum,mid+<span class="hljs-number">1</span>,right);<br>            <span class="hljs-keyword">let</span> res = n1 + n2;<br>            <span class="hljs-keyword">let</span> i = left;<br>            <span class="hljs-keyword">let</span> l = mid + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">let</span> r = mid + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span>(i&lt;=mid)&#123;<br>                <span class="hljs-keyword">while</span>(l&lt;=right&amp;&amp;sum[l]-sum[i]&lt;lower)&#123;<br>                    l++;<br>                &#125;<br>                <span class="hljs-keyword">while</span>(r&lt;=right&amp;&amp;sum[r]-sum[i]&lt;=upper)&#123;<br>                    r++;<br>                &#125;<br>                res += r-l;<br>                i++;<br>            &#125;<br>            <span class="hljs-keyword">const</span> sorted = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(right-left+<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">let</span> p1 = left, p2 = mid+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">let</span> p=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span>(p1&lt;=mid||p2&lt;=right)&#123;<br>                <span class="hljs-keyword">if</span>(p1&gt;mid)&#123;<br>                    sorted[p++]=sum[p2++];<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(p2&gt;right)&#123;<br>                    sorted[p++]=sum[p1++];<br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-keyword">if</span>(sum[p1]&lt;sum[p2])&#123;<br>                        sorted[p++]=sum[p1++];<br>                    &#125;<br>                    <span class="hljs-keyword">else</span>&#123;<br>                        sorted[p++]=sum[p2++];<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;sorted.<span class="hljs-property">length</span>;i++)&#123;<br>                sum[left+i] = sorted[i];<br>            &#125;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>    &#125;    <br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">countSum</span>(sum,<span class="hljs-number">0</span>,sum.<span class="hljs-property">length</span>-<span class="hljs-number">1</span>);<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>排序算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>493.【归并排序】翻转对</title>
    <link href="/2022/06/12/493-%E7%BF%BB%E8%BD%AC%E5%AF%B9/"/>
    <url>/2022/06/12/493-%E7%BF%BB%E8%BD%AC%E5%AF%B9/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个数组 nums ，如果 i &lt; j 且 nums[i] &gt; 2*nums[j] 我们就将 (i, j) 称作一个重要翻转对。</p><p>输入: [1,3,2,3,1]<br>输出: 2</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>采用归并排序的算法，每次将数组二分，然后分别对左右两边进行排序。<br>当前翻转对数量&#x3D;左侧原数量+右侧原数量+合并时左边每个对应右边时新增的数量。<br><strong>左右两边排序</strong>后，左侧从第一个开始，对应右侧从第一个开始一一进行检测，因为右侧是递增的当出现不满足条件的时候，立刻就可以左侧从第二个开始，再右侧从第一个开始一一检测。<br>最后，将左右两侧合并，再进行排序，并返回到上一级。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> reversePairs = <span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) &#123;<br>    <span class="hljs-keyword">if</span>(nums.<span class="hljs-property">length</span>===<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">reverseRecursive</span>(<span class="hljs-params">nums,left,right</span>)&#123;<br>        <span class="hljs-keyword">if</span>(left===right)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">const</span> mid = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((left+right)/<span class="hljs-number">2</span>);<br>            <span class="hljs-keyword">const</span> n1 = <span class="hljs-title function_">reverseRecursive</span>(nums,left,mid);<br>            <span class="hljs-keyword">const</span> n2 = <span class="hljs-title function_">reverseRecursive</span>(nums,mid+<span class="hljs-number">1</span>,right);<br>            <span class="hljs-keyword">let</span> res = n1 + n2<br>            <span class="hljs-keyword">let</span> i=left;<br>            <span class="hljs-keyword">let</span> j=mid+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span>(i&lt;=mid)&#123;<br>                <span class="hljs-keyword">while</span>(j&lt;=right&amp;&amp;nums[i]&gt;<span class="hljs-number">2</span>*nums[j])&#123;<br>                    j++;<br>                &#125;<br>                res += j-mid-<span class="hljs-number">1</span>;<br>                i++;<br>            &#125;<br>            <span class="hljs-keyword">const</span> sorted = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(right-left+<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">let</span> p1 = left, p2 = mid+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">let</span> p=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span>(p1&lt;=mid||p2&lt;=right)&#123;<br>                <span class="hljs-keyword">if</span>(p1&gt;mid)&#123;<br>                    sorted[p++]=nums[p2++];<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(p2&gt;right)&#123;<br>                    sorted[p++]=nums[p1++];<br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-keyword">if</span>(nums[p1]&lt;nums[p2])&#123;<br>                        sorted[p++] = nums[p1++];<br>                    &#125;<br>                    <span class="hljs-keyword">else</span>&#123;<br>                        sorted[p++] = nums[p2++];<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> k=<span class="hljs-number">0</span>;k&lt;sorted.<span class="hljs-property">length</span>;k++)&#123;<br>                nums[left+k] = sorted[k];<br>            &#125;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">reverseRecursive</span>(nums,<span class="hljs-number">0</span>,nums.<span class="hljs-property">length</span>-<span class="hljs-number">1</span>);<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>排序算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>315.【归并排序】计算右侧小于当前元素的个数</title>
    <link href="/2022/06/11/315-%E8%AE%A1%E7%AE%97%E5%8F%B3%E4%BE%A7%E5%B0%8F%E4%BA%8E%E5%BD%93%E5%89%8D%E5%85%83%E7%B4%A0%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
    <url>/2022/06/11/315-%E8%AE%A1%E7%AE%97%E5%8F%B3%E4%BE%A7%E5%B0%8F%E4%BA%8E%E5%BD%93%E5%89%8D%E5%85%83%E7%B4%A0%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数数组 nums ，按要求返回一个新数组 counts 。数组 counts 有该性质： counts[i] 的值是  nums[i] 右侧小于 nums[i] 的元素的数量。</p><p>输入：nums &#x3D; [5,2,6,1]<br>输出：[2,1,1,0] </p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>对于每个数，寻找其右侧小于该数的元素数量，想当于先对右侧数组进行排序，然后寻找该数的插入位置，插入位置之前有多少个数结果就是几个。<br>逆向对数组进行排序，每次插入末尾元素，并根据插入位置计算结果。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> countSmaller = <span class="hljs-keyword">function</span>(<span class="hljs-params">nums</span>) &#123;<br>    <span class="hljs-keyword">if</span>(nums.<span class="hljs-property">length</span>===<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span> [];<br>    &#125;<br>    <span class="hljs-keyword">const</span> counts = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(nums.<span class="hljs-property">length</span>);<br>    <span class="hljs-keyword">const</span> sorted = [];<br>    <br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">findIndex</span>(<span class="hljs-params">arr,target</span>)&#123;<br>        <span class="hljs-keyword">let</span> l=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">let</span> h=arr.<span class="hljs-property">length</span>-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(l&lt;h)&#123;<br>            <span class="hljs-keyword">const</span> mid = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((l+h)/<span class="hljs-number">2</span>);<br>            <span class="hljs-keyword">if</span>(arr[mid]&lt;target)&#123;<br>                l=mid+<span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                h=mid;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(arr[l]&lt;target)&#123;<br>            <span class="hljs-keyword">return</span> l+<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> l;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=nums.<span class="hljs-property">length</span>-<span class="hljs-number">1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>        <span class="hljs-keyword">const</span> index = <span class="hljs-title function_">findIndex</span>(sorted, nums[i]);<br>        sorted.<span class="hljs-title function_">splice</span>(index,<span class="hljs-number">0</span>,nums[i]);<br>        counts[i] = index;<br>    &#125;<br>    <span class="hljs-keyword">return</span> counts;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>排序算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>652.寻找重复的子树</title>
    <link href="/2022/06/11/652-%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E6%A0%91/"/>
    <url>/2022/06/11/652-%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一棵二叉树 root，返回所有重复的子树。<br>对于同一类的重复子树，你只需要返回其中任意一棵的根结点即可。<br>如果两棵树具有相同的结构和相同的结点值，则它们是重复的。</p><p>输入：root &#x3D; [1,2,3,4,null,2,4,null,null,4]<br>输出：[[2,4],[4]]</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>子树相同，则该子树的遍历序列也相同。找以每个节点为根节点的子树的遍历序列，存到一起，如果有相同的序列，则存下该结点。注意：相同子树可能出现多次，因此要记录每个序列出现的次数，只有在第一次重复时才进行保存。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> findDuplicateSubtrees = <span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) &#123;<br>    <span class="hljs-keyword">const</span> memory = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br>    <span class="hljs-keyword">const</span> res = [];<br>    <br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">traverse</span>(<span class="hljs-params">root</span>)&#123;<br>        <span class="hljs-keyword">if</span>(!root)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;#&#x27;</span>;<br>        &#125;<br>        <span class="hljs-keyword">const</span> key = root.<span class="hljs-property">val</span> + <span class="hljs-string">&#x27;#&#x27;</span> + <span class="hljs-title function_">traverse</span>(root.<span class="hljs-property">left</span>) + <span class="hljs-string">&#x27;#&#x27;</span> + <span class="hljs-title function_">traverse</span>(root.<span class="hljs-property">right</span>);<br>        <span class="hljs-keyword">let</span> freq = memory.<span class="hljs-title function_">get</span>(key) || <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(freq === <span class="hljs-number">1</span>)&#123;<br>            res.<span class="hljs-title function_">push</span>(root);<br>        &#125;<br>        memory.<span class="hljs-title function_">set</span>(key,freq+<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> key;<br>    &#125;<br>    <span class="hljs-title function_">traverse</span>(root);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>297.二叉树的序列化与反序列化</title>
    <link href="/2022/06/11/297-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <url>/2022/06/11/297-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。<br>请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 &#x2F; 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。<br>提示: 输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。</p><p>输入：root &#x3D; [1,2,3,null,null,4,5]<br>输出：[1,2,3,null,null,4,5]</p><p>树中结点数在范围 [0, 104] 内-1000 &lt;&#x3D; Node.val &lt;&#x3D; 1000</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>用前中后序遍历都可，再按这个顺序读取数组。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> serialize = <span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) &#123;<br>    <span class="hljs-keyword">let</span> res = <span class="hljs-string">&#x27;&#x27;</span>;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">rserialize</span>(<span class="hljs-params">root</span>)&#123;<br>        <span class="hljs-keyword">if</span>(!root)&#123;<br>            res = res + <span class="hljs-string">&#x27;null&#x27;</span> + <span class="hljs-string">&#x27;,&#x27;</span>;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        res = res + root.<span class="hljs-property">val</span> + <span class="hljs-string">&#x27;,&#x27;</span>;<br>        <span class="hljs-title function_">rserialize</span>(root.<span class="hljs-property">left</span>);<br>        <span class="hljs-title function_">rserialize</span>(root.<span class="hljs-property">right</span>);<br>    &#125;   <br>    <span class="hljs-title function_">rserialize</span>(root);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;;<br><br><span class="hljs-keyword">var</span> deserialize = <span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>) &#123;<br>    <span class="hljs-keyword">let</span> datalist = data.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;,&#x27;</span>);<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">rdeseriable</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">if</span>(datalist[<span class="hljs-number">0</span>] === <span class="hljs-string">&#x27;null&#x27;</span>)&#123;<br>            datalist.<span class="hljs-title function_">shift</span>();<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">const</span> root = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(datalist[<span class="hljs-number">0</span>]);<br>        datalist.<span class="hljs-title function_">shift</span>();<br>        root.<span class="hljs-property">left</span> = <span class="hljs-title function_">rdeseriable</span>();<br>        root.<span class="hljs-property">right</span> = <span class="hljs-title function_">rdeseriable</span>();<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    root = <span class="hljs-title function_">rdeseriable</span>();<br>    <span class="hljs-keyword">return</span> root;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>145.二叉树的后序遍历</title>
    <link href="/2022/06/10/145-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <url>/2022/06/10/145-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一棵二叉树的根节点 root ，返回其节点值的后序遍历。<br>输入：root &#x3D; [1,null,2,3]<br>输出：[3,2,1]</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> postorderTraversal = <span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) &#123;<br>    <span class="hljs-keyword">const</span> res = [];<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">backorder</span> = (<span class="hljs-params">root</span>) =&gt; &#123;<br>        <span class="hljs-keyword">if</span>(!root)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-title function_">backorder</span>(root.<span class="hljs-property">left</span>);<br>        <span class="hljs-title function_">backorder</span>(root.<span class="hljs-property">right</span>);<br>        res.<span class="hljs-title function_">push</span>(root.<span class="hljs-property">val</span>);<br>    &#125;<br>    <span class="hljs-title function_">backorder</span>(root);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>94.二叉树的中序遍历</title>
    <link href="/2022/06/10/94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <url>/2022/06/10/94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个二叉树的根节点 root ，返回 它的中序遍历。<br>输入：root &#x3D; [1,null,2,3]<br>输出：[1,3,2]</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> inorderTraversal = <span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) &#123;<br>    <span class="hljs-keyword">const</span> res = [];<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">inorder</span> = (<span class="hljs-params">root</span>) =&gt; &#123;<br>        <span class="hljs-keyword">if</span>(!root)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-title function_">inorder</span>(root.<span class="hljs-property">left</span>);<br>        res.<span class="hljs-title function_">push</span>(root.<span class="hljs-property">val</span>);<br>        <span class="hljs-title function_">inorder</span>(root.<span class="hljs-property">right</span>);<br>    &#125;<br>    <span class="hljs-title function_">inorder</span>(root);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>889.根据前序和后序遍历构造二叉树</title>
    <link href="/2022/06/10/889-%E6%A0%B9%E6%8D%AE%E5%89%8D%E5%BA%8F%E5%92%8C%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2022/06/10/889-%E6%A0%B9%E6%8D%AE%E5%89%8D%E5%BA%8F%E5%92%8C%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定两个整数数组，preorder 和 postorder ，其中 preorder 是一个具有 无重复 值的二叉树的前序遍历，postorder 是同一棵树的后序遍历，重构并返回二叉树。<br>如果存在多个答案，您可以返回其中 任何 一个。</p><p>输入：preorder &#x3D; [1,2,4,5,3,6,7], postorder &#x3D; [4,5,2,6,7,3,1]<br>输出：[1,2,3,4,5,6,7]</p><p>1 &lt;&#x3D; preorder.length &lt;&#x3D; 30<br>1 &lt;&#x3D; preorder[i] &lt;&#x3D; preorder.length<br>preorder 中所有值都 不同<br>postorder.length &#x3D;&#x3D; preorder.length<br>1 &lt;&#x3D; postorder[i] &lt;&#x3D; postorder.length<br>postorder 中所有值都 不同<br>保证 preorder 和 postorder 是同一棵二叉树的前序遍历和后序遍历</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>前序遍历序列开头是根节点，后序遍历序列结尾是根节点。前序遍历序列第二个值是左子树的根节点，在后序遍历序列中寻找到该值就能找到左子树的结尾位置。由此构建左右子树。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> constructFromPrePost = <span class="hljs-keyword">function</span>(<span class="hljs-params">preorder, postorder</span>) &#123;<br>    <span class="hljs-keyword">if</span>(!preorder.<span class="hljs-property">length</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-keyword">let</span> tmp = preorder[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">let</span> root = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(tmp);<br>    <span class="hljs-keyword">let</span> index = postorder.<span class="hljs-title function_">indexOf</span>(preorder[<span class="hljs-number">1</span>]);<br>    root.<span class="hljs-property">left</span> = <span class="hljs-title function_">constructFromPrePost</span>(preorder.<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>,index+<span class="hljs-number">2</span>),postorder.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>,index+<span class="hljs-number">1</span>));<br>    root.<span class="hljs-property">right</span> = <span class="hljs-title function_">constructFromPrePost</span>(preorder.<span class="hljs-title function_">slice</span>(index+<span class="hljs-number">2</span>,preorder.<span class="hljs-property">length</span>),postorder.<span class="hljs-title function_">slice</span>(index+<span class="hljs-number">1</span>,postorder.<span class="hljs-property">length</span>-<span class="hljs-number">1</span>));<br>    <span class="hljs-keyword">return</span> root;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>106.从中序与后序遍历序列构造二叉树</title>
    <link href="/2022/06/10/106-%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2022/06/10/106-%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定两个整数数组 inorder 和 postorder ，其中 inorder 是二叉树的中序遍历， postorder 是同一棵树的后序遍历，请你构造并返回这颗二叉树。<br>输入：inorder &#x3D; [9,3,15,20,7], postorder &#x3D; [9,15,7,20,3]<br>输出：[3,9,20,null,null,15,7]<br>1 &lt;&#x3D; inorder.length &lt;&#x3D; 3000<br>postorder.length &#x3D;&#x3D; inorder.length<br>-3000 &lt;&#x3D; inorder[i], postorder[i] &lt;&#x3D; 3000<br>inorder 和 postorder 都由 不同 的值组成<br>postorder 中每一个值都在 inorder 中<br>inorder 保证是树的中序遍历<br>postorder 保证是树的后序遍历</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>后序遍历最后一个值为根节点，根据此值将中序遍历序列划分为左右两个子序列，对应左子树和右子树，然后根据这两个序列的长度将后序遍历序列也分为左子树和右子树，再根据这些序列构建根节点的左子树和右子树。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> buildTree = <span class="hljs-keyword">function</span>(<span class="hljs-params">inorder, postorder</span>) &#123;<br>    <span class="hljs-keyword">if</span>(!inorder.<span class="hljs-property">length</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-keyword">let</span> root = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(postorder[postorder.<span class="hljs-property">length</span>-<span class="hljs-number">1</span>]);<br>    <span class="hljs-keyword">let</span> mid = inorder.<span class="hljs-title function_">findIndex</span>(<span class="hljs-function"><span class="hljs-params">number</span>=&gt;</span>number===root.<span class="hljs-property">val</span>);<br>    root.<span class="hljs-property">left</span> = <span class="hljs-title function_">buildTree</span>(inorder.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>,mid),postorder.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>,mid));<br>    root.<span class="hljs-property">right</span> = <span class="hljs-title function_">buildTree</span>(inorder.<span class="hljs-title function_">slice</span>(mid+<span class="hljs-number">1</span>,inorder.<span class="hljs-property">length</span>),postorder.<span class="hljs-title function_">slice</span>(mid,postorder.<span class="hljs-property">length</span>-<span class="hljs-number">1</span>));<br>    <span class="hljs-keyword">return</span> root;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>105.从前序遍历与中序遍历序列构造二叉树</title>
    <link href="/2022/06/10/105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2022/06/10/105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。</p><p>输入: preorder &#x3D; [3,9,20,15,7], inorder &#x3D; [9,3,15,20,7]<br>输出: [3,9,20,null,null,15,7]</p><p>1 &lt;&#x3D; preorder.length &lt;&#x3D; 3000<br>inorder.length &#x3D;&#x3D; preorder.length<br>-3000 &lt;&#x3D; preorder[i], inorder[i] &lt;&#x3D; 3000<br>preorder 和 inorder 均 无重复 元素<br>inorder 均出现在 preorder<br>preorder 保证 为二叉树的前序遍历序列<br>inorder 保证 为二叉树的中序遍历序列</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>前序遍历开头为根节点，以此将中序遍历分开，左边数组为左子树，右边数组为右子树。根据中序遍历划分知道左子树和右子树的序列长度，根据该长度将前序遍历序列划分。根据划分后的两个序列，再分别构建左子树和右子树。</p><img src="/2022/06/10/105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/%E5%BA%8F%E5%88%97.png" class=""> <h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> buildTree = <span class="hljs-keyword">function</span>(<span class="hljs-params">preorder, inorder</span>) &#123;<br>    <span class="hljs-keyword">if</span>(!preorder.<span class="hljs-property">length</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-keyword">let</span> root = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(preorder[<span class="hljs-number">0</span>]);<br>    <span class="hljs-keyword">let</span> mid = inorder.<span class="hljs-title function_">findIndex</span>(<span class="hljs-function"><span class="hljs-params">number</span>=&gt;</span>number===root.<span class="hljs-property">val</span>);<br>    root.<span class="hljs-property">left</span> = <span class="hljs-title function_">buildTree</span>(preorder.<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>),inorder.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>,mid));<br>    root.<span class="hljs-property">right</span> = <span class="hljs-title function_">buildTree</span>(preorder.<span class="hljs-title function_">slice</span>(mid+<span class="hljs-number">1</span>,preorder.<span class="hljs-property">length</span>),inorder.<span class="hljs-title function_">slice</span>(mid+<span class="hljs-number">1</span>,inorder.<span class="hljs-property">length</span>));<br>    <span class="hljs-keyword">return</span> root;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>654.最大二叉树</title>
    <link href="/2022/06/10/654-%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2022/06/10/654-%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你二叉树的根结点 root ，请你将它展开为一个单链表：<br>展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。<br>展开后的单链表应该与二叉树 先序遍历 顺序相同。</p><p>输入：root &#x3D; [1,2,5,3,4,null,6]<br>输出：[1,null,2,null,3,null,4,null,5,null,6]</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>先序遍历存入队列，然后连接成链表。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> flatten = <span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) &#123;<br>    <span class="hljs-keyword">if</span>(!root)&#123;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    <span class="hljs-keyword">const</span> stack = [];<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">perorderTraversal</span>(<span class="hljs-params">node</span>)&#123;<br>        <span class="hljs-keyword">if</span>(!node)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        stack.<span class="hljs-title function_">push</span>(node);<br>        <span class="hljs-title function_">perorderTraversal</span>(node.<span class="hljs-property">left</span>);<br>        <span class="hljs-title function_">perorderTraversal</span>(node.<span class="hljs-property">right</span>);<br>    &#125;<br>    <span class="hljs-title function_">perorderTraversal</span>(root);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;stack.<span class="hljs-property">length</span>;i++)&#123;<br>        <span class="hljs-keyword">const</span> node = stack[i];<br>        node.<span class="hljs-property">left</span> = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span>(i&lt;stack.<span class="hljs-property">length</span>-<span class="hljs-number">1</span>)&#123;<br>            node.<span class="hljs-property">right</span> = stack[i+<span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            node.<span class="hljs-property">right</span> = <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> stack[<span class="hljs-number">0</span>];<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>114.二叉树展开为链表</title>
    <link href="/2022/06/09/114-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/"/>
    <url>/2022/06/09/114-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你二叉树的根结点 root ，请你将它展开为一个单链表：<br>展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。<br>展开后的单链表应该与二叉树 先序遍历 顺序相同。</p><p>输入：root &#x3D; [1,2,5,3,4,null,6]<br>输出：[1,null,2,null,3,null,4,null,5,null,6]</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>先序遍历存入队列，然后连接成链表。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> flatten = <span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) &#123;<br>    <span class="hljs-keyword">if</span>(!root)&#123;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    <span class="hljs-keyword">const</span> stack = [];<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">perorderTraversal</span>(<span class="hljs-params">node</span>)&#123;<br>        <span class="hljs-keyword">if</span>(!node)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        stack.<span class="hljs-title function_">push</span>(node);<br>        <span class="hljs-title function_">perorderTraversal</span>(node.<span class="hljs-property">left</span>);<br>        <span class="hljs-title function_">perorderTraversal</span>(node.<span class="hljs-property">right</span>);<br>    &#125;<br>    <span class="hljs-title function_">perorderTraversal</span>(root);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;stack.<span class="hljs-property">length</span>;i++)&#123;<br>        <span class="hljs-keyword">const</span> node = stack[i];<br>        node.<span class="hljs-property">left</span> = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span>(i&lt;stack.<span class="hljs-property">length</span>-<span class="hljs-number">1</span>)&#123;<br>            node.<span class="hljs-property">right</span> = stack[i+<span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            node.<span class="hljs-property">right</span> = <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> stack[<span class="hljs-number">0</span>];<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>116.填充每个节点的下一个右侧节点指针</title>
    <link href="/2022/06/09/116-%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88/"/>
    <url>/2022/06/09/116-%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：<br>struct Node {<br>  int val;<br>  Node *left;<br>  Node *right;<br>  Node *next;<br>}<br>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。<br>初始状态下，所有 next 指针都被设置为 NULL。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>思路一：用队列，层序遍历。<br>思路二：每次传入上一层的左右两个子节点，然后将下一层的四个节点连起来。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>思路一</p><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> connect = <span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) &#123;<br>    <span class="hljs-keyword">if</span>(!root)&#123;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    <span class="hljs-keyword">const</span> deque = [root];<br>    <span class="hljs-keyword">while</span>(deque.<span class="hljs-property">length</span>&gt;<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">const</span> size = deque.<span class="hljs-property">length</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;<br>            <span class="hljs-keyword">const</span> node = deque.<span class="hljs-title function_">shift</span>();<br>            <span class="hljs-keyword">if</span>(i&lt;size-<span class="hljs-number">1</span>)&#123;<br>                node.<span class="hljs-property">next</span> = deque[<span class="hljs-number">0</span>];<br>            &#125;<br>            <span class="hljs-keyword">if</span>(node.<span class="hljs-property">left</span>)&#123;<br>                deque.<span class="hljs-title function_">push</span>(node.<span class="hljs-property">left</span>);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(node.<span class="hljs-property">right</span>)&#123;<br>                deque.<span class="hljs-title function_">push</span>(node.<span class="hljs-property">right</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> root;<br>&#125;;<br></code></pre></td></tr></table></figure><p>思路二</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> connect = <span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) &#123;<br>   <span class="hljs-keyword">if</span>(!root)&#123;<br>       <span class="hljs-keyword">return</span> root;<br>   &#125;<br>   <span class="hljs-keyword">function</span> <span class="hljs-title function_">traverse</span>(<span class="hljs-params">left,right</span>)&#123;<br>       <span class="hljs-keyword">if</span>(!left || !right)&#123;<br>           <span class="hljs-keyword">return</span>;<br>       &#125;<br>       left.<span class="hljs-property">next</span> = right;<br>       <span class="hljs-title function_">traverse</span>(left.<span class="hljs-property">left</span>,left.<span class="hljs-property">right</span>);<br>       <span class="hljs-title function_">traverse</span>(left.<span class="hljs-property">right</span>,right.<span class="hljs-property">left</span>);<br>       <span class="hljs-title function_">traverse</span>(right.<span class="hljs-property">left</span>,right.<span class="hljs-property">right</span>);<br>   &#125;<br>   <span class="hljs-title function_">traverse</span>(root.<span class="hljs-property">left</span>,root.<span class="hljs-property">right</span>);<br>   <span class="hljs-keyword">return</span> root;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>226.翻转二叉树</title>
    <link href="/2022/06/09/226-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2022/06/09/226-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>先序遍历，交换左右子树。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> invertTree = <span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) &#123;<br>    <span class="hljs-keyword">if</span>(!root)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">const</span> left = <span class="hljs-title function_">invertTree</span>(root.<span class="hljs-property">right</span>);<br>        <span class="hljs-keyword">const</span> right = <span class="hljs-title function_">invertTree</span>(root.<span class="hljs-property">left</span>);<br>        root.<span class="hljs-property">left</span> = left;<br>        root.<span class="hljs-property">right</span> = right;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构杂项</title>
    <link href="/2022/06/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9D%82%E9%A1%B9/"/>
    <url>/2022/06/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9D%82%E9%A1%B9/</url>
    
    <content type="html"><![CDATA[<h4 id="一、类图"><a href="#一、类图" class="headerlink" title="一、类图"></a>一、类图</h4><p>类图中，每个类由3个部分组成，上面的是类名，中间的是属性，下面的是方法。属性和方法可以用修饰符修饰，+表示public、-表示private、#表示protected。如：</p><img src="/2022/06/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9D%82%E9%A1%B9/%E7%B1%BB%E5%9B%BE.png" class=""><p>类的6种关系：泛化、实现、组合、聚合、关联、依赖</p><img src="/2022/06/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9D%82%E9%A1%B9/%E7%B1%BB%E7%9A%84%E5%85%B3%E7%B3%BB.png" class=""><ul><li>泛化：是一种继承关系。如老虎继承动物类，动物是老虎的泛化，老虎是动物的特化。</li></ul><img src="/2022/06/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9D%82%E9%A1%B9/%E6%B3%9B%E5%8C%96.png" class=""><ul><li>实现：子类实现了接口类。</li></ul><img src="/2022/06/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9D%82%E9%A1%B9/%E5%AE%9E%E7%8E%B0.png" class=""><ul><li>组合：把个体对象虽未整体类的属性。</li></ul><img src="/2022/06/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9D%82%E9%A1%B9/%E7%BB%84%E5%90%88.png" class=""><ul><li>聚合：把个体对象的指针作为整体类的属性。</li></ul><img src="/2022/06/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9D%82%E9%A1%B9/%E8%81%9A%E5%90%88.png" class=""><ul><li>关联：拥有关系，使一个类知道另一个类的属性和方法。</li></ul><img src="/2022/06/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9D%82%E9%A1%B9/%E5%85%B3%E8%81%94.png" class=""><ul><li>依赖：使用关系。</li></ul><img src="/2022/06/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9D%82%E9%A1%B9/%E4%BE%9D%E8%B5%96.png" class="">]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>543.二叉树的直径</title>
    <link href="/2022/06/08/543-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/"/>
    <url>/2022/06/08/543-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。<br>二叉树：[1,2,3,4,5]<br>输出：3</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>想当与求哪个节点的左右子树深度和最大。注意是路径不是经过的路上有多少个节点，而是节点数减一，所以是比较left+right。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> diameterOfBinaryTree = <span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) &#123;<br>    <span class="hljs-keyword">let</span> result = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">maxDepth</span>(<span class="hljs-params">node</span>)&#123;<br>        <span class="hljs-keyword">if</span>(!node)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">const</span> left = <span class="hljs-title function_">maxDepth</span>(node.<span class="hljs-property">left</span>);<br>            <span class="hljs-keyword">const</span> right = <span class="hljs-title function_">maxDepth</span>(node.<span class="hljs-property">right</span>);<br>            result = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(result, left+right);<br>            <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(left,right)+<span class="hljs-number">1</span>；<br>        &#125;<br>    &#125;<br>    <span class="hljs-title function_">maxDepth</span>(root);<br>    <span class="hljs-keyword">return</span> result；<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>144.二叉树的前序遍历</title>
    <link href="/2022/06/08/144-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <url>/2022/06/08/144-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你二叉树的根节点 root ，返回它节点值的前序遍历。<br>输入：root &#x3D; [1,null,2,3]<br>输出：[1,2,3]</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>递归实现：先访问根节点，然后左子树和右子树。</li><li>迭代实现：用栈来实现。根入栈，出栈，节点值放在结果数值中。然后先放右子树，再放左子树。因为是从堆顶取，取的时候先左后右。</li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>思路一：</p><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> preorderTraversal = <span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) &#123;<br>    <span class="hljs-keyword">let</span> result = [];<br>    <span class="hljs-keyword">var</span> <span class="hljs-title function_">preorderTraversalNode</span> = (<span class="hljs-params">node</span>) =&gt; &#123;<br>        <span class="hljs-keyword">if</span>(node) &#123;<br>            result.<span class="hljs-title function_">push</span>(node.<span class="hljs-property">val</span>);<br>            <span class="hljs-title function_">preorderTraversalNode</span>(node.<span class="hljs-property">left</span>);<br>            <span class="hljs-title function_">preorderTraversalNode</span>(node.<span class="hljs-property">right</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-title function_">preorderTraversalNode</span>(root);<br>    <span class="hljs-keyword">return</span> result;<br>&#125;;<br></code></pre></td></tr></table></figure><p>思路二：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> preorderTraversal = <span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) &#123;<br>    <span class="hljs-keyword">let</span> list = [];<br>    <span class="hljs-keyword">let</span> stack = [];<br>    <span class="hljs-keyword">if</span>(root)&#123;<br>        stack.<span class="hljs-title function_">push</span>(root);<br>    &#125;<br>    <span class="hljs-keyword">while</span>(stack.<span class="hljs-property">length</span>&gt;<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">const</span> curNode = stack.<span class="hljs-title function_">pop</span>();<br>        list.<span class="hljs-title function_">push</span>(curNode.<span class="hljs-property">val</span>);<br>        <span class="hljs-keyword">if</span>(curNode.<span class="hljs-property">right</span>!==<span class="hljs-literal">null</span>)&#123;<br>            stack.<span class="hljs-title function_">push</span>(curNode.<span class="hljs-property">right</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(curNode.<span class="hljs-property">left</span>!==<span class="hljs-literal">null</span>)&#123;<br>            stack.<span class="hljs-title function_">push</span>(curNode.<span class="hljs-property">left</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> list;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>104.二叉树的最大深度</title>
    <link href="/2022/06/08/104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/"/>
    <url>/2022/06/08/104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>dfs遍历二叉树，取左右子树的最大深度。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> maxDepth = <span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) &#123;<br>    <span class="hljs-keyword">if</span>(!root)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">const</span> left = <span class="hljs-title function_">maxDepth</span>(root.<span class="hljs-property">left</span>);<br>        <span class="hljs-keyword">const</span> right = <span class="hljs-title function_">maxDepth</span>(root.<span class="hljs-property">right</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(left,right) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>二叉树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树</title>
    <link href="/2022/05/17/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2022/05/17/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h4 id="一、各种二叉树的概念"><a href="#一、各种二叉树的概念" class="headerlink" title="一、各种二叉树的概念"></a>一、各种二叉树的概念</h4><ul><li><strong>满二叉树</strong>：除了最后一层的节点没有任何子节点外，每层上的所有结点都有两个节点的二叉树。</li><li><strong>完全二叉树</strong>：一颗二叉树的深度为h，除了第h层外，其他各层的节点都有两个子节点，且第h层的所有结点都集中在左边。</li><li><strong>二叉搜索树</strong>：左子树的所有节点的值均小于它的根节点的值。右子树的所有节点的值均大于它的根节点的值。它的左右子树也分别为二叉搜索树。</li><li><strong>平衡二叉树</strong>：一颗高度平衡的二叉搜索树，左右两个子树的高度差绝对值不超过1，且左右两个子树都是平衡二叉树。</li><li><strong>顶堆</strong>：大顶堆是父节点的值比每一个子节点的值都要大。小顶堆是父节点的值比每一个子节点的值都要小。</li></ul><h4 id="二、构建二叉树"><a href="#二、构建二叉树" class="headerlink" title="二、构建二叉树"></a>二、构建二叉树</h4><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">BinarySearchTree</span>(<span class="hljs-params"></span>)&#123;<br>    funtion <span class="hljs-title class_">Node</span>(key)&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">key</span> = key;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">left</span> = <span class="hljs-literal">null</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">right</span> = <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">root</span> = <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="三、二叉树的前序遍历"><a href="#三、二叉树的前序遍历" class="headerlink" title="三、二叉树的前序遍历"></a>三、二叉树的前序遍历</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> preorderTraversal = <span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) &#123;<br>    <span class="hljs-keyword">const</span> res = [];<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">preorder</span> = (<span class="hljs-params">root</span>) =&gt;&#123;<br>        <span class="hljs-keyword">if</span>(!root)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        res.<span class="hljs-title function_">push</span>(root.<span class="hljs-property">val</span>);<br>        <span class="hljs-title function_">preorder</span>(root.<span class="hljs-property">left</span>);<br>        <span class="hljs-title function_">preorder</span>(root.<span class="hljs-property">right</span>);<br>    &#125;<br>    <span class="hljs-title function_">preorder</span>(root);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="四、二叉树的中序遍历"><a href="#四、二叉树的中序遍历" class="headerlink" title="四、二叉树的中序遍历"></a>四、二叉树的中序遍历</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> inorderTraversal = <span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) &#123;<br>    <span class="hljs-keyword">const</span> res = [];<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">inorder</span> = (<span class="hljs-params">root</span>) =&gt; &#123;<br>        <span class="hljs-keyword">if</span>(!root)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-title function_">inorder</span>(root.<span class="hljs-property">left</span>);<br>        res.<span class="hljs-title function_">push</span>(root.<span class="hljs-property">val</span>);<br>        <span class="hljs-title function_">inorder</span>(root.<span class="hljs-property">right</span>);<br>    &#125;<br>    <span class="hljs-title function_">inorder</span>(root);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="五、二叉树的后序遍历"><a href="#五、二叉树的后序遍历" class="headerlink" title="五、二叉树的后序遍历"></a>五、二叉树的后序遍历</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js">jsvar postorderTraversal = <span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) &#123;<br>    <span class="hljs-keyword">const</span> res = [];<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">backorder</span> = (<span class="hljs-params">root</span>) =&gt; &#123;<br>        <span class="hljs-keyword">if</span>(!root)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-title function_">backorder</span>(root.<span class="hljs-property">left</span>);<br>        <span class="hljs-title function_">backorder</span>(root.<span class="hljs-property">right</span>);<br>        res.<span class="hljs-title function_">push</span>(root.<span class="hljs-property">val</span>);<br>    &#125;<br>    <span class="hljs-title function_">backorder</span>(root);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python</title>
    <link href="/2022/05/17/Python/"/>
    <url>/2022/05/17/Python/</url>
    
    <content type="html"><![CDATA[<h4 id="一、Python2和Python3的区别"><a href="#一、Python2和Python3的区别" class="headerlink" title="一、Python2和Python3的区别"></a>一、Python2和Python3的区别</h4><ul><li>Python2可以使用一个空格来分隔打印的内容，Python3必须使用小括号包含打印内容。</li><li>Python2是ASCII编码，需要更改字符集才能正常支持中文。Python3中字符串是Unicode，支持中文做标识符。</li><li>在Python2中&#x2F;除法规则是整数相除的结果是一个整数，Python3结果可以是浮点数。</li><li>Python3中没有xrange，range返回可迭代对象。Python2的range返回列表。</li><li>Python2中捕获异常为except exc，var。Python3中为except exc as var。</li><li>Python2中所有类型的对象可以直接被抛出。Python3中只有继承BaseException的对象才可以被抛出。</li><li>Python3中触发异常只能用raise IOError(“file error”)。Python2还可以raise IOError, “file error”</li><li>Python3废除异常StandardError，统一使用Exception</li><li>Python3不等于只有!&#x3D;。Python2还有&lt;&gt;</li><li>Python3中部分模块被改名，例如Queue&#x3D;&gt;queue，SocketServer&#x3D;&gt;socketserver</li></ul>]]></content>
    
    
    <categories>
      
      <category>测试开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>测试开发</title>
    <link href="/2022/05/17/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91/"/>
    <url>/2022/05/17/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<h4 id="一、测试用例是根据什么编写的"><a href="#一、测试用例是根据什么编写的" class="headerlink" title="一、测试用例是根据什么编写的"></a>一、测试用例是根据什么编写的</h4><p>测试用例指的是对一项特定产品进行测试任务的描述， 包括测试目标、测试环境、输入数据、测试步骤、预期结果、测试脚本等，最终形成文档。<br>测试用例主要包括四个内容：用例标题、前置条件、测试步骤和预期结果。</p><ul><li>用例标题：主要描述测试某项功能。</li><li>前置条件：用例标题需要满足该条件。</li><li>测试步骤：描述用例的操作步骤。</li><li>预期结果：符合预期需求（开发规格书、需求文档、用户需求等）<h4 id="二、怎么判断测试结束（十个原则）"><a href="#二、怎么判断测试结束（十个原则）" class="headerlink" title="二、怎么判断测试结束（十个原则）"></a>二、怎么判断测试结束（十个原则）</h4></li><li>基于“测试阶段”的原则：每个软件的测试一般都要经过单元测试、集成测试、系统测试这几个阶段，我们可以分别对单元测试、集成测试和系统测试制定详细的测试结束点。每个测试阶段符合结束标准后，再进行后面一个阶段的测试。</li><li>基于“测试用例”的原则：测试设计人员设计测试用例，并请项目组成员参与评审，测试用例一旦评审通过，后面测试时，就可以作为测试结束的一个参考标准。</li><li>基于“缺陷收敛趋势”的原则：软件测试的生命周期中随着测试时间的推移，测试发现的缺陷图线，在测试到一定阶段后，呈现下降趋势，直到发现的缺陷几乎为0或者很难发现缺陷为止。</li><li>基于“缺陷修复率”的原则：软件缺陷在测试生命周期中我们分成几个严重等级，它们分别是：严重错误、主要错误、次要错误、一般错误、较小错误和测试建议6种。那我们在确定测试结束点时，严重错误和主要错误的缺陷修复率必须达到100%，不允许存在功能性的错误；次要错误和一般错误的缺陷修复率必须达到85%以上，允许存在少量功能缺陷，后面版本解决；对于较小错误的缺陷修复率最好达到60%~70%以上。对于测试建议的问题，可以暂时不用修改。</li><li>基于“验收测试”的原则：在测试到一定阶段，达到或接近测试部门指定的标准后，就递交用户做验收测试。如果通过用户的测试验收，就可以立即终止测试部门的测试；如果客户验收测试时，发现了部分缺陷，就可以针对性的修改缺陷后，验证通过后递交用户，相应测试也可以结束。</li><li>基于“覆盖率”的原则：个人觉得只要测试用例的“覆盖率”覆盖了客户提出的全部软件需求，包括行业隐性需求、功能需求和性能需求等，只要测试用例执行的覆盖率达到100%，基本上测试就可以结束。</li><li>基于“项目计划”的原则：在项目开始时制定结点，对测试进度和测试结束点作出限制。</li><li>基于“缺陷度量”的原则：对已经发现的缺陷，运用常用的缺陷分析技术和缺陷分析工具，用图表统计出来，分时间段对缺陷进行度量，让缺陷数控制在一个可以接受的范围内。</li><li>基于“质量成本”的原则：从“质量&#x2F;成本&#x2F;进度”三方面取得平衡。</li><li>基于“测试行业经验”的原则：根据测试行业的一些经验，为测试提供借鉴。比如说测试人员对行业业务的熟悉程度，测试人员的工作能力，测试的工作效率等等都会影响到整个测试计划的执行。</li></ul><h4 id="三、-如何为登陆页面设计测试用例"><a href="#三、-如何为登陆页面设计测试用例" class="headerlink" title="三、 如何为登陆页面设计测试用例"></a>三、 如何为登陆页面设计测试用例</h4><h5 id="一、功能测试-Function-test"><a href="#一、功能测试-Function-test" class="headerlink" title="一、功能测试 (Function test)"></a>一、功能测试 (Function test)</h5><ol><li><p>输入为空时，点击提交按钮，看提示信息。　　</p></li><li><p>输入正确的用户名和密码，点击提交按钮，验证是否能正确登录。　　</p></li><li><p>输入错误的用户名或者密码, 验证登录会失败，并且提示相应的错误信息。</p></li><li><p>登录成功后能否跳转到正确的页面。　　</p></li><li><p>用户名和密码，长度的验证，应该怎么处理。　　</p></li><li><p>用户名和密码中有特殊字符（比如空格），和其它非英文的情况。　　</p></li><li><p>记住用户名的功能。　　</p></li><li><p>登录失败后，不能记录密码的功能。　　</p></li><li><p>用户名和密码前后有空格的处理。　　</p></li><li><p>密码是否加密显示（星号圆点等）。　</p></li><li><p>有验证码的，要考虑文字是否扭曲过度导致辨认难度大，考虑颜色（色盲使用者），刷新或换一个按钮是否好用。</p></li><li><p>登录页面中的注册、忘记密码、 退出登录后用另一帐号登录等情况下的链接是否正确。</p></li><li><p>输入密码的时候，大写键盘开启的时候要有提示信息。</p></li><li><p>重置功能是否实现。</p></li><li><p>是否对敏感字符屏蔽。　　</p><h5 id="二、界面测试-UI-Test"><a href="#二、界面测试-UI-Test" class="headerlink" title="二、界面测试 (UI Test)"></a>二、界面测试 (UI Test)</h5></li><li><p>布局是否合理，按钮是否对齐。　　</p></li><li><p>testbox和按钮的长度，高度是否符合要求。　　</p></li><li><p>界面的设计风格是否与UI的设计风格统一。　　</p></li><li><p>界面中的文字简洁易懂，没有错别字。　　</p><h5 id="三、性能测试-performance-test"><a href="#三、性能测试-performance-test" class="headerlink" title="三、性能测试 (performance test)"></a>三、性能测试 (performance test)</h5></li><li><p>打开登录页面，需要几秒。</p></li><li><p>输入正确的用户名和密码后，登录成功跳转到新页面，需要几秒，最好不超过5秒。</p></li><li><p>批量用户（用户的多少、持续时间等根据实际需求而定）并发登录情况验证。　　</p><h5 id="四、安全性测试-Security-test"><a href="#四、安全性测试-Security-test" class="headerlink" title="四、安全性测试 (Security test)"></a>四、安全性测试 (Security test)</h5></li><li><p>登录成功后生成的Cookie，是否是httponly (否则容易被脚本盗取)。　　</p></li><li><p>用户名和密码是否通过加密的方式，发送给Web服务器。　　</p></li><li><p>用户名和密码的验证，应该是用服务器端验证， 而不能单单是在客户端用javascript验证。　　</p></li><li><p>用户名和密码的输入框，应该屏蔽SQL 注入攻击。　　</p></li><li><p>用户名和密码的输入框，应该禁止输入脚本 （防止XSS攻击）。　　</p></li><li><p>错误登录的次数限制（防止暴力破解）。　　</p></li><li><p>考虑是否支持多用户在同一机器上登录。</p></li><li><p>考虑一用户在多台机器上登录。</p></li><li><p>验证密码是否可以粘贴复制。　　</p><h5 id="五、可用性测试-Usability-Test"><a href="#五、可用性测试-Usability-Test" class="headerlink" title="五、可用性测试 (Usability Test)"></a>五、可用性测试 (Usability Test)</h5></li><li><p>是否可以全用键盘操作，是否有快捷键。　　</p></li><li><p>输入用户名，密码后按回车，是否可以登录。　　</p></li><li><p>输入框能否可以以Tab键切换。　　</p><h5 id="六、兼容性测试（Compatibility-Test）"><a href="#六、兼容性测试（Compatibility-Test）" class="headerlink" title="六、兼容性测试（Compatibility Test）"></a>六、兼容性测试（Compatibility Test）</h5></li><li><p>主流的浏览器下能否显示正常功能（比如IE,6,7,8,9, Firefox, Chrome等）。　　</p></li><li><p>不同的平台是否能正常工作，比如Windows, LINUX。　　</p></li><li><p>移动设备上是否正常工作，比如手机客户端、ipad （Iphone, Andriod）。　　</p></li><li><p>不同的分辨率，页面显示是否正常。　　</p><h5 id="七、本地化测试-（Localization-test）"><a href="#七、本地化测试-（Localization-test）" class="headerlink" title="七、本地化测试 （Localization test）"></a>七、本地化测试 （Localization test）</h5></li><li><p>不同语言环境下，页面的显示是否正确。　　</p><h5 id="八、软件辅助性测试-（Accessibility-test）"><a href="#八、软件辅助性测试-（Accessibility-test）" class="headerlink" title="八、软件辅助性测试 （Accessibility test）"></a>八、软件辅助性测试 （Accessibility test）</h5><p>软件辅助功能测试是指测试软件是否向残疾用户提供足够的辅助功能。　　</p></li><li><p>高对比度下能否显示正常 （比如视力不好的人是否可以正常使用）</p></li></ol><h4 id="四、测试发现bug如何与开发人员沟通"><a href="#四、测试发现bug如何与开发人员沟通" class="headerlink" title="四、测试发现bug如何与开发人员沟通"></a>四、测试发现bug如何与开发人员沟通</h4><ol><li>测试人员登记一个缺陷：包括摘要（描述什么地方出现问题）、描述（发生了什么问题、如何发生的，包括前置条件、测试数据和操作步骤）</li><li>开发人员处理缺陷</li><li>测试人员进行验证</li></ol><h4 id="五、规格说明书"><a href="#五、规格说明书" class="headerlink" title="五、规格说明书"></a>五、规格说明书</h4><p>包括编写目的、团队职责与角色划分、工作流程（计划与设计阶段、实施测试阶段、总结阶段）、产品功能性和非功能性需求分析、产品介绍、产品面向用户群体、产品的标准或规范。</p><h4 id="六、常用的自动化测试工具"><a href="#六、常用的自动化测试工具" class="headerlink" title="六、常用的自动化测试工具"></a>六、常用的自动化测试工具</h4><h5 id="1、Selenium"><a href="#1、Selenium" class="headerlink" title="1、Selenium"></a>1、Selenium</h5><p>WEB自动化测试　　Selenium是网页应用中最流行的开源自动化测试框架。起源于2000年，10多年来不断地完善，Selenium成为许多Web自动化测试人员的选择，尤其是那些有高级编程和脚本技能的人。Selenium也成为了其他开源自动化测试工具比如Katalon Studio，Watir，Protractor和Robot Framework的核心框架。　　Selenium 支持多系统环境(Windows，Mac，Linux)以及多种浏览器(Chrome，FireFox，IE以及无头浏览器(没有界面))。它的脚本可以由各种各样的编程语言编写，比如 Java，Groovy，Python，C#，PHP，Ruby 以及 Perl。　　因为Selenium的灵活性，测试人员可以写各种复杂的、高级的测试脚本来应对各种复杂的问题，它需要高级的编程技能和付出来构建满足自己需求的自动化测试框架和库。　　</p><h5 id="2、Appium"><a href="#2、Appium" class="headerlink" title="2、Appium"></a>2、Appium</h5><p>App自动化测试　　Appium是一个移动端自动化测试开源工具，支持iOS和Android平台，支持Python、Java等语言，即同一套Java或Python脚本可以同时运行在iOS和Android平台，Appium 是一个C&#x2F;S架构，核心是一个Web服务器，它提供了一套REST的接口。当收到客户端的连接后，就会监听到命令，然后在移动设备上执行这些命令，最后将执行结果放在HTTP响应中返还给客户端。　　</p><h5 id="3、Jmeter"><a href="#3、Jmeter" class="headerlink" title="3、Jmeter"></a>3、Jmeter</h5><p>接口测试，性能测试　　Apache JMeter是一个开源的Java桌面应用程序，主要用于web应用程序的负载测试。它还支持单元测试和有限的功能测试。　　它有很多好的特性，比如动态报告、可移植性、强大的测试IDE等，并且支持不同类型的应用程序、协议、shell脚本、Java对象和数据库。　　</p><h5 id="4、Postman"><a href="#4、Postman" class="headerlink" title="4、Postman"></a>4、Postman</h5><p>接口测试　　Postman 提供功能强大的Web API和HTTP请求的调试，它能够发送任何类型的HTTP请求 (GET, POST, PUT, DELETE…)，并且能附带任何数量的参数和Headers。不仅如此，它还提供测试数据和环境配置数据的导入导出，付费的Post Cloud用户还能够创建自己的 Team Library用来团队协作式的测试，并能够将自己的测试收藏夹和用例数据分享给团队。　　</p><h5 id="5、SoapUI"><a href="#5、SoapUI" class="headerlink" title="5、SoapUI"></a>5、SoapUI</h5><p>接口测试　　SoapUI是一个非常流行的用于SOAP和REST的开源API测试自动化框架。它还支持功能测试、性能测试、数据驱动测试和测试报告。　　</p><h5 id="6、Monkey"><a href="#6、Monkey" class="headerlink" title="6、Monkey"></a>6、Monkey</h5><p>稳定性测试　　软件附带在sdk中，适用于android和ios，通过adb shell，生成用户或系统的伪随机事件。　　压力测试结果：崩溃crash，无响应anr，　　基本命令：adb shell monkey 1000。　　</p><h5 id="7、Robot-Framework"><a href="#7、Robot-Framework" class="headerlink" title="7、Robot Framework"></a>7、Robot Framework</h5><p>WebUI自动化测试，接口测试　　Robot Framework是一个开源自动化框架，它实现了用于验收测试和验收测试驱动开发(ATDD)的关键字驱动方法。Robot Framework为不同的测试自动化需求提供框架。但是，通过使用Python和Java实现其他测试库，可以进一步扩展其测试功能。Selenium WebDriver是Robot Framework中常用的外部库。　　测试工程师可以利用Robot Framework作为自动化框架，不仅可以进行Web测试，还可以用于Android和iOS测试自动化。对于熟悉关键字驱动测试的测试人员，可以轻松学习Robot Framework。　　</p><h5 id="8、QTP"><a href="#8、QTP" class="headerlink" title="8、QTP"></a>8、QTP</h5><p>Web自动化测试　　QTP是一种自动测试工具。使用 QTP 的目的是想用它来执行重复的手动测试，主要是用于回归测试和测试同一软件的新版本。因此你在测试前要考虑好如何对应用程序进行测试，例如要测试那些功能、操作步骤、输入数据和期望的输出数据等。　　QTP针对的是GUI应用程序，包括传统的Windows应用程序，以及现在越来越流行的Web应用。它可以覆盖绝大多数的软件开发技术，简单高效，并具备测试用例可重用的特点。其中包括：创建测试、插入检查点、检验数据、增强测试、运行测试、分析结果和维护测试等方面。　　</p><h5 id="9、LoadRunner"><a href="#9、LoadRunner" class="headerlink" title="9、LoadRunner"></a>9、LoadRunner</h5><p>性能测试　　LoadRunner，是一种预测系统行为和性能的负载测试工具。通过以模拟上千万用户实施并发负载及实时性能监测的方式来确认和查找问题，LoadRunner能够对整个企业架构进行测试。　　企业使用LoadRunner能最大限度地缩短测试时间，优化性能和加速应用系统的发布周期。LoadRunner可适用于各种体系架构的自动负载测试，能预测系统行为并评估系统性能。　　</p><h5 id="10、Jenkins"><a href="#10、Jenkins" class="headerlink" title="10、Jenkins"></a>10、Jenkins</h5><p>持续集成　　自动化构建编译，部署，任务执行，测试报告，邮件通知等。</p><h4 id="七、常用的自动化测试框架"><a href="#七、常用的自动化测试框架" class="headerlink" title="七、常用的自动化测试框架"></a>七、常用的自动化测试框架</h4><h5 id="一、线性框架"><a href="#一、线性框架" class="headerlink" title="一、线性框架"></a>一、线性框架</h5><p>最基本的框架。<br>测试代码的创建和执行是按线性或顺序编写的，测试人员手动记录每一个步骤，并自动回放记录的脚本。这些步骤包括导航、用户输入和检查点，最适合小型应用程序或团队。<br><strong>优点</strong>：生成测试用例的速度快，直接录制，无需代码基础，无需手动编写测试代码，门槛较低、易于上手。<br><strong>缺点</strong>：录制的脚本是固定的，不可重用。当应用发生微小变化时，上一次录制的脚本可能就无法使用，需要重新录制，产生大量的后期维护成本。</p><h5 id="二、基于模块化的框架"><a href="#二、基于模块化的框架" class="headerlink" title="二、基于模块化的框架"></a>二、基于模块化的框架</h5><p>允许将被测应用程序划分为单独的模块、单元或部分。每个模块都会为他们创建独立的测试脚本。每个模块及其测试脚本的组合可以构建代表各种测试案例的更大的测试。<br><strong>优点</strong>：该框架在创建模块时使用抽象，应用程序更改只影响与它们相关联的测试脚本所涉及的模块，而不影响其它部分。高度的模块化，使得维护更加容易且具有成本效益。创建测试用例所需的精力最少，因为可以重复使用不同模块的测试脚本。<br><strong>缺点</strong>：如果没有语言开发基础，建立框架会很困难。由于将数据硬编码到测试脚本中，因此无法重复使用数据集，因为测试是单独执行的。</p><h5 id="三、库结构框架"><a href="#三、库结构框架" class="headerlink" title="三、库结构框架"></a>三、库结构框架</h5><p>建立在模块化的基础上，不仅可以将被测应用程序划分为测试脚本，还可以将测试脚本中的相似任务划分为通用功能。创建一个库，该库构成了AUT的常用功能，可以在需要时由测试脚本调用。<br><strong>优点</strong>：高度的模块化，使得测试维护简单且预算友好。具有高度的可重用性，因为它的公共库函数可以被几个测试脚本使用。<br><strong>缺点</strong>：框架中引入的库使其更加复杂。测试数据也被硬编码到测试脚本中，因此数据中的更改必须适用于测试脚本。测试脚本的开发需要更多的时间和技术。</p><h5 id="四、数据驱动框架"><a href="#四、数据驱动框架" class="headerlink" title="四、数据驱动框架"></a>四、数据驱动框架</h5><p>测试数据和测试脚本是分离的。在测试场景中，需要使用不同的测试数据多次测试同一功能或者特性，有时每更换一次测试数据都需要修改测试脚本。如果测试脚本是固定的，而测试数据可以从外部的数据文件获取，那么只用维护一份脚本和一份数据文件即可。<br><strong>优点</strong>：易于维护。测试脚本中的任何更改都不会影响测试数据，可以避免对数据进行硬编码。可以使用多组数据进行测试。可以通过更改外部数据库中的测试数据来测试各种测试方案，从而减少所需的测试脚本数量。<br><strong>缺点</strong>：准备和计划框架的通用测试脚本，识别与格式化测试数据需要花费时间。框架设计的使用需要经验丰富的测试人员，因为它的丰富性，需要具备多种编程语言知识。</p><h5 id="五、关键字驱动框架"><a href="#五、关键字驱动框架" class="headerlink" title="五、关键字驱动框架"></a>五、关键字驱动框架</h5><p>是数据驱动框架的扩展。测试数据和测试脚本分离，进一步将测试脚本中的通用功能剥离出来，形成关键词。测试脚本本质上就是对一系列通用的或者自定义的关键词的调用。这样的好处是关键词可以在多个测试中复用，并且测试脚本更加易于维护。<br><strong>优点</strong>：运行此框架不需要脚本知识。可以独立于被测应用程序构建测试脚本。一个关键字可以在多个测试脚本中使用，代码是可重用的。<br><strong>缺点</strong>：设计框架和维护关键字对自动化的专业知识要求比较高。实现该框架的成本相对较高，而且设置起来比较耗时和复杂。</p><h4 id="八、软件测试的基本方法"><a href="#八、软件测试的基本方法" class="headerlink" title="八、软件测试的基本方法"></a>八、软件测试的基本方法</h4><h5 id="一、按是否查看程序内部结构"><a href="#一、按是否查看程序内部结构" class="headerlink" title="一、按是否查看程序内部结构"></a>一、按是否查看程序内部结构</h5><ul><li>黑盒测试：根据软件的规格对软件进行的测试。不考虑软件内部的运作原理，只关心输入和输出的结果。包括功能测试（检查软件的功能是否符合用户的需求，包括逻辑功能测试、界面测试、易用性测试和兼容性测试）和性能测试（时间性能主要是指软件的一个具体事务的响应时间，空间性能主要指是指软件运行时所消耗的系统资源）。</li><li>白盒测试：测试软件产品的内部结构和处理过程，不需测试软件产品的功能。要研究程序里面的源代码和程序结构。<h5 id="二、按是否运行程序"><a href="#二、按是否运行程序" class="headerlink" title="二、按是否运行程序"></a>二、按是否运行程序</h5></li><li>静态测试：测试不运行的部分，只是静态地检查程序代码、界面或文档可能存在的错误的过程，例如测试产品说明书，对此进行检查和审阅。</li><li>动态测试：指通过运行软件来检验软件的动态行为和运行结果的正确性。输入相应的测试数据，检查输出结果和预期结果是否相符。<h5 id="三、按阶段"><a href="#三、按阶段" class="headerlink" title="三、按阶段"></a>三、按阶段</h5></li><li>单元测试：最小规模的测试，测试某个功能或者代码块，由程序员来完成。</li><li>集成测试：指一个应用系统的各个部件的联合测试，以决定他们能否一起工作并没有冲突。部件可能是代码块、独立的应用、网络上的客户端或服务器端程序。尤其与客户服务器和分布式系统有关，一般集成测试以前，单元测试需要完成。</li><li>系统测试：将整个软件系统看做一个整体进行测试，包括对功能、性能以及软件所运行的软硬件环境进行测试。</li><li>验收测试：基于客户或最终用户的规格书的最终测试，基于用户一段时间的使用后，看软件是否满足客户要求。一般从功能、用户界面、性能、业务关联性进行测试，</li><li>回归测试：指在发生修改之后重新测试先前的测试以保证修改的正确性。理论上，软件产生新版本，都需要进行回归测试，验证以前发现和修复的错误是否在新软件版本上再次出现。<h5 id="四、其它类型测试"><a href="#四、其它类型测试" class="headerlink" title="四、其它类型测试"></a>四、其它类型测试</h5></li><li>冒烟测试：对新编译的每一个需要正式测试的软件版本进行测试。确认软件基本功能正常，可以进行后续的正式测试工作。执行人员是版本编译人员。</li><li>随机测试：指测试中的所有输入数据都是随机生成的，目的是模拟用户的真实操作，并发现一些边缘性的错误。</li></ul>]]></content>
    
    
    <categories>
      
      <category>测试开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript</title>
    <link href="/2022/05/12/JavaScript/"/>
    <url>/2022/05/12/JavaScript/</url>
    
    <content type="html"><![CDATA[<h4 id="一、声明函数的方法"><a href="#一、声明函数的方法" class="headerlink" title="一、声明函数的方法"></a>一、声明函数的方法</h4><ul><li><p>声明一个变量表达式，并定义该变量的表达式。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">var</span> func = <span class="hljs-keyword">function</span><span class="hljs-params">()</span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>定义一个function表达式，并指定该表达式的标识。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">func</span><span class="hljs-params">()</span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>使用JavaScript内置的Function对象构造</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> func = <span class="hljs-keyword">new</span> <span class="hljs-keyword">Function</span>(<span class="hljs-params"><span class="hljs-string">&quot;参数&quot;</span>,<span class="hljs-string">&quot;函数体&quot;</span></span>)<br></code></pre></td></tr></table></figure><h4 id="二、数据类型"><a href="#二、数据类型" class="headerlink" title="二、数据类型"></a>二、数据类型</h4><p>JS的八大数据类型：Number、String、Boolean、Undefined、Null、Object、Symbol、Bigint<br>基本数据类型：Number、String、Boolean、Undefined、Null、Symbol(ES6)<br>引用数据类型：Object、Array、Function<br>集合：set。映射：Map。<br><strong>区别</strong>：<br>1、 基本数据类型值（原始值）是存储在栈中的数据段，直接存储在变量访问的位置。存放js基本数据类型的变量存放的是基本类型数据的实际值。<br>引用数据类型值是存储在堆中的对象，即存储在变量处的值是一个指针，指向存储对象的内存地址。存放引用数据类型的变量是保存对它的引用，即指针。<br>2、复制变量时：对于存放基本数据类型的变量的交换，等于在一个新的作用域创建一个新的空间，新的空间与原空间不会互相影响。<br>对于存放引用数据类型的变量交换，并不会创建一个新的空间，而是让对象或方法和之前对象或方法同时指向一个原有空间（地址）。<br>3、参数传递不同：函数传参时，变量存储的基本类型的值只是把值传递给参数之后，参数和这个变量互不影响。<br>变量存储的引用数据类型值存储的是该引用值在堆内存中的内存地址，传递的值就是这个内存地址。</p></li></ul><p>确定一个值是哪种基本类型可以使用typeof操作符，确定一个值是哪种引用类型使用instanceof操作符。<br>typeof null输出object</p><h4 id="三、判断数据类型"><a href="#三、判断数据类型" class="headerlink" title="三、判断数据类型"></a>三、判断数据类型</h4><ul><li>最好的方法：Object.prototype.toString.call(a)，返回值为[object 类型] <img src="/2022/05/12/JavaScript/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD.png" class="" title="数据类型判断"> </li><li>typeof：对于原始类型来说，除了null都可以显示正确的类型。null和对象（函数除外返回function）都显示object。返回一个字符串，表示未经求值的操作数的类型。不能判断出Array、null和object之间区别。</li><li>instanceof：判断某个构造函数的prototype属性所指向的对象是否存在于另一个要检测的对象的原型链上。a instanceof b就是检测a是不是b的一个实例对象或者是b子类的一个实例对象。</li><li>valueOf：</li></ul><ol><li>booleanObject.valueOf()返回布尔对象的原始值。</li><li>stringObject.valueOf()返回String对象的原始值，原始值是由从String对象下来的所有对象继承的。</li><li>arrayObject.valueOf()返回Array对象的原始值，该值是由Array对象派生的所有对象继承。</li><li>NumberObject.valueOf()可以字符串返回数字，字符串的输出通常等于该数字。</li><li>DateObject.valueOf()方法返回Date对象的原始值。返回值和方法Date.getTime返回的值相等。<h4 id="四、JavaScript异步执行的机制"><a href="#四、JavaScript异步执行的机制" class="headerlink" title="四、JavaScript异步执行的机制"></a>四、JavaScript异步执行的机制</h4>1、所有同步任务都在主线程上执行，形成一个执行栈<br>2、主线程之外，还存在一个“任务队列”，只要异步任务有了运行结果，就在“任务队列”之中放置一个事件。<br>3、一旦“执行栈”中的所有同步任务执行完毕，系统就会读取“任务队列”，看看里面有哪些事件、哪些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。<br>4、主线程不断重复第三步。<h4 id="五、JS为什么要设计成单线程"><a href="#五、JS为什么要设计成单线程" class="headerlink" title="五、JS为什么要设计成单线程"></a>五、JS为什么要设计成单线程</h4>主要和js用途有关。js作为浏览器脚本语言，主要是实现用户与浏览器的交互，以及操作dom，这决定了它只能是单线程，否则会带来很复杂的同步问题。例如：若js是多线程，如果有一个线程要修改一个dom元素，另一个元素要删除这个dom元素，此时会发生冲突。<h4 id="六、this"><a href="#六、this" class="headerlink" title="六、this"></a>六、this</h4>this表示该方法所属的对象，单独使用时表示全局对象。<br>严格模式下，this是undefined。<h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h5>1、普通函数调用，this指向的是window<br>2、对象的方法，this指向的是该对象。一层作用域链时，this指的是该对象；多层作用域链时，this指的是距离方法最近的一层对象。<br>3、构造函数的调用，this指的是实例化的新对象。<br>4、apply和call调用时，this指向参数中的对象。<br>5、匿名函数调用，this指向的是全局对象。<br>6、定时器中调用，this指向的是全局变量。<h4 id="七、let、const、var"><a href="#七、let、const、var" class="headerlink" title="七、let、const、var"></a>七、let、const、var</h4></li></ol><ul><li>let声明的变量只在let命令所在的代码块内有效，不属于window对象，不必须初始化，未初始化时值为undefined。</li><li>const声明一个只读的常量，声明后值无法改变，也属于块级作用域，必须初始化。</li><li>const常量对象的属性可以更改，但无法为常量对象赋值。</li><li>const常量数组可以更改（改元素、添加元素），但无法为常量数组重新赋值。</li><li>var声明的全局作用域变量属于window对象，可以使用window.name调用该变量。声明的变量作用域是在当前位置的上下文中：函数内部（声明在函数内）或者全局（声明在函数外）。<strong>只有var声明的全局变量会变量声明提升</strong>，在任意位置声明变量和在代码开头声明变量是等价的。<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">var x<span class="hljs-operator">=</span><span class="hljs-number">10</span><span class="hljs-comment">;</span><br>&#123;<br>    var x<span class="hljs-operator">=</span><span class="hljs-number">2</span><span class="hljs-comment">;</span><br>&#125;<br>// x<span class="hljs-operator">=</span><span class="hljs-number">2</span>(为x重新赋值）<br></code></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> x=<span class="hljs-number">10</span>;<br>&#123;<br>    <span class="hljs-keyword">let</span> x=<span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-comment">// x=10,let只在&#123;&#125;内有效。&#125;</span><br></code></pre></td></tr></table></figure></li><li>相同作用域或块级作用域中，不能使用let关键字来重置let关键字声明的变量。</li><li>相同作用域或块级作用域中，不能使用let关键字来重置let关键字声明的变量。</li><li>相同作用域或块级作用域中，不能使用var关键字来重置let关键字声明的变量。</li><li>let关键字在不同作用域中，或不同块级作用域中是可以重新声明赋值的。<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs abnf">var x<span class="hljs-operator">=</span><span class="hljs-number">2</span><span class="hljs-comment">; //合法</span><br>let x<span class="hljs-operator">=</span><span class="hljs-number">3</span><span class="hljs-comment">; //不合法</span><br>&#123;<br>    var x<span class="hljs-operator">=</span><span class="hljs-number">4</span><span class="hljs-comment">; //合法</span><br>    let x<span class="hljs-operator">=</span><span class="hljs-number">3</span><span class="hljs-comment">; //不合法</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><strong>const和let都是块级作用域，都不能和它所在作用域内的其他变量或函数拥有相同名称。</strong></li><li>未声明的变量会被添加一个全局作用域，声明变量作用域是当前上下文。<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">x</span>(<span class="hljs-params"></span>) &#123;<br>  y = <span class="hljs-number">1</span>;   <span class="hljs-comment">// 在严格模式下会抛出ReferenceError</span><br>  <span class="hljs-keyword">var</span> z = <span class="hljs-number">2</span>;<br>&#125;<br>x();<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(y); <span class="hljs-comment">// &#x27;1&#x27;</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(z); <span class="hljs-comment">// ReferenceError: z is not defined</span><br></code></pre></td></tr></table></figure></li><li>声明变量在任何代码执行前创建，未声明的变量只有在执行赋值操作的时候才会被创建。<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(a);  <span class="hljs-comment">// 抛出ReferenceError。</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;still going...&#x27;</span>); <span class="hljs-comment">// 不会执行</span><br><span class="hljs-keyword">var</span> a;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(a);  <span class="hljs-comment">// &quot;undefined&quot;或&quot;&quot;（不同执行引擎的实现不同）</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;still going...&#x27;</span>); <span class="hljs-comment">// &#x27;still going...&#x27;</span><br></code></pre></td></tr></table></figure></li><li>声明变量是不可配置属性，而未声明变量是可配置的。<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf">var a <span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-comment">;</span><br><span class="hljs-attribute">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span><span class="hljs-comment">;</span><br>delete this.a<span class="hljs-comment">; // 在严格模式下抛出TypeError，非严格模式下执行失败且无任何提示</span><br>delete this.b<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li><li>函数内部声明的变量只能在函数内部使用，函数外部声明的变量可以全局使用。变量在函数内重新声明后在外部依旧保持原状态。<h4 id="八、匿名函数的调用方式"><a href="#八、匿名函数的调用方式" class="headerlink" title="八、匿名函数的调用方式"></a>八、匿名函数的调用方式</h4><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs arcade">（<span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)&#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(data);<br>&#125;）(<span class="hljs-string">&quot;222&quot;</span>);<br>(<span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)&#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(data);<br>&#125;(<span class="hljs-string">&quot;333&quot;</span>));<br>!<span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)&#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(data);<br>&#125;(<span class="hljs-string">&quot;444&quot;</span>);<br></code></pre></td></tr></table></figure><h4 id="九、类型转换"><a href="#九、类型转换" class="headerlink" title="九、类型转换"></a>九、类型转换</h4></li><li>显示转化：</li></ul><ol><li>转化为字符串类型（String）：String(a)</li><li>转换为数值类型：Number(a)。空字符串、空格字符串和null会转换为0，undefined转换为NaN，当其他类型无法转换为具体数值时，打印成NaN。</li><li>转化为布尔类型：Boolean(a)。数值类型中的0和NaN转化为false，其余转化为true。字符串类型中储粮空字符串其它都是true。undefined和null转换为false。</li><li>parseInt和parseFloat将字符串类型转换为数值类型，取字符串以整数开头的字符串中的数值。parseInt取整，parseFloat取小数。如果第一个非空格字符不是有效的数值字面量，则返回NaN。</li></ol><ul><li>隐式转换：</li></ul><ol><li>二元+：如果一个操作数是对象，把该操作数转换为原始值（toString和valueOf）。如果有操作数是字符串，另一个操作数也会转换为字符串并进行拼接。否则，两个操作数都转换为数值。</li><li>一元+、-、++：将操作数转转换为数值。</li><li>！：将操作数转换为布尔值再取反。</li><li>通常会按照需要转换操作数的类型进行转换。如”3”*”5”结果为15。<h4 id="十、-x3D-x3D-和-x3D-x3D-x3D"><a href="#十、-x3D-x3D-和-x3D-x3D-x3D" class="headerlink" title="十、&#x3D;&#x3D;和&#x3D;&#x3D;&#x3D;"></a>十、&#x3D;&#x3D;和&#x3D;&#x3D;&#x3D;</h4></li></ol><ul><li>&#x3D;&#x3D;&#x3D;：判断两者类型和值是否完全相等。如果一个值是NaN，则不相等。</li><li>&#x3D;&#x3D;：如果两个操作数的值类型不同，会先进行类型转换，再进行比较。</li></ul><ol><li>如果两个值类型相同，比较大小。</li><li>如果类型不同，会进行类型转换。</li><li>如果一个值是null，另一个值是undefined，则相等。</li><li>如果一个值是数值，另一个是字符串，就会将字符串转换为数值，再进行比较。</li><li>如果有一个值为布尔值，true转1false转0，再进行比较。</li><li>如果一个值为对象object，另一个值是数值或者字符串，就把对象转换为原始类型再比较。<h4 id="十一、小数求和（0-1-0-2-x3D-x3D-x3D-0-3）"><a href="#十一、小数求和（0-1-0-2-x3D-x3D-x3D-0-3）" class="headerlink" title="十一、小数求和（0.1+0.2&#x3D;&#x3D;&#x3D;0.3）"></a>十一、小数求和（0.1+0.2&#x3D;&#x3D;&#x3D;0.3）</h4>JS用Number类型来表示数字（整数或浮点数），通过64位来表示一个数字（1位符号位+11位指数位e+52位小数位f）</li></ol><ul><li>1 符号位，0表示正数，1表示负数</li><li>11 指数位（e），决定数值大小</li><li>52 尾数（f），小数部分（即有效数字），决定数值精度。<br>计算方式：尾数为1.xxx…，这些x指的就是52位尾数。指数位二进制-1023。指数位最大为11111111110。 <img src="/2022/05/12/JavaScript/%E6%95%B0%E5%80%BC%E8%A1%A8%E7%A4%BA%E6%96%B9%E5%BC%8F.png" class="" title="数值表示方式"> 最大安全数字：Number.MAX_SAFE_INTEGER &#x3D; Math.pow(2,53)-1，为一个16位整数。<br>最大数字：Number.MAX_VALUE &#x3D; 2^Math.pow(2,2046-1023)*（1.11111….（52个1））<br>两数相加，0.1和0.2均先转换为二进制数，尾数会发生无限循环，进行截断时会发生精度丢失。<br><strong>精度丢失可能会出现在进制换和对阶运算中</strong></li></ul>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue上</title>
    <link href="/2022/05/12/Vue/"/>
    <url>/2022/05/12/Vue/</url>
    
    <content type="html"><![CDATA[<h1 id="一、为什么要使用Vue"><a href="#一、为什么要使用Vue" class="headerlink" title="一、为什么要使用Vue"></a>一、为什么要使用Vue</h1><ul><li>体积小，轻量级框架，只关注视图层，是一个构建数据的视图集合。</li><li>双向数据绑定：让开发者不用再去操作DOM对象。</li><li>易用：容易上手，学习成本低。</li><li>可以直接直接将vue作为现成的服务端应用嵌入。实现组件化，将网页分割成可复用的组件，每个组件用来渲染网页中相应的地方。</li><li>高效：基于虚拟DOM，可以预先通过JavaScript进行各种计算，把最终的DMO操作计算出来并优化的技术。由于这种DOM操作属于预处理操作，并没有真实的操作DOM，没有浏览器渲染所以叫做虚拟DOM。</li><li>性能比react更强</li><li>社区和第三方组件库丰富。</li></ul><h1 id="★二、浏览器的虚拟DOM与真实DOM区别"><a href="#★二、浏览器的虚拟DOM与真实DOM区别" class="headerlink" title="★二、浏览器的虚拟DOM与真实DOM区别"></a>★二、浏览器的虚拟DOM与真实DOM区别</h1><ul><li><strong>虚拟DOM不会进行排版与重绘操作</strong>：虚拟DOM进行频繁修改，然后一次性比较并修改真实DOM中需要修改的部分，最后在真实DOM中进行排版与重绘，减少过多DOM节点排版与重绘的损耗。</li><li><strong>真实DOM频繁排版重绘的效率相当低</strong>：虚拟DOM有效降低大面积真实dom节点的重绘与排版，因为最终与真实DOM比较差异，可以只渲染局部。</li><li>虚拟DOM减少了一些情况下对真实DOM的操作，它对比后再选择更新哪些DOM，而不是全部删除再重建。虚拟DOM是内存中维护的DOM树，是在实体DOM上的一层抽象，查询修改操作都是先操作内存中的虚拟DOM。</li></ul><h2 id="2-1-虚拟-DOM解析过程"><a href="#2-1-虚拟-DOM解析过程" class="headerlink" title="2.1 虚拟 DOM解析过程"></a>2.1 虚拟 DOM解析过程</h2><ul><li>首先对将要插入文档中的DOM树结构进行分析，使用js对象将其表示出来，比如一个元素对象包含TagName、props和Children属性，然后将这些对象树保存下来，最后再将DOM片段插入到文档中。</li><li>当页面状态发生改变，需要对页面的DOM结构进行调整的时候，首先根据变更的状态，重新构建一颗对象树，然后将这棵新的对象树与旧的对象树进行比较，记录两棵树的差异。新旧虚拟DOM使用diff算法，得到<strong>patch</strong>（需要修改的部分），然后将这个patch打到浏览器DOM上，减少回流和重绘。</li><li>最后将记录的有差异的地方应用到真的DOM树中去，就完成了视图更新。</li></ul><h2 id="2-2-虚拟DOM最大优势"><a href="#2-2-虚拟DOM最大优势" class="headerlink" title="2.2 虚拟DOM最大优势"></a>2.2 虚拟DOM最大优势</h2><ol><li>将虚拟DOM作为一个兼容层，可以对接非Web端的系统，实现跨域开发。</li><li>虚拟DOM可以渲染到其它平台，比如实现SSR、同构渲染等等。</li><li>实现组件的高度抽象化。</li></ol><h2 id="2-3-虚拟DOM和真实DOM性能对比"><a href="#2-3-虚拟DOM和真实DOM性能对比" class="headerlink" title="2.3 虚拟DOM和真实DOM性能对比"></a>2.3 虚拟DOM和真实DOM性能对比</h2><p>首次渲染大量DOM时，由于多了一层虚拟DOM的计算，会比innerHTML插入慢。在真实DOM操作的时候进行针对性的优化时更快。</p><h2 id="2-4-Vue2和Vue3的diff算法区别"><a href="#2-4-Vue2和Vue3的diff算法区别" class="headerlink" title="2.4 Vue2和Vue3的diff算法区别"></a>2.4 Vue2和Vue3的diff算法区别</h2><p><strong>diff算法过程</strong>：</p><ol><li>首先，对比节点本身，判断是否为同一节点，如果为不相同节点，则删除该节点重新创建节点进行替换。</li><li>如果为相同节点，进行patchVnode，判断如何对该节点的子节点进行处理。<strong>同级比较，再比较子节点</strong>：先判断一方有子节点一方没有子节点的情况，如果新的children没有子节点，将旧的子节点移除。如果都有子节点，则进行updateChilren，判断如何对这些新老节点的子节点进行操作（diff核心）。</li><li><strong>递归比较子节点</strong>：匹配时，找到相同的子节点，递归比较子节点。在diff中，只对同层的子节点进行比较，放弃跨级的节点比较，使得时间复杂度从O(n3)变为O(n)。<br><strong>VUE2</strong>的核心diff算法采用了双端比较的算法，同时从新旧的children的两端开始进行比较，借助key值找到可复用的节点，再进行相关操作。相比React可以减少移动节点次数，减少不必要的性能损耗。<br><strong>VUE3</strong>：借鉴了ivi算法和inferno算法，在创建vnode时就确定其类型，以及在mount&#x2F;patch的过程中采用位运算来判断一个vnode的类型，在这个基础上再配合核心diff算法，使得性能得到了提升。该算法中还运用了动态规划的思想求解最长递归子序列。</li></ol><h1 id="三、VUE特性"><a href="#三、VUE特性" class="headerlink" title="三、VUE特性"></a>三、VUE特性</h1><ul><li><strong>数据驱动视图</strong>：在使用了vue的界面中，vue会监听数据的变化，从而自动重新渲染页面的结构，当页面数据发生变化时，页面会自动渲染，数据驱动视图是单向的数据绑定，程序员只用维护数据。</li></ul><img src="/2022/05/12/Vue/%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A8.png" class=""><ul><li><strong>双向数据绑定</strong>：在网页中，form表单用来采集数据，ajax用来提交数据。在填写表单时，双向数据绑定可以辅助开发者在不操作DOM的前提下，自动把用户填写的内容同步到数据源中。开发者不需要再手动操作DOM元素，来获取表单元素的最新值。js数据的变化会自动渲染到页面上，页面上采集的表单数据发生变化时，会被vue自动获取填充到js中。</li></ul> <img src="/2022/05/12/Vue/%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A.png" class=""><h1 id="四、MVC和MVVM模式"><a href="#四、MVC和MVVM模式" class="headerlink" title="四、MVC和MVVM模式"></a>四、MVC和MVVM模式</h1><ul><li><strong>MVC</strong>：MVC允许在不改变视图的情况下改变视图对用户输入的响应模式，用户对View的操作交给了Controller处理，在Controller中响应View的事件调用Model的接口对数据进行操作，一旦Model发生变化便通知相关视图进行更新。</li><li><strong>MVVM</strong>：指的是Model（当前页面渲染所需要的数据源）、View（当前页面所渲染的DOM结构）、ViewModel（VUE的实例，MVVM的核心，把当前页面的数据源和页面结构连接在一起）。当数据源发生变化时，会被ViewModel监听到，VM会根据最新的数据源自动更新页面的结构。<br>当表单元素的值发生变化时，也会被VM监听到，VM会把变化过后最新的值自动同步到Model数据源中。<br>MVVM与MVC最大的区别就是：它实现了View和Model的自动同步，也就是当Model的属性改变时，我们不用再自己手动操作DOM元素来改变View的显示，而是改变属性后该属性对应View层显示会自动改变。<br>VUE实例中的data相当于Model层，而ViewModel层的核心是VUE中的双向数据绑定，即Model变化时View可以实时更新，View变化也能让Model发生变化。<br>在MVVM架构中，引入了ViewModel的概念，ViewModel只关心数据和业务的处理，不关系View如何处理数据。在这种情况下，View和Model都可以独立出来，任何一方改变了也不一定需要改变另一方，并且可以把一些可复用的逻辑放在一个ViewModel中，让多个View复用这个ViewModel。<br>以VUE框架来举例，ViewModel就是组件的实例，View就是模板，Model的话在引入Vuex的情况下是完全可以和组件分离的。<br>MVVM还引入了一个隐式的Binder层，实现了View和ViewModel的绑定。这个隐式的Binder层就是VUE通过解析模板中的插值和指令从而实现View与ViewModel的绑定。<br>对于MVVM来说，最重要的并不是通过双向绑定或其他的方式将View与ViewModel绑定起来，而是通过ViewModel将视图中的状态和用户的行为分离出一个抽象。</li></ul><h1 id="★五、双向数据绑定与变化侦测"><a href="#★五、双向数据绑定与变化侦测" class="headerlink" title="★五、双向数据绑定与变化侦测"></a>★五、双向数据绑定与变化侦测</h1><p>VUE最大特点之一就是<strong>数据驱动视图</strong>，可以把数据理解为状态，而视图就是用户可以直观看到的页面，其原理是采用<strong>数据劫持结合发布者-订阅者</strong>（publisher-subscriber）默认的方式来实现（realize）。<br><strong>变化侦测就是追踪状态，数据一旦发生变化就要去更新视图</strong>。变化侦测在目前前端三大框架中都有涉及，在<strong>Angular</strong>中是通过脏值检测流程来实现变化侦测，在<strong>React</strong>中是通过对比虚拟DOM来实现变化侦测，在VUE中也有自己的一套变化侦测实现机制，当状态变化后，会通知到组件，组件内部再使用虚拟DOM进行对比。<br> <img src="/2022/05/12/Vue/%E5%8F%98%E5%8C%96%E4%BE%A6%E6%B5%8B.png" class=""></p><p><strong>数据变化更新视图，视图变化更新数据</strong>：输入框内容变化时，Data中数据同步变化，即视图到数据的变化，Data中的数据变化时，文本节点的内容同步变化，即数据到视图的变化。</p><h2 id="5-0-实现数据双向绑定步骤"><a href="#5-0-实现数据双向绑定步骤" class="headerlink" title="5.0 实现数据双向绑定步骤"></a>5.0 实现数据双向绑定步骤</h2><ul><li>bidirectional data binding</li><li><strong>实现监听器Observer</strong>：对数据对象进行遍历（traverse the data object），包括子属性对象的属性，利用Object.defineProperty()对属性（property）加上setter和getter，对这个对象的某个值赋值（ the assignment to this object）就会触发（tigger）setter，就能监听到数据变化。</li><li><strong>实现解析器Compile</strong>：解析（analysis）VUE模板（template）指令（instruction），将模板中的变量（variable）都替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点（node）绑定（binding）更新函数，添加监听（monitor）数据的订阅者（subscriber），一旦数据发生变动，收到通知，调用更新函数进行数据更新。</li><li><strong>实现订阅者Watcher</strong>：它是Observer和Complie之间通信的桥梁，主要的任务是订阅Observer中的属性值变化的消息，当收到属性值变化的消息时，触发（trigger）解析器Compile中对应的更新函数。</li><li><strong>实现一个订阅器Dep</strong>：订阅器采用发布-订阅设计模式，用来收集订阅者Watcher，对监听器Observer和订阅者Watcher进行统一管理。<br><strong>VUE框架是通过遍历数组和递归遍历对象，达到利用defineProperty对对象和数组的监听</strong>。</li></ul><h2 id="★5-1Observer数据劫持-观察者-Object-defineProperty"><a href="#★5-1Observer数据劫持-观察者-Object-defineProperty" class="headerlink" title="★5.1Observer数据劫持(观察者)+Object.defineProperty"></a>★5.1Observer数据劫持(观察者)+Object.defineProperty</h2><p>数据的观察者，让数据对象的读写操作都处于自己的监管下。</p><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> car = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Observer</span>(&#123;<br>    brand<span class="hljs-string">&#x27;:&#x27;</span><span class="hljs-variable constant_">BMW</span><span class="hljs-string">&#x27;,</span><br><span class="hljs-string">    &#x27;</span>price<span class="hljs-string">&#x27;:3000;</span><br><span class="hljs-string">&#125;)</span><br></code></pre></td></tr></table></figure><p>Observer类定义在src&#x2F;core&#x2F;observer&#x2F;index.js中。<br>Observer类会通过递归的方式把一个对象的所有属性都转化成可观测对象，下面是Observer的构造函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Observer</span> &#123;<br>  <span class="hljs-title function_">constructor</span> (value) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = value   <span class="hljs-comment">//value是需要被观察的数据对象</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">dep</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dep</span>()<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">vmCount</span> = <span class="hljs-number">0</span><br>    <br>    <span class="hljs-comment">// 给value新增一个__ob__属性，作为数据已经被Observer观察的标志</span><br>    <span class="hljs-comment">// 相当于为value打上标记，表示它已经被转化成响应式了，避免重复操作</span><br>    <span class="hljs-title function_">def</span>(value,<span class="hljs-string">&#x27;__ob__&#x27;</span>,<span class="hljs-variable language_">this</span>)<br>    <br>    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(value)) &#123;<br>        <span class="hljs-keyword">const</span> augment = hasProto ? protoAugment : copyAugment;<br>    <span class="hljs-comment">//如果value是数组，就使用observerArray遍历value，对value中每一个元素调用observe分别进行观察。</span><br>        <span class="hljs-title function_">augment</span>(value, arrayMethods, arrayKeys);<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">observerArray</span>(value);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">walk</span>(value);<br>      <span class="hljs-comment">//如果value是对象，则使用walk遍历value上的每个key，对每个key调用defineReactive来获得该key的set/get控制权。</span><br>    &#125;<br>  &#125;<br>  walk (<span class="hljs-attr">obj</span>: <span class="hljs-title class_">Object</span>) &#123;<span class="hljs-comment">//定义一个walk方法</span><br>    <span class="hljs-keyword">const</span> keys = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(obj)<br>    <span class="hljs-comment">//因为defineproperty只能劫持属性，所以遍历obj中各属性调用劫持函数</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; keys.<span class="hljs-property">length</span>; i++) &#123;<br>      <span class="hljs-title function_">defineReactive</span>(obj, keys[i])<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>defineReactive函数将一个对象转换为可观测的对象。obj为对象，key是对象的key，val是对象某个key的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">defineReactive</span> (obj,key,val) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span> === <span class="hljs-number">2</span>) &#123;<br>    val = obj[key]<span class="hljs-comment">//如果没有传val的值，val就等于obj[key]</span><br>  &#125;<br>  <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> val === <span class="hljs-string">&#x27;object&#x27;</span>)&#123;<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Observer</span>(val)<span class="hljs-comment">//如果val是对象，就递归劫持对象将其变成可观测的</span><br>  &#125;<br>  <span class="hljs-keyword">const</span> dep = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dep</span>()  <span class="hljs-comment">//实例化一个依赖管理器，生成一个依赖管理数组dep</span><br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(obj, key, &#123; <span class="hljs-comment">//设置对象的key属性，使得能够捕获到该属性值的set/get动作。</span><br>    <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>)&#123;    <span class="hljs-comment">//get操作，将Watcher的实例对象添加到Dep实例的依赖数组中。</span><br>      dep.<span class="hljs-title function_">depend</span>()    <span class="hljs-comment">// 在getter中收集依赖</span><br>      <span class="hljs-keyword">return</span> val;<br>    &#125;,<br>    <span class="hljs-title function_">set</span>(<span class="hljs-params">newVal</span>)&#123;    <span class="hljs-comment">//外部操作触发set时通过Dep实例的notify通知。</span><br>      <span class="hljs-keyword">if</span>(val === newVal)&#123;<br>          <span class="hljs-keyword">return</span>    <span class="hljs-comment">//如果修改值等于原来的值，就直接return</span><br>      &#125;<br>      val = newVal;  <span class="hljs-comment">//否则赋新值</span><br>      dep.<span class="hljs-title function_">notify</span>()   <span class="hljs-comment">// 在setter中通知各依赖的Watcher进行更新</span><br>    &#125;<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>Object.definePropertyd缺陷：<br>①<strong>无法监听数组下标变化和对象新增属性</strong>，通过数组下标添加元素，无法实时响应。<br>②<strong>只能劫持对象的属性</strong>，因此需要对每个对象的每个属性进行遍历，如果属性值也是对象那么需要深度遍历，能劫持一个完整的对象是更好的选择。<br>Object.keys(value).forEach(key&#x3D;&gt;this.convert(key,value[key]));<br><strong>vue能够监听到对象变化的场景</strong>：通过直接赋值的场景，如：<br>watchObj &#x3D; {name:”zyk”}<br><strong>vue无法监听到对象变化的场景</strong>：对象新增和删除属性。<br><strong>vue解决无法监听对象变化的方法</strong>：<br>①使用this.$se(object,key,value)，vue无法监听this.set修改原有属性。<br>②使用Object.assig()直接赋值。<br><strong>VUE监听数组</strong>：(重写了push)判断要监听的数据是否为数组，是数组的情况就将数组模拟成对象，将数组的方法名绑定到新创建的对象中，将对应数值原型的方法赋给自定义的方法。</p><p><strong>对比其他双向绑定的实现方法，数据劫持优势</strong>：<br>①<strong>无需显式调用</strong>：例如Vue使用数据劫持+发布订阅，直接可以通知变化并驱动视图，当数据变更后直接触发视图变更，而Angular的脏检测需要显式调用markForCheck，react需要显式调用setState。<br>②<strong>可精确得知变化数据</strong>：我们劫持了属性的setter，当属性值改变，我们可以精确货值变化的内容newVal，因此在这部分不需要额外的diff操作。否则我们只知道数据发生了变化而不知道具体哪些数据变化了，这个时候需要大量使用diff来找出变化值，这是额外性能损耗。</p><h2 id="5-2-Dep依赖收集"><a href="#5-2-Dep依赖收集" class="headerlink" title="5.2 Dep依赖收集"></a>5.2 Dep依赖收集</h2><p>它用来收集依赖、删除依赖和向依赖发送消息等。<br>依赖收集过程：谁用到了这个数据称为“谁依赖了这个数据”，给每个数据都建立一个依赖数组（因为一个数据可能被多处使用），谁依赖了这个数据我们就把谁放入到这个依赖数组中，当这个数据发生变化的时候，我们就去它对应的依赖数组中，把每个依赖都通知一遍，告诉他们应该更新了。<br><strong>在getter中收集依赖</strong>为谁用到了这个数据，就代表谁依赖这个数据。<br><strong>在setter中通知依赖更新</strong>。<br>每个数据都有一个依赖管理器Dep类：在src&#x2F;core&#x2F;observer&#x2F;dep.js中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Watcher</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./Watcher&quot;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dep</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">subs</span> = [] <span class="hljs-comment">//初始化了一个subs数组，用来存放依赖</span><br>    &#125;<br>    <span class="hljs-title function_">addSub</span>(<span class="hljs-params">sub</span>)&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">subs</span>.<span class="hljs-title function_">push</span>(sub) <span class="hljs-comment">//添加操作</span><br>    &#125;  <br>    <span class="hljs-comment">// 删除一个依赖</span><br>    removeSub (sub) &#123;<br>        <span class="hljs-title function_">remove</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">subs</span>, sub)<br>    &#125;        <br>    <span class="hljs-comment">// 添加一个依赖</span><br>    depend () &#123;<span class="hljs-comment">//在Object.defineProperty的get方法中调用</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">window</span>.<span class="hljs-property">target</span>) &#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">addSub</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">target</span>)<br>        &#125;<br>    &#125; <br>    <span class="hljs-comment">// 通知所有依赖更新</span><br>    notify () &#123;   <span class="hljs-comment">//在Object.defineProperty的set方法中调用</span><br>        <span class="hljs-keyword">const</span> subs = <span class="hljs-variable language_">this</span>.<span class="hljs-property">subs</span>.<span class="hljs-title function_">slice</span>()<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, l = subs.<span class="hljs-property">length</span>; i &lt; l; i++) &#123;<br>            subs[i].<span class="hljs-title function_">update</span>()<br>        &#125;<br>    &#125;<br>&#125;<br> <span class="hljs-comment">// 移除</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">remove</span> (arr, item) &#123;<br>  <span class="hljs-keyword">if</span> (arr.<span class="hljs-property">length</span>) &#123;<br>    <span class="hljs-keyword">const</span> index = arr.<span class="hljs-title function_">indexOf</span>(item)<br>    <span class="hljs-keyword">if</span> (index &gt; -<span class="hljs-number">1</span>) &#123;<br>      <span class="hljs-keyword">return</span> arr.<span class="hljs-title function_">splice</span>(index, <span class="hljs-number">1</span>)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-3-Watcher订阅者"><a href="#5-3-Watcher订阅者" class="headerlink" title="5.3 Watcher订阅者"></a>5.3 Watcher订阅者</h2><p>谁用到了数据，谁就是依赖，就为谁创建一个Watcher实例，在之后数据发生变化时，我们不去直接通知依赖更新，而是通知依赖对应的Watcher实例，由Watcher实例去通知真正的视图。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Dep</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./Dep&quot;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Watcher</span> &#123;<br>    <span class="hljs-title function_">constructor</span> (vm,expOrFn,cb) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">vm</span> = vm;  <span class="hljs-comment">//vm指当前的Vue实例</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">cb</span> = cb;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">getter</span> = <span class="hljs-title function_">parsePath</span>(expOrFn)<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">get</span>()  <span class="hljs-comment">//读取vm.$data中的值，同时会触发属性上的getter</span><br>    &#125;<br>    get () &#123;<br>        <span class="hljs-comment">// Watcher把自己设置到全局唯一的指定位置，就是window.target</span><br>        <span class="hljs-variable language_">window</span>.<span class="hljs-property">target</span> = <span class="hljs-variable language_">this</span>;<br>        <span class="hljs-keyword">const</span> vm = <span class="hljs-variable language_">this</span>.<span class="hljs-property">vm</span><br>        <span class="hljs-comment">//读取数据，触发这个数据的getter，因此Observer会收集依赖，将这个Watcher收集到Dep</span><br>        <span class="hljs-keyword">let</span> value = <span class="hljs-variable language_">this</span>.<span class="hljs-property">getter</span>.<span class="hljs-title function_">call</span>(vm, vm)<br>        <span class="hljs-comment">// 收集结束，清除Dep.target的内容</span><br>        <span class="hljs-variable language_">window</span>.<span class="hljs-property">target</span> = <span class="hljs-literal">undefined</span>;<br>        <span class="hljs-comment">// 返回读取到的数据值</span><br>        <span class="hljs-keyword">return</span> value<br>    &#125;<br>    update () &#123;<br>    <span class="hljs-comment">// 数据改变后，Dep会依次循环向依赖发通知，接到通知之后先获取它的旧数据</span><br>        <span class="hljs-keyword">const</span> oldValue = <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span><br>        <span class="hljs-comment">// 然后获取最新的值</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">get</span>()<br>        <span class="hljs-comment">// 将新旧值传给回调函数</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">cb</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">vm</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>, oldValue)<br>    &#125;<br>&#125;<br><span class="hljs-keyword">const</span> bailRE = <span class="hljs-regexp">/[^\w.$]/</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">parsePath</span> (path) &#123;<br>  <span class="hljs-keyword">if</span> (bailRE.<span class="hljs-title function_">test</span>(path)) &#123;<br>    <span class="hljs-keyword">return</span><br>  &#125;<br>  <span class="hljs-keyword">const</span> segments = path.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;.&#x27;</span>)<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">obj</span>) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; segments.<span class="hljs-property">length</span>; i++) &#123;<br>      <span class="hljs-keyword">if</span> (!obj) <span class="hljs-keyword">return</span><br>      obj = obj[segments[i]]<br>    &#125;<br>    <span class="hljs-keyword">return</span> obj<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>watcher类代码实现逻辑：</p><ol><li>当实例化Watcher类时，会先执行其构造函数。</li><li>在构造函数中调用this.get()方法。</li><li>在get()方法中，首先通过window.target&#x3D;this把实例自身赋给了全局的一个唯一对象window.target上，然后通过let value&#x3D;this.getter.call(vm, vm)获取一下被依赖的数据，获取被依赖数据的目的是触发该数据上面的getter。在getter里会调用dep.depend()收集依赖，而在dep.depend()中取到挂载window.target上的值并将其存入依赖数组中，在get()方法最后将window.target释放掉。</li><li>而当数据变化时，会触发数据的setter，在setter中调用了dep.notify()方法，在dep.notify()方法中，遍历所有依赖(即watcher实例)，执行依赖的update()方法，也就是Watcher类中的update()实例方法，在update()方法中调用数据变化的更新回调函数，从而更新视图。</li></ol><p>简单总结一下就是：Watcher先把自己设置到全局唯一的指定位置（window.target），然后读取数据。因为读取了数据，所以会触发这个数据的getter。接着，在getter中就会从全局唯一的那个位置读取当前正在读取数据的Watcher，并把这个Watcher收集到Dep中去。收集好之后，当数据发生变化时，会向Dep中的每个Watcher发送通知。通过这样的方式，Watcher可以主动去订阅任意一个数据的变化。<br> <img src="/2022/05/12/Vue/Watcher.png" class=""></p><p>不足之处<br>虽然我们通过Object.defineProperty方法实现了对object数据的可观测，但是仅能观测到object数据的取值及设置值，当我们向object数据里添加一对新的key&#x2F;value或删除一对已有的key&#x2F;value时，它是无法观测到的，导致当我们对object数据添加或删除值时，无法通知依赖，无法驱动视图进行响应式更新。<br>当然，Vue也注意到了这一点，为了解决这一问题，Vue增加了两个全局API:Vue.set和Vue.delete</p><h2 id="5-4-Compiler模板编译器"><a href="#5-4-Compiler模板编译器" class="headerlink" title="5.4 Compiler模板编译器"></a>5.4 Compiler模板编译器</h2><p>Compiler主要的作用是把Vue绑定的DOM节点（也就el标签绑定的id）遍历该节点的所有子节点，找出其中所有的v-指令和  {{ }} 。</p><ol><li>如果子节点含有v-指令，即是元素节点，则对这个元素添加监听事件。如果是v-on，则node.addEventListener(‘click’)，如果是v-model，则node-addEventListener(‘input’)。接着初始化模板元素，创建一个Watcher绑定这个元素节点。<br>通过hasAttribute去判断某个节点是否存在我们自定义的指令，通过getAttribute去获取这个指令所绑定的data对象具体的属性（也就是频道）。</li></ol><hr><p>v-model的具体作用是绑定input或textarea标签的输入事件，当输入改变时，改变data对象中具体属性的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (node.<span class="hljs-title function_">hasAttribute</span>(<span class="hljs-string">&quot;v-model&quot;</span>) &amp;&amp;(node.<span class="hljs-property">tagName</span> == <span class="hljs-string">&quot;INPUT&quot;</span> ||node.<span class="hljs-property">tagName</span> == <span class="hljs-string">&quot;TEXTAREA&quot;</span>)) &#123;<br>      <span class="hljs-comment">// 如果元素绑定了 v-model指令 且 元素为输入框</span><br>    node.<span class="hljs-title function_">addEventListener</span>(input<span class="hljs-string">&quot;,</span><br><span class="hljs-string">        (e) =&gt; &#123;</span><br><span class="hljs-string">          // 赋值对应的属性，更新订阅</span><br><span class="hljs-string">            const attr = node.getAttribute(&quot;</span>v-model<span class="hljs-string">&quot;);</span><br><span class="hljs-string">            this.$data[attr] = e.target.value;</span><br><span class="hljs-string">        &#125;,</span><br><span class="hljs-string">        false</span><br><span class="hljs-string">    );</span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure><hr><p>v-bind就是响应订阅</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (node.<span class="hljs-title function_">hasAttribute</span>(<span class="hljs-string">&quot;v-bind&quot;</span>)) &#123;<br>    <span class="hljs-keyword">const</span> attr = node.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">&quot;v-bind&quot;</span>);<br>    <span class="hljs-comment">// 创建 观众 - 自动订阅频道</span><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Watcher</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">$data</span>, attr, <span class="hljs-function">(<span class="hljs-params">newVal</span>) =&gt;</span> &#123;<br>    node.<span class="hljs-property">innerText</span> = newVal;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>如果子节点是文本节点，即  {{ data }} ，则用正则表达式取出  {{ data }} 中的data，然后var initText &#x3D; this.vm[exp]，用initText去代替其中的data。<br>解析  {{ }} 跟v-bind的思路一样，区别在于双括号语法是存在于文本节点中的，我们无法通过getAttribute去直接获取，所以我们要解析存在双括号语法的文本节点：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (node.<span class="hljs-property">childNodes</span>.<span class="hljs-property">length</span> !== <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">const</span> childList = node.<span class="hljs-property">childNodes</span>;<br>    childList.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">child</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (child.<span class="hljs-property">nodeType</span> === <span class="hljs-number">3</span>) &#123;<br>            <span class="hljs-comment">// 文本节点</span><br>            <span class="hljs-title function_">replaceStr</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">$data</span>, child);<br>        &#125;<br>    &#125;);<br>&#125;<br><span class="hljs-comment">//src/utils/index.js</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Watcher</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../core/Watcher&quot;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> replaceStr = <span class="hljs-keyword">function</span> (<span class="hljs-params">data, node</span>) &#123;<br>    <span class="hljs-keyword">const</span> replaceReg = <span class="hljs-regexp">/\&#123;\&#123;((?:.|\r?\n)+?)\&#125;\&#125;/g</span>;<br>    <span class="hljs-keyword">const</span> attrReg = <span class="hljs-regexp">/\&#123;\&#123;((?:.|\r?\n)+?)\&#125;\&#125;/</span>;<br>    <span class="hljs-keyword">const</span> str = node.<span class="hljs-property">data</span>;<br>    <span class="hljs-keyword">const</span> attr = str.<span class="hljs-title function_">match</span>(attrReg)[<span class="hljs-number">1</span>].<span class="hljs-title function_">trim</span>();<br>    <span class="hljs-comment">// 初始化赋值</span><br>    <span class="hljs-keyword">const</span> initRes = str.<span class="hljs-title function_">replace</span>(replaceReg, <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) &#123;<br>        <span class="hljs-keyword">return</span> data[attr];<br>    &#125;);<br>    node.<span class="hljs-property">data</span> = initRes;<br>    <span class="hljs-comment">// 创建 观众 - 自动订阅频道</span><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Watcher</span>(data, attr, <span class="hljs-function">(<span class="hljs-params">newVal</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">const</span> res = str.<span class="hljs-title function_">replace</span>(replaceReg, <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) &#123;<br>            <span class="hljs-keyword">return</span> newVal;<br>        &#125;);<br>        node.<span class="hljs-property">data</span> = res;<br>    &#125;);<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Compile</span>&#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">el, vm</span>)&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">$el</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">isElementNode</span>(el) ? <span class="hljs-attr">el</span>: <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(el);<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">$vm</span> = vm;<br>        <span class="hljs-comment">// 在内存中创建一个和 $el相同的元素节点</span><br>        <span class="hljs-keyword">let</span> fragment = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">node2fragment</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">$el</span>);<br>        <span class="hljs-comment">// 解析模板($el节点)</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">compile</span>(fragment);<br>        <span class="hljs-comment">// 将解析后的节点重新挂载到DOM树上</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">$el</span>.<span class="hljs-title function_">appendChild</span>(fragment);<br>    &#125;<br>    <span class="hljs-comment">// 判断node是否为元素节点</span><br>    <span class="hljs-title function_">isElementNode</span>(<span class="hljs-params">node</span>) &#123;<br>        <span class="hljs-keyword">return</span> node.<span class="hljs-property">nodeType</span> === <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 判断是否为v-开头的Vue指令</span><br>    <span class="hljs-title function_">isDirective</span>(<span class="hljs-params">attr</span>) &#123;<br>        <span class="hljs-keyword">return</span> attr.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&#x27;v-&#x27;</span>);<br>    &#125;<br>    <span class="hljs-title function_">isSpecialisDirective</span>(<span class="hljs-params">attr</span>)&#123;<br>        <span class="hljs-keyword">return</span> attr.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&#x27;@&#x27;</span>);<br>    &#125;<br>    <span class="hljs-title function_">compile</span>(<span class="hljs-params">fragment</span>)&#123;<br>        <span class="hljs-comment">// 获取根节点的子节点</span><br>        <span class="hljs-keyword">let</span> childNodes  = fragment.<span class="hljs-property">childNodes</span>;<br>        [...childNodes].<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">child</span> =&gt;</span>&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">isElementNode</span>(child))&#123;<br>                <span class="hljs-comment">// 解析元素节点的属性,查看是否存在Vue指令</span><br>                <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">compileElement</span>(child);<br>                <span class="hljs-comment">// 如果子节点也是元素节点,则递归执行该函数</span><br>                <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">compile</span>(child);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">// 解析文本节点,查看是否存在&quot;&#123;&#123;&#125;&#125;&quot;</span><br>                <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">compileText</span>(child);<br>            &#125;<br>        &#125;)<br>    &#125;<br>    <span class="hljs-comment">// 编译元素</span><br>    <span class="hljs-title function_">compileElement</span>(<span class="hljs-params">node</span>)&#123;<br>        <span class="hljs-comment">// 获取元素节点的所有属性</span><br>        <span class="hljs-keyword">let</span> attrs = node.<span class="hljs-property">attributes</span>;<br>        <span class="hljs-comment">// 遍历所有属性,查找是否存在Vue指令</span><br>        [...attrs].<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">attr</span> =&gt;</span>&#123;<br>            <span class="hljs-comment">// name: 属性名, expr: 属性值</span><br>            <span class="hljs-keyword">let</span> &#123;name, <span class="hljs-attr">value</span>:expr&#125; = attr;<br>            <span class="hljs-comment">// 判断是不是指令</span><br>            <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">isDirective</span>(name))&#123;<br>                <span class="hljs-keyword">let</span> [,directive] = name.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;-&#x27;</span>);<br>                <span class="hljs-comment">// 如果为指令则去设置该节点的响应式函数</span><br>                compileUtil[directive](node, expr, <span class="hljs-variable language_">this</span>.<span class="hljs-property">$vm</span>);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">isSpecialisDirective</span>(name))&#123;<br>                <span class="hljs-keyword">let</span> eventName = name.<span class="hljs-title function_">substr</span>(<span class="hljs-number">1</span>);<br>                compileUtil[<span class="hljs-string">&#x27;on&#x27;</span>](node, eventName, expr, <span class="hljs-variable language_">this</span>.<span class="hljs-property">$vm</span>);<br>            &#125;<br>        &#125;)<br>    &#125;<br>    <span class="hljs-comment">// 编辑文本</span><br>    <span class="hljs-title function_">compileText</span>(<span class="hljs-params">node</span>)&#123;<br>        <span class="hljs-keyword">let</span> content = node.<span class="hljs-property">textContent</span>;<br>        <span class="hljs-comment">// 匹配 &#123;&#123;xxx&#125;&#125;</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-regexp">/\&#123;\&#123;(.+?)\&#125;\&#125;/</span>.<span class="hljs-title function_">test</span>(content))&#123;<br>            compileUtil[<span class="hljs-string">&#x27;contentText&#x27;</span>](node, content, <span class="hljs-variable language_">this</span>.<span class="hljs-property">$vm</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 把节点移动到内存中</span><br>    <span class="hljs-title function_">node2fragment</span>(<span class="hljs-params">node</span>)&#123;<br>        <span class="hljs-comment">// 创建文档碎片</span><br>        <span class="hljs-keyword">let</span> fragment = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createDocumentFragment</span>();<br>        <span class="hljs-keyword">let</span> firstChild;<br>        <span class="hljs-keyword">while</span>(firstChild = node.<span class="hljs-property">firstChild</span>)&#123;<br>            <span class="hljs-comment">// appendChild具有移动性</span><br>            fragment.<span class="hljs-title function_">appendChild</span>(firstChild);<br>        &#125;<br>        <span class="hljs-keyword">return</span> fragment;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">const</span> compileUtil = &#123;<br>    <span class="hljs-title function_">getValue</span>(<span class="hljs-params">expr, vm</span>)&#123;<br>        <span class="hljs-keyword">let</span> valOrFn = expr.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;.&#x27;</span>).<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">totalValue, key</span>) =&gt;</span>&#123;<br>            <span class="hljs-keyword">if</span>(!totalValue[key]) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">return</span> totalValue[key];<br>        &#125;, vm)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> valOrFn === <span class="hljs-string">&#x27;function&#x27;</span> ? valOrFn.<span class="hljs-title function_">call</span>(vm) : valOrFn;<br>    &#125;,<br>    <span class="hljs-title function_">setValue</span>(<span class="hljs-params">expr, vm, value</span>)&#123;<br>        <span class="hljs-keyword">return</span> expr.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;.&#x27;</span>).<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">totalValue, key, index, arr</span>) =&gt;</span>&#123;<br>            <span class="hljs-keyword">if</span>(index === arr.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>) totalValue[key] = value;<br>            <span class="hljs-keyword">return</span> totalValue[key];<br>        &#125;, vm.<span class="hljs-property">$data</span>)<br>    &#125;,<br>    <span class="hljs-title function_">getContentValue</span>(<span class="hljs-params">content, vm</span>)&#123;<br>        <span class="hljs-keyword">return</span> content.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\&#123;\&#123;(.+?)\&#125;\&#125;/g</span>, <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getValue</span>(args[<span class="hljs-number">1</span>], vm);<br>         &#125;)<br>    &#125;,<br>    <span class="hljs-title function_">contentText</span>(<span class="hljs-params">node, content, vm</span>)&#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-title function_">fn</span> = (<span class="hljs-params"></span>) =&gt;&#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">textUpdater</span>(node, <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getContentValue</span>(content, vm));<br>        &#125;<br>        <span class="hljs-keyword">let</span> resText = content.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\&#123;\&#123;(.+?)\&#125;\&#125;/g</span>, <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span>&#123;<br>            <span class="hljs-comment">// args[1] 为&#123;&#123;xxx&#125;&#125;中的xxx</span><br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Watcher</span>(vm, args[<span class="hljs-number">1</span>], fn);<br>            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getValue</span>(args[<span class="hljs-number">1</span>], vm);<br>        &#125;);<br>        <span class="hljs-comment">// 首次解析直接替换文本内容</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">textUpdater</span>(node, resText);<br>    &#125;,<br>    <span class="hljs-title function_">text</span>(<span class="hljs-params">node, expr, vm</span>)&#123;<br>        <span class="hljs-keyword">let</span> value = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getValue</span>(expr, vm);<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">textUpdater</span>(node, value);<br>        <span class="hljs-keyword">let</span> <span class="hljs-title function_">fn</span> = (<span class="hljs-params"></span>) =&gt;<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">textUpdater</span>(node, <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getValue</span>(expr, vm));<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Watcher</span>(vm, expr, fn);<br>    &#125;,<br>    <span class="hljs-title function_">textUpdater</span>(<span class="hljs-params">node, value</span>)&#123;<br>        node.<span class="hljs-property">textContent</span> = value;<br>    &#125;,<br>    <span class="hljs-title function_">html</span>(<span class="hljs-params">node, expr, vm</span>)&#123;<br>        <span class="hljs-keyword">let</span> value = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getValue</span>(expr, vm);<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">htmlUpdater</span>(node, value);<br>        <span class="hljs-keyword">let</span> <span class="hljs-title function_">fn</span> = (<span class="hljs-params"></span>) =&gt;<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">htmlUpdater</span>(node, <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getValue</span>(expr, vm));<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Watcher</span>(vm, expr, fn);<br>    &#125;,<br>    <span class="hljs-title function_">htmlUpdater</span>(<span class="hljs-params">node, value</span>)&#123;<br>        node.<span class="hljs-property">textContent</span> = value;<br>    &#125;,<br>    <span class="hljs-title function_">model</span>(<span class="hljs-params">node, expr, vm</span>)&#123;<br>        <span class="hljs-keyword">let</span> value = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getValue</span>(expr, vm);<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">modelUpdater</span>(node, value);<br>        <span class="hljs-keyword">let</span> <span class="hljs-title function_">fn</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">modelUpdater</span>(node, <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getValue</span>(expr, vm));<br>        node.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;input&#x27;</span>, <span class="hljs-function">()=&gt;</span>&#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setValue</span>(expr, vm, node.<span class="hljs-property">value</span>);<br>        &#125;)<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Watcher</span>(vm, expr, fn)<br>    &#125;,<br>    <span class="hljs-title function_">modelUpdater</span>(<span class="hljs-params">node, value</span>)&#123;<br>        node.<span class="hljs-property">value</span> = value;<br>    &#125;,<br>    <span class="hljs-title function_">on</span>(<span class="hljs-params">node, eventName, expr, vm</span>)&#123;<br>        <span class="hljs-comment">// 改变this为vm实例</span><br>        <span class="hljs-keyword">let</span> fn = vm.<span class="hljs-property">$option</span>.<span class="hljs-property">methods</span>[expr].<span class="hljs-title function_">bind</span>(vm);<br>        <span class="hljs-comment">// 添加事件</span><br>        node.<span class="hljs-title function_">addEventListener</span>(eventName, fn);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h1 id="六、组件化好处"><a href="#六、组件化好处" class="headerlink" title="六、组件化好处"></a>六、组件化好处</h1><ol><li>提高了开发效率</li><li>方便重复使用</li><li>简化了调试步骤</li><li>提升了项目的可维护性</li><li>便于协同开发</li></ol><h1 id="七、★VUE的指令"><a href="#七、★VUE的指令" class="headerlink" title="七、★VUE的指令"></a>七、★VUE的指令</h1><p>VUE的实例对象。<br> <img src="/2022/05/12/Vue/%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1.png" class=""></p><h2 id="7-1-内容渲染指令（v-text、、v-html）"><a href="#7-1-内容渲染指令（v-text、、v-html）" class="headerlink" title="7.1 内容渲染指令（v-text、、v-html）"></a>7.1 内容渲染指令（v-text、 {{ }} 、v-html）</h2><p>用来辅助开发者渲染DOM元素的文本内容。</p><ul><li><strong>v-text</strong>：会覆盖标签原有内容。<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-text</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span>用户名<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure>此时p标签显示的是username而非“用户名”。</li><li> {{ }} ：插值表达式，专门解决内容覆盖问题，只是内容的占位符，不会覆盖原有内容。<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>姓名：&#123;&#123;username&#125;&#125;<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure>此时p标签显示的是”姓名：username对应的值”。</li><li>v-html：v-text和插值表达式只能渲染纯文本内容，如果要把包含HTML标签的字符串渲染为页面的HTML元素，则需要使用v-html指令。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-html</span>=<span class="hljs-string">&quot;discription&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>description: &#x27;<span class="hljs-tag">&lt;<span class="hljs-name">h4</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color:red; font-weight:bold&quot;</span>&gt;</span>欢迎<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span>&#x27;<br></code></pre></td></tr></table></figure><p>使用如上方法时，username、discription等值都要写在data里，其中el要指向整个大盒子，调用data里的元素都要放到这个大盒子里才能生效。</p><h2 id="7-2-属性绑定指令（v-bind）"><a href="#7-2-属性绑定指令（v-bind）" class="headerlink" title="7.2 属性绑定指令（v-bind）"></a>7.2 属性绑定指令（v-bind）</h2><ul><li><strong>v-bind</strong>：为元素的<strong>属性</strong>动态绑定属性值，单向绑定，可以简写为冒号:。<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-bind:placeholder</span>=<span class="hljs-string">&quot;tips&quot;</span>&gt;</span><br>tips: &#x27;请输出用户名&#x27;<br></code></pre></td></tr></table></figure>输入框中默认显示‘请输入用户名’<br>还支持简单JavaScript表达式的运算，不能一串逻辑语句，如：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-bind:id</span>=<span class="hljs-string">&quot;&#x27;list-&#x27;+id&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>属性值tips、id写在data里。</p><h2 id="7-3-事件绑定指令（v-on）"><a href="#7-3-事件绑定指令（v-on）" class="headerlink" title="7.3 事件绑定指令（v-on）"></a>7.3 事件绑定指令（v-on）</h2><p>用来辅助程序员为DOM元素绑定事件监听。可以简写为@，如@click</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">&quot;addCount(1)&quot;</span>&gt;</span>+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure><p>当点击该按钮时，触发函数addCount。在methods下定义事件处理函数，可以省略function和冒号，调用data里面变量直接用this.变量名。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">methods</span>: &#123;<br>    <span class="hljs-title function_">add</span>(<span class="hljs-params">参数<span class="hljs-number">1</span>, 参数<span class="hljs-number">2.</span>..</span>)&#123;<br>        <span class="hljs-comment">//操作</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>原生DOM对象有onclick、oninput、onkeyup等原生事件，替换为vue的事件绑定形式后分别为v-on:click、v-on:input、v-on:keyup</strong><br><font color=red>若要修改样式，调用时不用传参，在methods传参e（代表事件），vue提供了内置变量，名字叫$event，原生DOM的事件对象e。</font><br>样式修改，如果必须传参，如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;add(1,$event)&quot;</span>&gt;</span>+N<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>methods: &#123;<br>    add(n,e) &#123;<br>        this.count += n;<br>        if(this.count % 2 === 0)&#123;<br>            e.target.style.backgroundColor = &#x27;red&#x27;;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>事件修饰符</strong>：加在绑定事件后面。如</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span> @<span class="hljs-attr">click.prevent</span>=<span class="hljs-string">&quot;show&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><p>此时点击会执行show，但会阻止原有跳转操作。<br> <img src="/2022/05/12/Vue/%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6.png" class=""></p><p><strong>事件冒泡</strong>：父元素和子元素有相同的事件，当触发子元素事件时，会向上冒泡，同时触发父元素事件。<br><strong>按键修饰符</strong>：在监听键盘事件时，需要判断详细的按键，此时为键盘相关的事件添加按键修饰符，如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> @<span class="hljs-attr">keyup.enter</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>当按下enter按键时执行vm.submit()</p><h2 id="7-4-双向绑定指令（v-model）"><a href="#7-4-双向绑定指令（v-model）" class="headerlink" title="7.4 双向绑定指令（v-model）"></a>7.4 双向绑定指令（v-model）</h2><p>辅助开发者在不操作DOM的前提下，快速获取表单的数据，可以和input、textarea、select使用。<br>真正实现靠的是v-bind绑定响应式数据和触发oninput时间并传递数据。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;searchText&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>相当于：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v:bind:value</span>=<span class="hljs-string">&quot;searchText&quot;</span> <span class="hljs-attr">v-on:input</span>=<span class="hljs-string">&quot;searchText=$event.target.value&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>从html5开始，input每次输入都会触发oninput事件，所以输入input的内容会绑定到searchText中，于是searchText的值就被改变。<br>$event指代当前触发的事件对象，$event.target指代当前触发的事件对象的DOM，$event.target.value就是当前DOM的value值。<br>在@input方法中，value&#x3D;&gt;searchText，在:value，searchText&#x3D;&gt;value。<br>表单绑定v-model</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;message&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript">            <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#app&quot;</span>,</span><br><span class="language-javascript">            <span class="hljs-attr">data</span>: &#123;</span><br><span class="language-javascript">                <span class="hljs-attr">message</span>: <span class="hljs-string">&quot;v-model的使用&quot;</span></span><br><span class="language-javascript">            &#125;</span><br><span class="language-javascript">        &#125;)</span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><p>当我们在输入框输入内容时，因为input中的v-model绑定了message，此时v-model相当于value属性。输入的内容传给message，message发生改变。<br>当message发生改变时，因为使用Mustache语法，将message的值插入到DOM中，所以DOM会发送相应的改变。<br>复选框：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;agree&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;agree&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;isAgree&quot;</span>&gt;</span>同意协议<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>您选择的是&#123;&#123;isAgree&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">:disabled</span>=<span class="hljs-string">&quot;!isAgree&quot;</span>&gt;</span>下一步<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript">      <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#app&quot;</span>,</span><br><span class="language-javascript">      <span class="hljs-attr">data</span>: &#123;</span><br><span class="language-javascript">        <span class="hljs-attr">isAgree</span>: <span class="hljs-literal">false</span>,</span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript">    &#125;)</span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><p>此时v-model相当于checked属性。<br>下拉菜单：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;city&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span>请选择城市<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span>北京<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span>上海<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure> <img src="/2022/05/12/Vue/%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E4%BF%AE%E9%A5%B0%E7%AC%A6.png" class=""><h2 id="7-5-★★★条件渲染指令（v-if、v-show、v-else-if、v-else）"><a href="#7-5-★★★条件渲染指令（v-if、v-show、v-else-if、v-else）" class="headerlink" title="7.5 ★★★条件渲染指令（v-if、v-show、v-else-if、v-else）"></a>7.5 ★★★条件渲染指令（v-if、v-show、v-else-if、v-else）</h2><p>用来按需控制DOM的显示与隐藏，可以设置值等于某个值，该值的真假在js中修改，在data中设置。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;state===200&quot;</span>&gt;</span>被v-if控制<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">&quot;state===200&quot;</span>&gt;</span>被v-show控制<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>!!!!!!!! v-if与v-show区别</strong>：<br>v-show只是在display:none和display:block之间切换，无论初始条件是什么都会被渲染出来，后面只需要切换CSS，DOM还是一直保留着的。v-show在初始渲染时有更高的开销，但是切换开销很小，更适合频繁切换的场景。<br>v-if当属性初始值为false时，组件就不会渲染，直到条件为true，并且切换条件时会触发销毁&#x2F;挂载组件，所以总的来说在切换时开销更高，更适合于不经常切换的场景。<br>基于v-if的这种惰性渲染机制，可以在必要的时候才去渲染组件，减少整个页面的初始渲染开销。<br><strong>v-else-if</strong>指令，必须与v-if连续使用。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;type===&#x27;A&#x27;&quot;</span>&gt;</span>优秀<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-else-if</span>=<span class="hljs-string">&quot;type===&#x27;B&#x27;&quot;</span>&gt;</span>良好<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-else-if</span>=<span class="hljs-string">&quot;type===&#x27;C&#x27;&quot;</span>&gt;</span>一般<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-else</span>&gt;</span>差<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="7-6-列表渲染指令（v-for）"><a href="#7-6-列表渲染指令（v-for）" class="headerlink" title="7.6 列表渲染指令（v-for）"></a>7.6 列表渲染指令（v-for）</h2><p>用于辅助开发者基于一个数组来循环渲染一个列表结构。v-for指令需要使用item in items形式的特殊语法，其中items是待循环的数组，item是被循环的每一项，index是当前项的索引，即(item, index) in items</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(item,index) in list&quot;</span>&gt;</span>姓名是：&#123;&#123;item.name&#125;&#125;, 索引是：&#123;&#123;index&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>data: &#123;<br>    list: [<br>        &#123; id: 1, name: &#x27;zs&#x27; &#125;,<br>        &#123; id: 2, name: &#x27;ls&#x27; &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>只要用到v-for指令，一定要绑定一个key属性，而且尽量把id作为key的值（不重复），key的值只能是字符串或数字类型。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(item, index) in list&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;item.id&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br></code></pre></td></tr></table></figure><p>①key的值只能是字符串或数字类型。<br>②key的值必须具有唯一性。<br>③建议把数据项id属性的值作为key的值，因为id属性的值具有唯一性。<br>④使用index的值当做key的值没有任何意义，因为index的值不具有唯一性。<br>⑤建议使用v-for指令时一定要指定key的值，这样既提升性能、又防止列表状态紊乱。</p><h1 id="八、过滤器Filters-侦听器watch-计算属性computed"><a href="#八、过滤器Filters-侦听器watch-计算属性computed" class="headerlink" title="八、过滤器Filters|侦听器watch|计算属性computed"></a>八、过滤器Filters|侦听器watch|计算属性computed</h1><h2 id="8-1-过滤器Filters"><a href="#8-1-过滤器Filters" class="headerlink" title="8.1 过滤器Filters"></a>8.1 过滤器Filters</h2><p>常用于文本的格式化，可以用于插值表达式和v-bind属性绑定。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; message | capitalize &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-bind:id</span>=<span class="hljs-string">&quot;rawId | formatId&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>对p标签中的message借助capitalize进行格式化，显示的是返回值。对div标签的id对应的rawId的值用formatId进行格式化。<br>在Vue实例对象中，用filters声明过滤器函数，里面直接放函数，<strong>过滤器一定要有返回值</strong>。过滤器函数的形参值是|前面的值。</p><ul><li><strong>私有过滤器</strong>：定义到VUE实例中的过滤器都是私有过滤器，只能在当前vm实例所控制的el区域中使用。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>    <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,<br>    <span class="hljs-attr">data</span>: &#123;<br>        <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;hello&#x27;</span><br>    &#125;,<br>    <span class="hljs-attr">filters</span>:&#123;<br>        <span class="hljs-title function_">capitalize</span>(<span class="hljs-params">val</span>)&#123;<br>            <span class="hljs-keyword">const</span> first = val.<span class="hljs-title function_">charAt</span>(<span class="hljs-number">0</span>).<span class="hljs-title function_">toUpperCase</span>();<br>            <span class="hljs-keyword">const</span> other = val.<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">return</span> first + other;<br>        &#125;<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure></li><li><strong>全局过滤器</strong>：定义到vm实例之外。<strong>放到main.js之中</strong><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">filter</span>(<span class="hljs-string">&#x27;capitalize&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">str</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> str.<span class="hljs-title function_">charAt</span>(<span class="hljs-number">0</span>).<span class="hljs-title function_">toUpperCase</span>() + str.<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>);<br>&#125;)<br></code></pre></td></tr></table></figure>可以连续使用过滤器，如data|first|second|third，此时先把data用first处理，结果再用second处理，结果再用third处理。<br>过滤器可以传参：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; message | filterA(arg1, arg2) &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>Vue.filter(&#x27;filterA&#x27;, (msg, arg1, arg2) =&gt; &#123;<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="8-2-侦听器"><a href="#8-2-侦听器" class="headerlink" title="8.2 侦听器"></a>8.2 侦听器</h2><p>watch侦听器允许开发者监视数据的变化从而针对数据的变化做特定的操作。<strong>要监视哪个数据的变化就把数据名作为方法名</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>    <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,<br>    <span class="hljs-attr">data</span>: &#123; <span class="hljs-attr">username</span>: <span class="hljs-string">&#x27;&#x27;</span> &#125;,<br>    <span class="hljs-attr">watch</span>: &#123;<br>        <span class="hljs-title function_">username</span>(<span class="hljs-params">newVal, oldVal</span>)&#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newVal, oldVal);<br>        &#125;<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>此时监听username值的变化，当发生变化时，打印旧值和新值。</p><ul><li><strong>方法格式的侦听器</strong>：无法在刚进入页面的时候自动触发，如果侦听的是一个对象，如果<strong>对象中的属性发生变化，不会触发侦听器</strong>。</li><li><strong>对象格式的侦听器</strong>：可以通过immediate选项，让侦听器自动触发，此时用handler属性。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">watch</span>: &#123;<br>    <span class="hljs-attr">username</span>: &#123;<br>        <span class="hljs-title function_">handler</span>(newVal, oldVal)<br>    &#125;,<br>    <span class="hljs-attr">immediate</span>: <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure>可以通过deep选项，让侦听器深度监听对象中每个属性的变化，对象中任何一个属性发生变化，都会触发对象的侦听器。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">watch</span>: &#123;<br>    <span class="hljs-attr">info</span>: &#123;<br>        <span class="hljs-title function_">handler</span>(<span class="hljs-params">newVal</span>)&#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newVal)<br>        &#125;,<br>        <span class="hljs-attr">deep</span>: <span class="hljs-literal">true</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>如果要侦听的是对象的子属性的变化，则必须包裹一层单引号，如’watch: {‘info.username’(newVal, oldVal){}}<h2 id="8-3-计算属性"><a href="#8-3-计算属性" class="headerlink" title="8.3 计算属性"></a>8.3 计算属性</h2>指的是通过一系列运算之后，最后得到一个属性值，这个动态计算出来的属性值可以被模板结构或methods方法使用。所有计算属性都定义到computed之下，定义时要定义成方法格式，使用时当成属性来用。实现了代码的复用，只要计算属性中依赖的任何一个属性变化了都会重新求值。<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box&quot;</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">&quot;&#123; background-color: rgb &#125;&quot;</span>&gt;</span><br>    &#123;&#123; rgb &#125;&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>var vm = new Vue(&#123;<br>    el: &#x27;#app&#x27;,<br>    data: &#123;<br>        r:0,<br>        g:0,<br>        b:0<br>    &#125;,<br>    computed: &#123;<br>        rgb() &#123; <br>            return &#x27;rgb($&#123;this.r&#125;, $&#123;this.g&#125;, $&#123;this.b&#125;)&#x27; &#125;<br>        &#125;<br>    &#125;,<br>    methods: &#123;<br>        show() &#123; console.log(this.rgb) &#125;<br>    &#125;,<br>&#125;)<br></code></pre></td></tr></table></figure></li></ul><h2 id="8-4-computed和watch区别"><a href="#8-4-computed和watch区别" class="headerlink" title="8.4 computed和watch区别"></a>8.4 computed和watch区别</h2><p>computed是计算属性，依赖其它属性值计算，且computed的值有缓存，只有当计算值变化时才会返回内容。<br>watch监听到值的变化就会执行回调，在回调中可以进行一些逻辑操作。<br>所以一般来说需要依赖别的属性来动态获得值的时候可以用computed，对于监听到的变化需要做一些复杂的业务逻辑的情况可以使用watch。<br>computed是多对一或一对一时使用，watch是一对多时使用。</p><h1 id="九、私有子组件和全局组件"><a href="#九、私有子组件和全局组件" class="headerlink" title="九、私有子组件和全局组件"></a>九、私有子组件和全局组件</h1><h2 id="9-1-私有子组件"><a href="#9-1-私有子组件" class="headerlink" title="9.1 私有子组件"></a>9.1 私有子组件</h2><p>父组件使用子组件：<br>①在根组件的script中导入需要的组件import Left from ‘@&#x2F;components&#x2F;Left.vue’<br>②在export default中的components节点注册组件，可选的给组件命名：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    <span class="hljs-attr">components</span>: &#123;  <span class="hljs-comment">//这样注册的都是私有子组件</span><br>        <span class="hljs-title class_">Left</span>: <span class="hljs-string">&#x27;Left&#x27;</span>   <span class="hljs-comment">// 可以不用重命名，直接写Left</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>③以标签的形式使用刚才注册的组件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">Left</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Left</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="9-2-全局组件"><a href="#9-2-全局组件" class="headerlink" title="9.2 全局组件"></a>9.2 全局组件</h2><p>在vue项目的main.js入口文件中，通过Vue.component()方法注册全局组件。在所有组件中，无需导入直接可以在模板中使用该组件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Count</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/components/Count.vue&#x27;</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;MyCount&#x27;</span>, <span class="hljs-title class_">Count</span>)<br></code></pre></td></tr></table></figure><h1 id="★十、组件通信"><a href="#★十、组件通信" class="headerlink" title="★十、组件通信"></a>★十、组件通信</h1><p>组件通信一般分为以下三种情况：<br>①父子组件通信<br>②兄弟组件通信<br>③跨多层级组件通信<br>通信的六种方式：<br>①props&#x2F; $emit（适用父子组件通信）<br>②ref &#x2F; $refs<br>③$emit &#x2F; $on （Eventbus，适用于父子，隔代，兄弟组件通信）<br>④provide &#x2F; inject（适用于隔代组件通信）<br>⑤$parent &#x2F; $children（适用父子组件通信）<br>⑥$attrs &#x2F; $listeners （适用于隔代组件通信）<br>⑦Vuex（适用于父子、隔代、兄弟组件通信）</p><h2 id="10-1-props-x2F-emit"><a href="#10-1-props-x2F-emit" class="headerlink" title="10.1 props&#x2F;$emit"></a>10.1 props&#x2F;$emit</h2><ul><li><strong>父组件向子组件共享数据用自定义属性props</strong>。<br>在子组件中定义props，父组件把数据定义在data中，使用子组件时直接传给子组件。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span>&#123;<br>    <span class="hljs-attr">props</span>: &#123;<br>        <span class="hljs-attr">init</span>: &#123;<br>            <span class="hljs-attr">default</span>: <span class="hljs-number">0</span>, <span class="hljs-comment">//如果外界使用的时候，没有传递init属性，默认值生效</span><br>            <span class="hljs-attr">type</span>: <span class="hljs-title class_">Number</span>,   <span class="hljs-comment">//定义init数据类型</span><br>            <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span> <span class="hljs-comment">//必填项校验，规定这个属性使用时是否要传值</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>父组件data中定义数据user。<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">MyCount</span> <span class="hljs-attr">v-bind:init</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">MyCount</span>&gt;</span><br></code></pre></td></tr></table></figure>父组件调用子组件MyCount时将user的值传给子组件的init。<strong>使用v-bind是动态传递，传递的值可以是表达式、对象、布尔值等等，不使用v-bind传递的是静态字符串</strong>。<br>这种父子通信方式就是典型的单向数据流，父组件通过props传递数据，子组件不能直接修改props，而是必须通过发送事件的方式告知父组件修改数据。<br>组件中封装的props的值是只读的，<strong>不要直接修改</strong>，否则会报错。可以将props的值传给data中的值作为初始值，然后修改data中的值。</li><li><strong>子组件给父组件传值用自定义事件$emit</strong>。<br>这种方式还可以使用v-model来直接实现，因为v-model默认会解析成名为value的prop和名为input的事件，这种语法糖的方式是典型的双向绑定，常用与UI控件上，但究其根本，还是通过事件的方法让父组件修改数据。<br><strong>子组件</strong>：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> &#125;<br>    &#125;,<br>    <span class="hljs-attr">methods</span>: &#123;<br>        <span class="hljs-title function_">add</span>(<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> += <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">// 修改数据时，通过$emit()触发自定义事件numchange，将this.count传给父组件。</span><br>            <span class="hljs-variable language_">this</span>.$emit(<span class="hljs-string">&#x27;numchange&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><strong>父组件</strong>：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">Son</span> @<span class="hljs-attr">numchange</span>=<span class="hljs-string">&quot;getNewCount&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Son</span>&gt;</span><br>export default &#123;<br>    data() &#123;<br>        return &#123; countFromSon: 0 &#125;<br>    &#125;, <br>    methods: &#123;<br>        getNewCount(val) &#123;<br>            this.countFromSon = val;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="10-2-ref"><a href="#10-2-ref" class="headerlink" title="10.2 $ref"></a>10.2 $ref</h2>用来辅助开发者在不依赖jQuery的情况下，获取DOM元素或组件的引用，每个vue组件实例上，都包含一个针对$refs对象，对象里存储着对应DOM元素或组件的引用，默认情况下组件的$refs指向一个空对象。<br>如果在普通的DOM元素上使用，引用指向的就是DOM元素；如果用在子组件上，引用就指向组件实例，能够获取到在子组件里定义的属性和方法。<br><strong>使用方法</strong>：</li></ul><ol><li>给某个标签加一个ref名称，如<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;myh1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li>修改DOM元素的时候，使用this.$refs.名称，如this.$refs.myh1。</li><li>修改DOM元素样式，直接this.$refs.myh1.color&#x3D;’red’。<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">my-counter</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;counterRef&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">my-counter</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;getRef&quot;</span>&gt;</span>获取$refs引用<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br> <br> methods: <br>    getRef() &#123;<br>        this.$refs.counterRef.add()     //直接调用my-counter的add函数。<br>    &#125;<br> &#125;<br></code></pre></td></tr></table></figure><strong>父传子</strong>：<br>父组件：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;Child ref=&quot;msg&quot;&gt;&lt;/Child&gt;<br>export default &#123;<br>    components: &#123;<br>        Child<br>    &#125;,<br>    data() &#123;<br>        return &#123;<br>            child: “父组件传的参数&quot;,<br>        &#125;<br>    &#125;,<br>    mounted()&#123;<br>        this.$refs.msg.message = this.child;    // 将child的值传给子组件msg的message。<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>子组件：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>export default &#123;<br>    data() &#123;<br>        return &#123;<br>            message: &quot;&quot;<br>        &#125;<br>    &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><strong>子传父</strong>：<br>父组件：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">Child</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;givChild&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Child</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;&#123; data &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>export default&#123;<br>    components: &#123; Child &#125;,<br>    data() &#123;<br>        return &#123;<br>            data: &quot;&quot;,<br>        &#125;<br>    &#125;,<br>    mounted() &#123;<br>        this.$refs.givChild.$on(&quot;xxx&quot;, (e)=&gt;&#123;<br>            this.data = e;<br>        &#125;);<br>    &#125;,<br>&#125;<br></code></pre></td></tr></table></figure>子组件：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;giveFather&quot;</span>&gt;</span>给父元素传数据<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>export default &#123;<br>    data() &#123;<br>        return &#123;<br>            data: &quot;这是子组件传来的&quot;<br>        &#125;<br>    &#125;,<br>    methods: &#123;<br>        giveFather() &#123;<br>            this.$emit(&#x27;xxx&#x27;, this.data)<br>        &#125;<br>    &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="10-3-parent和-children"><a href="#10-3-parent和-children" class="headerlink" title="10.3 $parent和$children"></a>10.3 $parent和$children</h2>这种情况可以通过查找父组件中的子组件实现，也就是this.$parent.$children。在$children中可以通过组件name查询到需要的组件实例，然后进行通信。<br>使用$parent可以让组件访问父组件的实例（访问的是上一级父组件的属性和方法）。<br>使用$children可以让组件访问子组件的实例，但是$children并不能保证顺序，并且访问的数据也不是响应式的。<br>子组件：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>获取父组件的值为:  &#123;&#123;parentVal&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">      <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Vue&#x27;</span></span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  <span class="hljs-attr">computed</span>:&#123;</span><br><span class="language-javascript">    <span class="hljs-title function_">parentVal</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">$parent</span>.<span class="hljs-property">msg</span>;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>父组件：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;hello_world&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">child</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">child</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;change&quot;</span>&gt;</span>点击改变子组件值<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> child <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./child.vue&#x27;</span></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-attr">components</span>: &#123; child &#125;,</span><br><span class="language-javascript">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">      <span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;Welcome&#x27;</span></span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  <span class="hljs-attr">methods</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-title function_">change</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-comment">// 获取到子组件</span></span><br><span class="language-javascript">      <span class="hljs-variable language_">this</span>.<span class="hljs-property">$children</span>[<span class="hljs-number">0</span>].<span class="hljs-property">message</span> = <span class="hljs-string">&#x27;JavaScript&#x27;</span></span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>此时，子组件获得了父组件中msg的值，父组件改变了子组件中message的值。<br><strong>注意</strong>:<br>①通过$parent访问到的是上一级父组件的实例，可以使用$root来访问根组件的实例。<br>②在组件中使用$children拿到的是所有的子组件的实例，它是一个数组，并且是无序的。<br>③在根组件 #app 上拿 $parent 得到的是 new Vue()的实例，在这实例上再拿 $parent 得到的是undefined，而在最底层的子组件拿 $children 是个空数组<br>④$children 的值是数组，而 $parent是个对象<h2 id="10-4-eventBus事件总线"><a href="#10-4-eventBus事件总线" class="headerlink" title="10.4 eventBus事件总线"></a>10.4 eventBus事件总线</h2>它适用于父子组件、非父子组件等之间的通信。<br>①创建eventBus.js模块，并向外共享一个VUE的实例对象。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-comment">// 向外共享Vue的实例对象</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>()<br></code></pre></td></tr></table></figure>②在数据发送方，调用bus.$emit(‘事件名称”, 要发送的数据)方法触发自定义事件。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> bus <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./eventBus.js&#x27;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> &#123;<br>            <span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;hello&#x27;</span><br>        &#125;<br>    &#125;,<br>    <span class="hljs-attr">methods</span>: &#123;<br>        <span class="hljs-title function_">sendMsg</span>(<span class="hljs-params"></span>) &#123;<br>            bus.$emit(<span class="hljs-string">&#x27;share&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">msg</span>)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>③在数据接收方，调用bus.$on(‘事件名称’,事件处理函数)方法注册一个自定义事件。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> bus <span class="hljs-keyword">from</span>  <span class="hljs-string">&#x27;./eventBus.js&#x27;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> &#123;<br>            <span class="hljs-attr">msgFrom</span>: <span class="hljs-string">&#x27;&#x27;</span><br>        &#125;<br>    &#125;,<br>    <span class="hljs-title function_">created</span>(<span class="hljs-params"></span>) &#123;<br>        bus.$on(<span class="hljs-string">&#x27;share&#x27;</span>, <span class="hljs-function"><span class="hljs-params">val</span>=&gt;</span>&#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">msgFrom</span> = val<br>        &#125;)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="10-5-attrs-x2F-listeners"><a href="#10-5-attrs-x2F-listeners" class="headerlink" title="10.5 $attrs&#x2F;$listeners"></a>10.5 $attrs&#x2F;$listeners</h2>适用于隔代组件通信。<br><strong>$attrs</strong>：包含了父作用域中不被 prop 所识别 (且获取) 的特性绑定 ( class 和 style 除外 )。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 ( class 和 style 除外 )，并且可以通过 v-bind&#x3D;”$attrs”传入内部组件。通常配合 inheritAttrs 选项一起使用。<br><strong>$listeners</strong>：包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on&#x3D;”$listeners”传入内部组件<h2 id="10-6-provide-x2F-inject"><a href="#10-6-provide-x2F-inject" class="headerlink" title="10.6 provide&#x2F;inject"></a>10.6 provide&#x2F;inject</h2>适用于隔代组件通信。<br>祖先组件中通过 provider 来提供变量，然后在子孙组件中通过 inject 来注入变量。provide &#x2F; inject API主要解决了跨级组件间的通信问题，不过它的使用场景，主要是子组件获取上级组件的状态，跨级组件间建立了一种主动提供与依赖注入的关系。<h2 id="10-7-Vuex"><a href="#10-7-Vuex" class="headerlink" title="10.7 Vuex"></a>10.7 Vuex</h2>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。<br>Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。<br>改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。</li></ol><h1 id="十一、scoped解决组件样式冲突"><a href="#十一、scoped解决组件样式冲突" class="headerlink" title="十一、scoped解决组件样式冲突"></a>十一、scoped解决组件样式冲突</h1><p>在VUE组件中，在style标签上添加scoped属性，以表示它的样式作用于当下的模块，很好的实现了样式私有化的目的，是一个非常好的机制。默认情况下，写在vue组件中的样式会全局生效，因此很容易造成多个组件之间的样式冲突问题。<br><strong>导致组件之间样式冲突的根本原因是</strong>：<br>①单页面应用程序中，所有组件的DOM结构，都是基于唯一的index.html页面进行呈现的。<br>②每个组件中的样式，都会影响整个index.html页面中的DOM元素。<br><strong>使用方法</strong>：直接在style标签末尾加scoped。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;less&quot;</span> <span class="hljs-attr">scpoed</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>主要通过使用PostCSS来实现以下转换：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="language-css"></span><br><span class="language-css">  <span class="hljs-selector-class">.example</span> &#123;</span><br><span class="language-css">     <span class="hljs-attribute">color</span>: red;</span><br><span class="language-css">  &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;example&quot;</span>&gt;</span>hi<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>//转换结果：<br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">  <span class="hljs-selector-class">.example</span><span class="hljs-selector-attr">[data-v-7668812d]</span> &#123;</span><br><span class="language-css">      <span class="hljs-attribute">color</span>: red;</span><br><span class="language-css">  &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;example&quot;</span> <span class="hljs-attr">data-v-7668812d</span>&gt;</span>hi<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><p>通过给DOM增加一个动态属性，然后CSS选择器也额外添加对应的属性来选择该DOM，达到该样式只作用于含有该属性的DOM，实现组件的模板化。</p><h4 id="特殊用法"><a href="#特殊用法" class="headerlink" title="特殊用法"></a>特殊用法</h4><p>scoped这个属性就是专门用于实现样式的模块化的，使用这个属性意味着样式不能经过外部或者全局的调整，在使用之初就应该规划好。但有时候我们可能要引入第三方组件，修改它的样式又不想去除scoped造成组件之间的样式污染，所以才有了下面的特殊用法。<br><strong>scoped穿透（深度作用选择器）</strong>：<br>如果希望scoped样式中的一个选择器能够作用的更深，例如影响子组件，可以使用&gt;&gt;&gt;操作符。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    .外层 &gt;&gt;&gt; .第三方组件 &#123; <span class="hljs-comment">/* ... */</span> &#125;&#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><p>或者要修改子组件中元素的样式，前面加&#x2F;deep&#x2F;。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    /deep/ <span class="hljs-selector-tag">h5</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">color</span>: pink;</span><br><span class="language-css">    &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><p>上述代码会编译成：.外层[data-v-7668812d] .第三方组件 {  &#x2F;* … * &#x2F;  }<br>通过’&gt;&gt;&gt;’ 可以使得在使用scoped属性的情况下，穿透scoped，修改其他组件的值。<br>实现原理其实就是加权重。<br>‘&gt;&gt;&gt;’ 功能由 vue-loader 提供。 vue-loader 专门用于解析 vue 文件，提取每个语言块（html、script、style），如有必要会通过其它 loader 处理，最后将他们组装成一个 CommonJS 模块，module.exports 出一个 Vue.js 组件对象。<br><strong>scoped实质</strong>就是添加了属性选择器增加了10的权重。</p><h1 id="★十二、生命周期钩子函数"><a href="#★十二、生命周期钩子函数" class="headerlink" title="★十二、生命周期钩子函数"></a>★十二、生命周期钩子函数</h1><p><strong>生命周期</strong>：指一个组件从创建-&gt;运行-&gt;销毁的整个阶段，强调的是一个时间段。<br><strong>生命周期函数</strong>：是由vue框架提供的内置函数，会伴随着组件的生命周期，自动按次序执行，强调的是时间点。这些函数直接写在export default里面，与methods平级。<br><strong>组件生命周期四个阶段</strong>：组件创建阶段、组件载入阶段、组件运行阶段、组件销毁阶段。</p><p><strong>钩子</strong>：hook，一种事件劫持机制，可以比事件更早进行执行处理。钩子可以理解为vue的内置事件，但是这个内置事件需要主动去配置，可以用来处理被拦截的函数调用、事件和消息。</p><h4 id="12-1-组件创建阶段："><a href="#12-1-组件创建阶段：" class="headerlink" title="12.1 组件创建阶段："></a>12.1 组件创建阶段：</h4><p>此时的函数都只会运行一次。<br>①new Vue()创建组件的实例对象<br>②初始化时间和生命周期函数，此时组件的props、data、methods都尚未被创建，都处于不可用状态。<br>③<strong>beforeCreate()</strong> ，此时vue实例挂载元素$el和数据对象data都为undefined，还未初始化。<br>④初始化props、data、methods。<br>⑤<strong>created</strong> ，组件的props、data、methods已经创建好，都处于可用的状态，但是$el还没有，组件的模板结构尚未生成，此时通常用来借助ajax拿数据，并将拿来的数据放到data中使用。</p><h4 id="12-2-组件载入阶段"><a href="#12-2-组件载入阶段" class="headerlink" title="12.2 组件载入阶段"></a>12.2 组件载入阶段</h4><p>此时的函数都只会运行一次。<br>①判断是否有el选项，没有看是否有vm.#mount(el)。<br>②基于数据和模板，在内存中编译生成HTML结构。<br>③<strong>beforeMount()</strong> ，此时vue实例的$el和data都初始化了，但还是挂载之前为虚拟的DOM节点，data.message还未替换。将要把内存中编译好的HTML结构渲染到浏览器中，此时浏览器中还没有当前组件的DOM结构。<br>④用内存中编译生成的HTML结构替换到el属性指定的DOM元素。<br>⑤<strong>mounted()</strong> ，此时vue实例挂载完成，data.message成功渲染，已经把内存中的HTML结构，成功的渲染到了浏览器之中，此时浏览器中已经包含了当前组件的DOM结构。</p><h4 id="12-3-组件运行阶段（更新）"><a href="#12-3-组件运行阶段（更新）" class="headerlink" title="12.3 组件运行阶段（更新）"></a>12.3 组件运行阶段（更新）</h4><p>函数会运行多次。<br>①数据发生变化<br>②<strong>beforeUpdate()</strong> ：数据更新时调用，将要根据变化过后、最新的数据，重新渲染组件的模板结构。<br>③根据最新的数据，重新渲染组建的DOM结构。<br>④<strong>update()</strong> ：已经根据最新的数据，完成了组件DOM结构的重新渲染。</p><h4 id="12-4-组件销毁阶段"><a href="#12-4-组件销毁阶段" class="headerlink" title="12.4 组件销毁阶段"></a>12.4 组件销毁阶段</h4><p>①<strong>beforeDestroy()</strong> ：实例销毁之前调用，此时实例仍然完全可用，将要销毁此组件，组件还处于正常工作的状态。<br>②销毁当前组件的数据侦听器、子组件、事件监听。<br>③<strong>destroyed()</strong> ：实例销毁后调用，此时组件已经被销毁，实例的所有东西都被解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁，此组件在浏览器中对应的DOM结构已经完全被移除。</p><h1 id="十三、data中对象添加新属性"><a href="#十三、data中对象添加新属性" class="headerlink" title="十三、data中对象添加新属性"></a>十三、data中对象添加新属性</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>    &lt;div&gt;<br>        &lt;ul&gt;    <br>            &lt;li v-for=&quot;value in obj&quot; :key=&quot;value&quot;&gt;&#123;&#123;value&#125;&#125;&lt;/li&gt;<br>        &lt;/ul&gt;<br>        &lt;button @click=&quot;addObjB&quot;&gt;添加obj.b&lt;/button&gt;<br>    &lt;/div&gt;<br>&lt;/template&gt;<br>&lt;script&gt;<br>export default&#123;<br>  data () &#123;<br>      return &#123;<br>        obj: &#123;<br>        a: &#x27;obj.a&#x27;<br>      &#125;<br>    &#125;<br>  &#125;,<br>  methods: &#123;<br>    addObjB () &#123;<br>        this.obj.b = &#x27;obj.b&#x27;<br>      console.log(this.obj)<br>    &#125;<br>  &#125;<br>&#125;<br>&lt;/script&gt;<br>&lt;style&gt;&lt;/style&gt;<br></code></pre></td></tr></table></figure><p>此时，点击button按钮会发现，obj.b已经成功添加，但视图未刷新。<br>在Vue实例创建时，obj.b并未声明，因此就没有被Vue转换为响应式的属性，自然不会触发视图的更新，此时需要使用Vue的全局api：$set()</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">addObjB () &#123;    <br><span class="hljs-comment">// this.obj.b = &#x27;obj.b&#x27;      </span><br><span class="hljs-variable language_">this</span>.$set(<span class="hljs-variable language_">this</span>.<span class="hljs-property">obj</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;obj.b&#x27;</span>)<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">obj</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>$set() 方法相当于手动的去把 obj.b 处理成一个响应式的属性，此时视图也会跟着改变了。<br><strong>只要请求回来的数据，在页面渲染期间要用到，则必须要转存到data中</strong>。</p><h1 id="十四、动态组件与keep-alive"><a href="#十四、动态组件与keep-alive" class="headerlink" title="十四、动态组件与keep-alive"></a>十四、动态组件与keep-alive</h1><p>动态切换组件的显示与隐藏，例如设置多个按钮，控制在同一个区域内要显示哪个组件。<br>VUE提供了内置的<component>组件，专门用来实现动态组件的切换。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs vue">data() &#123;<br>    return &#123; comName: &#x27;Left&#x27; &#125;<br>&#125;<br>// 通过is属性，动态指定要渲染的组件<br>&lt;component :is=&quot;comName&quot;&gt;&lt;/component&gt;<br>// 点击按钮，动态切换组件的名称<br>&lt;button @click=&quot;comName=&#x27;Left&#x27; &quot;&gt;展示Left组件&lt;/button&gt;<br>&lt;button @click=&quot;comName=&#x27;Right&#x27; &quot;&gt;展示Right组件&lt;/button&gt;<br></code></pre></td></tr></table></figure><p><strong>动态组件切换的时候原来的组件会被销毁，创建新的组件。</strong><br><strong>使用keep-alive使得组件被切换时不会被销毁，仍然保持</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vue">// include指定哪些组件会被缓存，可选<br>&lt;keep-alive include=&quot;Left,Right&quot;&gt;<br>    &lt;component :is=&quot;comName&quot;&gt;&lt;/component&gt;<br>&lt;/keep-alive&gt;<br></code></pre></td></tr></table></figure><p>如果在声明组件的时候，没有为组件指定name名称，则组件的名称默认就是注册时候的名称。如果指定了名称，调用的时候就要用指定的名称。<br><strong>声明name</strong>：在组件的export default中，添加name:’name’。<br>组件的注册名称主要应用场景是以标签的形式把注册好的组件渲染和使用到页面结构中。<br>组件声明时候的name名称的主要应用场景：结合keep-alive标签实现组件缓存功能，以及在调试工具中看到组件的name名称。</p><h2 id="14-1-keep-alive"><a href="#14-1-keep-alive" class="headerlink" title="14.1 keep-alive"></a>14.1 keep-alive</h2><ul><li><p><strong>用法</strong>：<br>三个属性值：<strong>使用include指定哪些组件会被缓存，exclude指定哪些组件不会被缓存，二者只能同时用一个，max指定最多缓存多少个组件</strong>。<br><strong>keep-alive对应生命周期函数</strong>：<br>当组件被缓存时，会自动触发组件的deactivated生命周期函数（组件被停用时调用）。<br>当组件被激活时，会自动触发组件的activated生命周期函数（组件第一次渲染）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;keep-alive&gt;<br>  &lt;coma v-if=&quot;visible&quot;&gt;&lt;/coma&gt;<br>  &lt;comb v-else&gt;&lt;/comb&gt;<br>&lt;/keep-alive&gt;<br>&lt;button @click=&quot;visible = !visible&quot;&gt;更改&lt;/button&gt;<br></code></pre></td></tr></table></figure><p><strong>例如在coma和comb都有一个input都有对应的value，如果我们不用keep-alive，当更改visible的时候，这两个组件都会重新渲染，先前输入的内容就会丢失，会执行一遍完整的生命周期流程:beforeCreate &#x3D;&gt; created…。</strong><br>但是如果我们用了keep-alive，那么在次切换visible的时候，input对应的value为上次更改时候的值。 所以keep-alive主要是用于保持组件的状态，避免组件反复创建。</p></li><li><p><strong>原理</strong>：keep-alive的文件位置在src&#x2F;core&#x2F;components&#x2F;keep-alive.js中。<br>①keep-alive是一个组件，包括三个属性include、exclude和max。<br>②在created中创建缓存容器cache和缓存组件的key属性，cache用于保存vnode节点。<br>③在destroyed组件销毁时循环销毁清空所有的cache缓存和key，清空缓存中的所有组件实例。<br>④mounted监听include和exclude属性，进行组件的缓存处理。如果这两个属性发生了变化，即表示定义需要缓存的组件的规则或不要缓存的组件的规则发生了变化，就执行pruneCache函数，更新cache缓存。<br>⑤<strong>render</strong>：<br>  先获取插槽中的内容，然后用getFirstComponentChild方法获取第一个子组件，获取该组件的name。<br>  用获取到的name和传入的include和exclude属性进行匹配，如果匹配不成功，则表示不缓存这个组件，直接返回这个组件的vnode，否则，进行下一步缓存。<br>  用name去缓存cache中找是否有该值，如果命中缓存则直接从缓存中拿node的组件实例，并重新调整该组件key（节点的标识）的顺序，将其从原位置删除并放在keys的最后一个。（LRU）<br>  如果没有命中缓存，即该组件还没被缓存过，则以该组件key为键，组件vnode为值存入缓存cache中，key存入keys中。然后再判断缓存组件数量是否超过最大缓存数量值，超过了就把第一个缓存组件删掉。（删除原因：LRU最近最少使用策略）<br>  设置第一个子组件对象的keep-alive为true。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    <span class="hljs-attr">abstract</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">props</span>: &#123;<br>        <span class="hljs-attr">include</span>: patternTypes, <span class="hljs-comment">// 缓存白名单</span><br>        <span class="hljs-attr">exclude</span>: patternTypes, <span class="hljs-comment">// 缓存黑名单</span><br>        <span class="hljs-attr">max</span>: [<span class="hljs-title class_">String</span>, <span class="hljs-title class_">Number</span>] <span class="hljs-comment">// 缓存的实例上限</span><br>    &#125;,<br>    <span class="hljs-title function_">created</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">// 用于缓存虚拟DOM</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>);<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">keys</span> = [];<br>    &#125;,<br>    destroyed () &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>) &#123;<span class="hljs-comment">// keep-alive销毁时,循环清空所有的缓存和key</span><br>            <span class="hljs-title function_">pruneCacheEntry</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>, key, <span class="hljs-variable language_">this</span>.<span class="hljs-property">keys</span>)<br>        &#125;<br>    &#125;,<br>     <span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>) &#123;<br>    / 用于监听黑白名单，如果发生调用pruneCache<br>    <span class="hljs-comment">// pruneCache更新vue的cache缓存</span><br>        <span class="hljs-variable language_">this</span>.$watch(<span class="hljs-string">&#x27;include&#x27;</span>, <span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> &#123;<br>            <span class="hljs-title function_">pruneCache</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-function"><span class="hljs-params">name</span> =&gt;</span> <span class="hljs-title function_">matches</span>(val, name))<br>        &#125;)<br>        <span class="hljs-variable language_">this</span>.$watch(<span class="hljs-string">&#x27;exclude&#x27;</span>, <span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> &#123;<br>            <span class="hljs-title function_">pruneCache</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-function"><span class="hljs-params">name</span> =&gt;</span> !<span class="hljs-title function_">matches</span>(val, name))<br>        &#125;)<br>    &#125;<br>    <br>    <br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">const</span> slot = <span class="hljs-variable language_">this</span>.<span class="hljs-property">$slots</span>.<span class="hljs-property">default</span> <span class="hljs-comment">// 获取默认插槽中的第一个组件节点</span><br>        <span class="hljs-keyword">const</span> <span class="hljs-attr">vnode</span>: <span class="hljs-title class_">VNode</span> = <span class="hljs-title function_">getFirstComponentChild</span>(slot)<br> <span class="hljs-comment">// 获取该组件节点的componentOptions（用来挂载部分组件选项，包括Ctor、tag、propsData、listeners、children。非组件的该项为空）</span><br>        <span class="hljs-keyword">const</span> componentOptions = vnode &amp;&amp; vnode.<span class="hljs-property">componentOptions</span><br>        <span class="hljs-keyword">if</span> (componentOptions) &#123;<br>            <span class="hljs-comment">//  获取该组件的名称，优先获取组件的name字段，如果name不存在则获取组件的tag</span><br>            <span class="hljs-keyword">const</span> name = <span class="hljs-title function_">getComponentName</span>(componentOptions)<br>            <span class="hljs-keyword">const</span> &#123; include, exclude &#125; = <span class="hljs-variable language_">this</span><br>            <span class="hljs-keyword">if</span> (  <span class="hljs-comment">// 如果name不在include中或者存在与exclude中则不缓存，直接返回vnode</span><br>                (include &amp;&amp; (!name || !<span class="hljs-title function_">matches</span>(include, name))) || (exclude &amp;&amp; name &amp;&amp; <span class="hljs-title function_">matches</span>(exclude, name))<br>            ) &#123;<br>                <span class="hljs-keyword">return</span> vnode<br>            &#125;<br> <br>            <span class="hljs-comment">// 如果组件没key 就自己通过 组件的标签和key和cid 拼接一个key</span><br>            <span class="hljs-keyword">const</span> &#123; cache, keys &#125; = <span class="hljs-variable language_">this</span><br>            <span class="hljs-keyword">const</span> key = vnode.<span class="hljs-property">key</span> == <span class="hljs-literal">null</span> ? componentOptions.<span class="hljs-property">Ctor</span>.<span class="hljs-property">cid</span> + (componentOptions.<span class="hljs-property">tag</span> ?<span class="hljs-string">`::<span class="hljs-subst">$&#123;componentOptions.tag&#125;</span>`</span> : <span class="hljs-string">&#x27;&#x27;</span>) : vnode.<span class="hljs-property">key</span><br><br>            <span class="hljs-keyword">if</span> (cache[key]) &#123; <span class="hljs-comment">// 如果缓存中有key，直接从缓存中拿vnode的组件实例</span><br>                vnode.<span class="hljs-property">componentInstance</span> = cache[key].<span class="hljs-property">componentInstance</span><br>                <span class="hljs-comment">// 调整该组件key的顺序，将其从原来地方删掉并重新放在最后一个。</span><br>                <span class="hljs-title function_">remove</span>(keys, key) <span class="hljs-comment">// 删除当前的key，用LRU 最近最久未使用法</span><br>                keys.<span class="hljs-title function_">push</span>(key)  <span class="hljs-comment">// 并将key放到缓存的最后面</span><br>            &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//如果没有命中缓存，则将其放入缓存。</span><br>                cache[key] = vnode <span class="hljs-comment">// 缓存vnode</span><br>                keys.<span class="hljs-title function_">push</span>(key) <span class="hljs-comment">// 将key 存入</span><br>        <br>                <span class="hljs-comment">// 如果配置了max且缓存的长度超过了this.max，则从缓存中删除第一个</span><br>                <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">max</span> &amp;&amp; keys.<span class="hljs-property">length</span> &gt; <span class="hljs-built_in">parseInt</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">max</span>)) &#123;<br>                    <span class="hljs-title function_">pruneCacheEntry</span>(cache, keys[<span class="hljs-number">0</span>], keys, <span class="hljs-variable language_">this</span>.<span class="hljs-property">_vnode</span>) <span class="hljs-comment">// 要删除第0个 但是现在渲染的就是第0个</span><br>                &#125;<br>            &#125;<br>            vnode.<span class="hljs-property">data</span>.<span class="hljs-property">keepAlive</span> = <span class="hljs-literal">true</span> <span class="hljs-comment">// 设置keepAlive标记位</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> vnode || (slot &amp;&amp; slot[<span class="hljs-number">0</span>]) <span class="hljs-comment">// 返回当前的虚拟节点</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="14-2-keep-alive首次渲染"><a href="#14-2-keep-alive首次渲染" class="headerlink" title="14.2 keep-alive首次渲染"></a>14.2 keep-alive首次渲染</h2> <img src="/2022/05/12/Vue/keep-alive%E9%A6%96%E6%AC%A1%E6%B8%B2%E6%9F%93.png" class=""></li></ul><p>页面首次渲染的时候，组件的渲染过程是先子组件后父组件，所以这里就能拿到子组件的数据，然后把子组件的vnode信息存到缓存cache中，并把子组件的keepAlive标记为设置为true。<br><strong>Vue会拿到前面生成的Vnode对象执行真实节点创建的过程，就是patch过程</strong>。patch执行阶段会调用createElm创建真实dom，在创建节点途中，<strong>keep-alive的vnode对象会被认定为一个组件Vnode，针对组件Vnode会执行createComponent函数，它会对keep-alive的组件进行初始化和实例化</strong>。<br><strong>keep-alive组件会先调用内部钩子init方法进行初始化操作。</strong>第一次执行时，组件vnode没有componentInstance属性，vnode.data.keepAlive也没有值，此时会调用createComponentInstanceForVnode方法进行组件实例化并将组件实例赋值给vnode的componentInstance属性，最终执行组件实例的$mount方法进行实例挂载。<br>createComponentInstanceForVnode就是组件实例化的过程。</p><h2 id="14-3-为什么切换组件后组件内数据仍保留"><a href="#14-3-为什么切换组件后组件内数据仍保留" class="headerlink" title="14.3 为什么切换组件后组件内数据仍保留"></a>14.3 为什么切换组件后组件内数据仍保留</h2><p>在首次渲染时，更改组件coma中input的值，查看当visible的值再次变为true时input是否会记住前面的值，因为更改visible的值后会执行updateComponent，即重新执行keep-alive的render函数。因为首次渲染时已经把数据存入到cache中，所以这次数据直接从cache中获取执行。<br>vnode.componentInstance &#x3D; cache[key].componentInstance<br>在首次渲染的时候，当key值不存在的时候会首先将子组件的vnode缓存起来，首次渲染时componentInstance是undefined，它在patch过程中调用组件的init钩子才生成的。当发生组件切换时，先前的状态信息重新赋值给了组件coma，vnode.componentInstance在keep-alive时已经进行重新赋值，且keepAlive为true，所以只会执行prepatch，不会执行created和mounted钩子。</p><h2 id="14-4-keep-alive在首次渲染和patch过程中的差异"><a href="#14-4-keep-alive在首次渲染和patch过程中的差异" class="headerlink" title="14.4 keep-alive在首次渲染和patch过程中的差异"></a>14.4 keep-alive在首次渲染和patch过程中的差异</h2><p><strong>首次渲染</strong>：keep-alive终究是一个组件，会执行组件相应的逻辑，在首次渲染的时候执行patch操作，执行到core&#x2F;vdom&#x2F;patch中。首次渲染时componentInstance并不存在，只执行init钩子，init具体作用就是创建子组件实例。<br><strong>更改数据后patch过程</strong>：当data中的值发生改变时，会触发updateComponent，此时会重新执行keep-alive的render函数，重新执行根组件的patch过程。</p><h2 id="14-5-keep-alive是否必须"><a href="#14-5-keep-alive是否必须" class="headerlink" title="14.5 keep-alive是否必须"></a>14.5 keep-alive是否必须</h2><p>keep-alive对于缓存数据有巨大帮助，可以防止组件反复创建。<br><strong>使用场景</strong>：页面中，如果返回上一个页面会刷新数据，需要保留离开页面时的状态，此时需要keep-alive。<br><strong>不使用场景</strong>：如果组件切换不需要保存状态，此时使用keep-alive需要在activated重置这些属性。如果所有变量都进行重置，风险是否可控。所有缓存都放在了cache中，当组件过多的时候内容过多，导致这个对象巨大，不一定能提高性能要求。</p><h1 id="十五、slot插槽"><a href="#十五、slot插槽" class="headerlink" title="十五、slot插槽"></a>十五、slot插槽</h1><p>插槽，是<strong>组件的一块HTML模板</strong>，允许开发者在封装组件时把不确定、希望用户指定的部分定义为插槽。核心问题是是否显示和怎样显示。每个插槽都要指定一个name名称，如果省略了则有一个默认的名称叫做default。<br>在组件中放置<slot></slot>，当用户调用组件，并在组件的标签中输入内容时，这些内容会被放到组件的slot标签位置显示，默认在使用组件时提供的内容被填充到名字为default的插槽中。<br>任何一个组件都可以分为非插槽模板和插槽模板两类。非插槽模板指的是html模板，比如div、span，它们的显示与隐藏、怎样显示由组件自身控制。插槽模板是slot，它是一个空壳，显示与隐藏、最后长什么样由父组件控制，但是插槽显示的位置由子组件自身决定，slot写在组件template的什么位置，父组件传过来的模板将来就显示在什么位置。<br><strong>父组件指定内容放到子组件某个插槽</strong>：用v-slot，不能直接使用在元素上，需要套一个盒子，可以简写为#，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;child&gt;<br>    &lt;template v-slot:title&gt;<br>        &lt;p&gt;123&lt;/p&gt;<br>    &lt;/template&gt;<br>&lt;/child&gt;<br></code></pre></td></tr></table></figure><p>此处v-slot:子组件插槽名name&#x3D;”给插槽起的新名字”，旧版本中组件名用slot&#x3D;’插槽名’，slot-scope&#x3D;’插槽新名字’<br><strong>指定默认内容（后备内容）</strong>：直接在子组件里放置的slot标签内部放置内容，这些内容就是默认的内容，当用户没有指定的时候就显示默认的内容，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;slot name=&quot;title&quot;&gt;<br>    &lt;p&gt;123&lt;/p&gt;<br>&lt;/slot&gt;<br></code></pre></td></tr></table></figure><h4 id="15-1-单个插槽-默认插槽-匿名插槽"><a href="#15-1-单个插槽-默认插槽-匿名插槽" class="headerlink" title="15.1 单个插槽 | 默认插槽 | 匿名插槽"></a>15.1 单个插槽 | 默认插槽 | 匿名插槽</h4><p>不用设置name属性，可以放在组件的任意位置，一个组件中只能有一个该类插槽。具名插槽可以放多个，只要它们的名字不同就可以。</p><h4 id="15-2-具名插槽"><a href="#15-2-具名插槽" class="headerlink" title="15.2 具名插槽"></a>15.2 具名插槽</h4><p>给插槽设置name属性，可以在一个组件中出现多次，但每次name值不同。</p><h4 id="15-3-作用域插槽"><a href="#15-3-作用域插槽" class="headerlink" title="15.3 作用域插槽"></a>15.3 作用域插槽</h4><p>在封装组件时，为预留的slot提供属性对应的值，在调用组件时，可以使用组件插槽预留的值，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs vue">// 子组件里<br>&lt;slot name=&quot;content&quot; msg=&quot;hello vue.js&quot;&gt;&lt;/slot&gt;<br><br>// 父组件<br>&lt;template #content=&quot;obj&quot;&gt;    <br>    &lt;div&gt;<br>        &lt;p&gt;&#123;&#123; obj.msg &#125;&#125;&lt;/p&gt;<br>    &lt;/div&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><p>也可以不给插槽命名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;slot name=&quot;content&quot; msg=&quot;hello vue.js&quot; :user=&quot;userinfo&quot;&gt;&lt;/slot&gt;<br><br>&lt;template #content=&quot;&#123;msg,user&#125;&quot;&gt;<br>    &lt;div&gt;<br>        &lt;p&gt;&#123;&#123; msg &#125;&#125;&lt;/p&gt;<br>        &lt;p&gt;&#123;&#123; user.username &#125;&#125;&lt;/p&gt;<br>    &lt;/div&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><h1 id="十六、自定义指令"><a href="#十六、自定义指令" class="headerlink" title="十六、自定义指令"></a>十六、自定义指令</h1><p>分为两类：私有自定义指令和全局自定义指令。<br>VUE2.0中，代码复用和抽象的主要形式是组件，然有需要对DOM元素进行底层操作，这时就需要使用自定义指令。一般需要对DOM元素进行底层操作时使用，尽量只用来操作DOM展示，不修改内部的值，当使用自定义指令直接修改value值时绑定v-model的值也不会同步更新； 如果必须修改可以在自定义指令中使用keydown事件，在vue组件中使用change事件，回调中修改vue数据。</p><h4 id="16-1-私有自定义指令"><a href="#16-1-私有自定义指令" class="headerlink" title="16.1 私有自定义指令"></a>16.1 私有自定义指令</h4><p>在每个组件中，在directives节点下声明私有自定义指令，使用时名字前加v-，如v-color。当指令第一次被绑定到元素上时立即触发bind函数，形参中的el表示当前指令所绑定到的那个DOM对象，update函数会在每次DOM更新时被调用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">directives</span>: &#123;<br>    <span class="hljs-attr">color</span>: &#123;<br>        <span class="hljs-comment">// 当指令第一次被绑定到元素时使用</span><br>        <span class="hljs-title function_">bind</span>(<span class="hljs-params">el. binding</span>) &#123;<br>            el.<span class="hljs-property">style</span>.<span class="hljs-property">color</span> = binding.<span class="hljs-property">value</span><br>        &#125;,<br>        <span class="hljs-comment">// 每次DOM更新时被调用</span><br>        <span class="hljs-title function_">update</span>(<span class="hljs-params">el, binding</span>) &#123;<br>            el.<span class="hljs-property">style</span>.<span class="hljs-property">color</span> = binding.<span class="hljs-property">value</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以给私有自定义指令传参，此时给bind函数增加一个形参，如binding，传递参数的实际值放在value里了。此时调用该指令，可以传变量值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;h1 v-color=&quot;data&quot;&gt;&lt;/h1&gt;<br></code></pre></td></tr></table></figure><p>如果要直接传值，则需要用单引号括起来。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;h1 v-color=&quot;&#x27;red&#x27;&quot;&gt;&lt;/h1&gt;<br></code></pre></td></tr></table></figure><h4 id="16-2-全局自定义指令"><a href="#16-2-全局自定义指令" class="headerlink" title="16.2 全局自定义指令"></a>16.2 全局自定义指令</h4><p>需要通过Vue.directive()进行声明，全局自定义指令都必须放到main.js中，里面也可以分为bind和update两个函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vue">Vue.directive(&#x27;color&#x27;, function(el,binding) &#123;<br>    el.style.color = binding.value<br>&#125;）<br></code></pre></td></tr></table></figure><h4 id="16-3-指令钩子函数及其参数"><a href="#16-3-指令钩子函数及其参数" class="headerlink" title="16.3 指令钩子函数及其参数"></a>16.3 指令钩子函数及其参数</h4><ul><li>bind：只调用一次，指令第一次绑定到元素时调用，在这里可以进行一次性的初始化设置。</li><li>inSerted：被绑定元素插入父节点时调用，仅保证父节点存在，但不一定已经被插入文档中。</li><li>update：所在组件的vnode更新时调用，但可能发生在其子vnode更新之前调用。指令的值可能发生了改变，也可能没有，可以通过比较更新前后的值来忽略不必要的模板更新。</li><li>ComponentUpdate：指令所在组件的vnode及其子vnode全部更新后调用。</li><li>unbind：只调用一次，指令与元素解绑时调用。<br><strong>参数</strong>：</li><li>el：绑定元素</li><li>name、value、oldValue、expression、arg、modifers</li><li>vnode：虚拟节点</li><li>oldVnode：上一个虚拟节点，只在更新钩子函数中才有。</li></ul><h4 id="16-4-使用场景"><a href="#16-4-使用场景" class="headerlink" title="16.4 使用场景"></a>16.4 使用场景</h4><ul><li>普通DOM元素进行底层操作的时候，可以使用自定义指令。</li><li>自定义指令是用来操作DOM的，尽管Vue推崇数据驱动视图的理念，但并非所有情况都适合数据驱动。自定义指令就是一种有效的补充和扩展，不仅可以用于定义任何的DOM操作，并且是可复用的。</li></ul><h4 id="16-5-使用案例"><a href="#16-5-使用案例" class="headerlink" title="16.5 使用案例"></a>16.5 使用案例</h4><p>鼠标聚焦、下拉菜单、相对时间转换、滚动动画、自定义指令实现图片懒加载、自定义指令集成第三方插件。</p><h1 id="★十七、父子组件生命周期函数"><a href="#★十七、父子组件生命周期函数" class="headerlink" title="★十七、父子组件生命周期函数"></a>★十七、父子组件生命周期函数</h1><img src="/2022/05/12/Vue/%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" class=""> <h1 id="十八、Patch和diff"><a href="#十八、Patch和diff" class="headerlink" title="十八、Patch和diff"></a>十八、Patch和diff</h1><p>diff的过程就是调用名为patch的函数，比较新旧节点，一边比较一边给真实的DOM打补丁。<br>我们<strong>先根据真实DOM生成一颗虚拟dom树，当虚拟dom某个节点的数据改变后会生成一个新的Vnode，然后Vnode和oldVnode作对比，发现有不一样的地方就直接修改在真实的DOM上，然后使oldVnode的值为Vnode</strong>。<br><strong>以新的VNode为基准，改造旧的oldVNode使之成为跟新的VNode一样，这就是patch过程要干的事</strong>。<br><strong>Patch主要干三件事</strong>：</p><ul><li>创建节点：新的VNode中有而旧的oldVNode中没有，就在旧的oldVNode中创建。</li><li>删除节点：新的VNode中没有而旧的oldVNode中有，就从旧的oldVNode中删除。</li><li>更新节点：新的VNode和旧的oldVNode中都有，就以新的VNode为准，更新旧的oldVNode。</li></ul><h2 id="18-1-创建节点"><a href="#18-1-创建节点" class="headerlink" title="18.1 创建节点"></a>18.1 创建节点</h2><p>源码位置: &#x2F;src&#x2F;core&#x2F;vdom&#x2F;patch.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createElm</span> (vnode, parentElm, refElm) &#123;<br>    <span class="hljs-keyword">const</span> data = vnode.<span class="hljs-property">data</span><br>    <span class="hljs-keyword">const</span> children = vnode.<span class="hljs-property">children</span><br>    <span class="hljs-keyword">const</span> tag = vnode.<span class="hljs-property">tag</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isDef</span>(tag)) &#123;<span class="hljs-comment">//如果有tag就是元素节点</span><br>        vnode.<span class="hljs-property">elm</span> = nodeOps.<span class="hljs-title function_">createElement</span>(tag, vnode)   <span class="hljs-comment">// 创建元素节点</span><br>        <span class="hljs-title function_">createChildren</span>(vnode, children, insertedVnodeQueue) <span class="hljs-comment">// 创建元素节点的子节点</span><br>        <span class="hljs-title function_">insert</span>(parentElm, vnode.<span class="hljs-property">elm</span>, refElm)       <span class="hljs-comment">// 插入到DOM中</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isTrue</span>(vnode.<span class="hljs-property">isComment</span>)) &#123;<br>      <span class="hljs-comment">//判断是否为注释节点，只需判断VNode的isComment属性是否为true</span><br>      vnode.<span class="hljs-property">elm</span> = nodeOps.<span class="hljs-title function_">createComment</span>(vnode.<span class="hljs-property">text</span>)  <span class="hljs-comment">// 创建注释节点</span><br>      <span class="hljs-title function_">insert</span>(parentElm, vnode.<span class="hljs-property">elm</span>, refElm)           <span class="hljs-comment">// 插入到DOM中</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//既不是元素节点，也不是注释节点，那就认为是文本节点</span><br>      vnode.<span class="hljs-property">elm</span> = nodeOps.<span class="hljs-title function_">createTextNode</span>(vnode.<span class="hljs-property">text</span>)  <span class="hljs-comment">// 创建文本节点</span><br>      <span class="hljs-title function_">insert</span>(parentElm, vnode.<span class="hljs-property">elm</span>, refElm)           <span class="hljs-comment">// 插入到DOM中</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="18-2-删除节点"><a href="#18-2-删除节点" class="headerlink" title="18.2 删除节点"></a>18.2 删除节点</h2><p>如果某些节点再新的VNode中没有而在旧的oldVNode中有，那么就需要把这些节点从旧的oldVNode中删除。删除节点非常简单，只需在要删除节点的父元素上调用removeChild方法即可。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> removeNode (el) &#123;<br>    const parent = nodeOps.parent<span class="hljs-constructor">Node(<span class="hljs-params">el</span>)</span>  <span class="hljs-comment">// 获取父节点</span><br>    <span class="hljs-keyword">if</span> (is<span class="hljs-constructor">Def(<span class="hljs-params">parent</span>)</span>) &#123;<br>      nodeOps.remove<span class="hljs-constructor">Child(<span class="hljs-params">parent</span>, <span class="hljs-params">el</span>)</span>  <span class="hljs-comment">// 调用父节点的removeChild方法</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="18-3-更新节点"><a href="#18-3-更新节点" class="headerlink" title="18.3 更新节点"></a>18.3 更新节点</h2><h3 id="更新子节点"><a href="#更新子节点" class="headerlink" title="更新子节点"></a>更新子节点</h3><p>更新节点过程中，新旧VNode可能都包含有子节点，对于子节点的对比更新会有额外的一些逻辑。以下四种情况：</p><ul><li>创建子节点<br>如果newChildren里面的某个子节点在oldChildren里找不到与之相同的子节点，那么说明newChildren里面的这个子节点是之前没有的，是需要此次新增的节点，那么就创建子节点。</li><li>删除子节点<br>如果把newChildren里面的每一个子节点都循环完毕后，发现在oldChildren还有未处理的子节点，那就说明这些未处理的子节点是需要被废弃的，那么就将这些节点删除。</li><li>移动子节点<br>如果newChildren里面的某个子节点在oldChildren里找到了与之相同的子节点，但是所处的位置不同，这说明此次变化需要调整该子节点的位置，那就以newChildren里子节点的位置为基准，调整oldChildren里该节点的位置，使之与在newChildren里的位置相同。</li><li>更新节点<br>如果newChildren里面的某个子节点在oldChildren里找到了与之相同的子节点，并且所处的位置也相同，那么就更新oldChildren里该节点，使之与newChildren里的该节点相同。</li></ul><h3 id="优化更新"><a href="#优化更新" class="headerlink" title="优化更新"></a>优化更新</h3><p><img src="https://vue-js.com/learn-vue/assets/img/8.e4c85c40.png" alt="img"></p><ol><li>新前等于旧前，无需进行节点移动操作</li><li>新后&#x3D;旧后，把newChildren数组里所有未处理子节点的最后一个子节点和oldChildren数组里所有未处理子节点的最后一个子节点做比对，如果相同，那就直接进入更新节点的操作并且由于新后与旧后两个节点的位置也相同，无需进行节点移动操作；如果不同，继续往后尝试。</li><li>新后&#x3D;旧前<br>相同，那就直接进入更新节点的操作，更新完后再将oldChildren数组里的该节点移动到与newChildren数组里节点相同的位置； <img src="https://vue-js.com/learn-vue/assets/img/11.2ddb5ee5.png" alt="img"><br>此时，出现了移动节点的操作，移动节点最关键的地方在于找准要移动的位置。我们一再强调，<strong>更新节点要以新VNode为基准，然后操作旧的oldVNode，使之最后旧的oldVNode与新的VNode相同</strong>。那么现在的情况是：newChildren数组里的最后一个子节点与oldChildren数组里的第一个子节点相同，那么我们就应该在oldChildren数组里把第一个子节点移动到最后一个子节点的位置，如下图：<br><img src="https://vue-js.com/learn-vue/assets/img/12.bace2f7f.png" alt="img"><br>从图中不难看出，我们要把oldChildren数组里把第一个子节点移动到数组中<strong>所有未处理节点之后</strong>。<br>如果对比之后发现这两个节点仍不是同一个节点，那就继续尝试最后一种情况。</li><li>新前&#x3D;旧后，把newChildren数组里所有未处理子节点的第一个子节点和oldChildren数组里所有未处理子节点的最后一个子节点做比对，如果相同，那就直接进入更新节点的操作，更新完后再将oldChildren数组里的该节点移动到与newChildren数组里节点相同的位置；<br><img src="https://vue-js.com/learn-vue/assets/img/13.98dbc208.png" alt="img"><br>同样，这种情况的节点移动位置逻辑与“新后与旧前”的逻辑类似，那就是newChildren数组里的第一个子节点与oldChildren数组里的最后一个子节点相同，那么我们就应该在oldChildren数组里把最后一个子节点移动到第一个子节点的位置，如下图：<br><img src="https://vue-js.com/learn-vue/assets/img/14.18c1c6dd.png" alt="img"><br>从图中不难看出，我们要把oldChildren数组里把最后一个子节点移动到数组中<strong>所有未处理节点之前</strong>。<br>准备4个变量：</li></ol><ul><li>**newStartIdx:**newChildren数组里开始位置的下标；</li><li>**newEndIdx:**newChildren数组里结束位置的下标；</li><li>**oldStartIdx:**oldChildren数组里开始位置的下标；</li><li>**oldEndIdx:**oldChildren数组里结束位置的下标；</li></ul><p>在循环的时候，每处理一个节点，就将下标向图中箭头所指的方向移动一个位置，开始位置所表示的节点被处理后，就向后移动一个位置；结束位置所表示的节点被处理后，就向前移动一个位置；由于我们的优化策略都是新旧节点两两更新的，所以一次更新将会移动两个节点。说的再直白一点就是：newStartIdx和oldStartIdx只能往后移动（只会加），newEndIdx和oldEndIdx只能往前移动（只会减）。<br>当开始位置大于结束位置时，表示所有节点都已经遍历过了。</p><h1 id="十九、Vue中key的作用"><a href="#十九、Vue中key的作用" class="headerlink" title="十九、Vue中key的作用"></a>十九、Vue中key的作用</h1><p>vue 中 key 值的作用可以分为两种情况来考虑：</p><ul><li>第一种情况是 v-if 中使用 key。由于 Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。因此当使用 v-if 来实现元素切换的时候，如果切换前后含有相同类型的元素，那么这个元素就会被复用。如果是相同的 input 元素，那么切换前后用户的输入不会被清除掉，这样是不符合需求的。因此可以通过使用 key 来唯一的标识一个元素，这个情况下，使用 key 的元素不会被复用。这个时候 key 的作用是用来标识一个独立的元素。</li><li>第二种情况是 v-for 中使用 key。用 v-for 更新已渲染过的元素列表时，它默认使用“就地复用”的策略。如果数据项的顺序发生了改变，Vue 不会移动 DOM 元素来匹配数据项的顺序，而是简单复用此处的每个元素。因此通过为每个列表项提供一个 key 值，来以便 Vue 跟踪元素的身份，从而高效的实现复用。这个时候 key 的作用是为了高效的更新渲染虚拟 DOM。<br>key 是为 Vue 中 vnode 的唯一标记，通过这个 key，diff 操作可以更准确、更快速</li><li>更准确：因为带 key 就不是就地复用了，在 sameNode 函数a.key &#x3D;&#x3D;&#x3D; b.key对比中可以避免就地复用的情况。所以会更加准确。</li><li>更快速：利用 key 的唯一性生成 map 对象来获取对应节点，比遍历方式更快</li></ul><h3 id="为什么不建议用index作为key"><a href="#为什么不建议用index作为key" class="headerlink" title="为什么不建议用index作为key"></a>为什么不建议用index作为key</h3><p>使用index 作为key和没写基本上没区别，因为不管数组的顺序怎么颠倒，index 都是 0, 1, 2…这样排列，导致 Vue 会复用错误的旧子节点，做很多额外的工作。</p><h1 id="二十、VUE异步事件队列-nextTick"><a href="#二十、VUE异步事件队列-nextTick" class="headerlink" title="二十、VUE异步事件队列(nextTick)"></a>二十、VUE异步事件队列(nextTick)</h1><p>当Vue侦听到数据变化时，如果同一个watcher被触发多次，只会被推入到队列 中一次，这种在缓冲时去除重复数据对于避免不必要的计算和DOM操作非常重要。在下一次<strong>事件循环tick</strong>时，Vue刷新队列并执行已经去重的工作。<br>nextick的<strong>核心</strong>是利用了Promise、MutationOberserver（监视DOM变动，实现异步触发，DOM变动后不会立刻触发，而是等到当前所有DOM操作都结束才去触发）和setImmediate（在浏览器完成其它语句后立刻执行其中回调函数，一般是执行时间比较长的）、setTimeout。<strong>本质是</strong>为了利用 JavaScript 的这些异步回调任务队列来实现 Vue 框架中自己的异步回调队列。</p><h2 id="引入异步更新队列机制的原因"><a href="#引入异步更新队列机制的原因" class="headerlink" title="引入异步更新队列机制的原因"></a>引入异步更新队列机制的原因</h2><p>①如果是同步更新，多次对一个或多个属性赋值，会频繁触发UI&#x2F;DOM的渲染，可以减少一些无用渲染。<br>②由于 VirtualDOM 的引入，每一次状态发生变化后，状态变化的信号会发送给组件，组件内部使用 VirtualDOM 进行计算得出需要更新的具体的 DOM 节点，然后对 DOM 进行更新操作，每次更新状态后的渲染过程需要更多的计算，而这种无用功也将浪费更多的性能，所以异步渲染变得更加至关重要。</p><p>Vue采用了数据驱动视图的思想，但是在一些情况下，仍然需要操作DOM。有时候，可能遇到这样的情况，DOM1的数据发生了变化，而DOM2需要从DOM1中获取数据，那这时就会发现DOM2的视图并没有更新，这时就需要用到了nextTick了。由于Vue的DOM操作是异步的，所以，在上面的情况中，就要将DOM2获取数据的操作写在$nextTick中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">this</span>.$nextTick(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-comment">// 获取数据的操作</span><br>    <span class="hljs-keyword">var</span> text = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;div&quot;</span>).<span class="hljs-property">innerHTML</span>;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(text);<br>&#125;&#125;<br></code></pre></td></tr></table></figure><h2 id="使用nextTick的情况"><a href="#使用nextTick的情况" class="headerlink" title="使用nextTick的情况"></a>使用nextTick的情况</h2><ol><li>在Vue生命周期的created()钩子函数进行的DOM操作一定要放在Vue.nextTick()的回调函数中。<br>因为在created()钩子函数执行的时候 DOM 其实并未进行任何渲染，而此时进行DOM操作无异于徒劳，所以此处一定要将DOM操作的js代码放进Vue.nextTick()的回调函数中。与之对应的就是mounted()钩子函数，因为该钩子函数执行时所有的DOM挂载和渲染都已完成，此时在该钩子函数中进行任何DOM操作都不会有问题 。</li><li>在数据变化后要执行的某个操作，而这个操作需要使用随数据改变而改变的DOM结构的时候，这个操作都应该放进Vue.nextTick()的回调函数中。</li></ol>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端杂项</title>
    <link href="/2022/05/12/%E5%89%8D%E7%AB%AF%E6%9D%82%E9%A1%B9/"/>
    <url>/2022/05/12/%E5%89%8D%E7%AB%AF%E6%9D%82%E9%A1%B9/</url>
    
    <content type="html"><![CDATA[<h4 id="一、前端和后端之间如何交互"><a href="#一、前端和后端之间如何交互" class="headerlink" title="一、前端和后端之间如何交互"></a>一、前端和后端之间如何交互</h4><p>1、前端通过ajax发起请求给后端<br>2、后端接收到请求之后，通过node里面的mysql模块连接数据库<br>3、数据库检测到请求，通过node的mysql模块给后端服务器返回数据<br>4、后端服务器接收到数据之后，将数据响应到前台页面</p><h4 id="二、前端向后端传输数据的手段"><a href="#二、前端向后端传输数据的手段" class="headerlink" title="二、前端向后端传输数据的手段"></a>二、前端向后端传输数据的手段</h4><h4 id="三、浏览器缓存机制"><a href="#三、浏览器缓存机制" class="headerlink" title="三、浏览器缓存机制"></a>三、浏览器缓存机制</h4><p>浏览器缓存是浏览器将用户请求过的静态资源（html、css、js）存储到电脑本地磁盘中，当浏览器再次访问时，可以知己从本地加载，不需要再去服务端请求。若处理不当，会导致服务端代码更新，但用户还是老页面。</p><h5 id="一、浏览器缓存的优点"><a href="#一、浏览器缓存的优点" class="headerlink" title="一、浏览器缓存的优点"></a>一、浏览器缓存的优点</h5><ul><li>减少了冗余的数据传输，节省网费。</li><li>减少了服务器的负担，提升网站性能。</li><li>加快了客户端加载网页的速度。<h5 id="二、缓存位置"><a href="#二、缓存位置" class="headerlink" title="二、缓存位置"></a>二、缓存位置</h5>四种，存在优先级，当依次查找缓存且都没有命中的时候才去请求网络。<br><strong>Service Worker</strong>：可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的。<br><strong>Memory Cache</strong>：内存缓存虽然读取高效，但缓存持续性很短，会随着进程的释放而释放。一旦关闭了Tab页面，内存中的缓存也就被释放了。<br><strong>Disk Cache</strong>：读取速度慢，但是什么都能存储到磁盘中，比内存缓存胜在容量和存储时效性上。<br><strong>Push Cache</strong>：当以上三种缓存都没有命中时，才会被使用。且缓存时间很短暂，只会在会话（session）中存在，一旦会话救赎就被释放。<br><strong>网络请求</strong>：以上缓存都没有命中，发送请求获取资源。<h5 id="三、缓存策略：强缓存和协商缓存"><a href="#三、缓存策略：强缓存和协商缓存" class="headerlink" title="三、缓存策略：强缓存和协商缓存"></a>三、缓存策略：强缓存和协商缓存</h5>1、<strong>强缓存</strong>：可以通过设置两种HTTP Header来实现，Expires和Cache-Control。<br>强缓存如果命中，返回state code为200，客户端不会给服务器发送请求，直接从本地获取资源。<br>Expries是一个时间戳，本地时间小于expires设置的过期时间，就说明命中强缓存，但本地时间改了会出错。<br>Cache-Control优先级更高，max-age是一个时间长度，例如3153600秒代表在3153600秒内有效。<br>S-maxage主要用于代理服务器生效。<br>public：浏览器和CDN都可以被缓存。<br>private：默认值，仅被览器缓存。</li></ul><p>强缓存也称为本地缓存，发送请求时向浏览器缓存查找请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程。<br>强缓存的情况主要分三种：<br>①浏览器缓存中不存在缓存请求结果和缓存标识，则浏览器直接向服务器发送请求。<br>②浏览器缓存中存在请求结果和缓存标识，但根据缓存规则结果已经失效，则使用协商缓存。<br>③浏览器缓存中存在请求结果和缓存标识，且根据缓存规则结果尚在有效时间内，则直接返回请求结果。<br>2、<strong>协商缓存（弱缓存）</strong>：如果缓存过期了，需要发起请求验证资源是否有更新。可以通过谁知两种HTTP Header来实现：Last-Modified和Tag。当两者同时存在，服务器会先检查Etag，再检查Last-Modified，最终决定返回200还是304.<br><strong>Last-Modified</strong>：服务器对比时间戳和资源在服务器上最后修改的时间是否一致，无法感知文件本身变化。<br>在浏览器第一次请求某个URL时，服务器端返回状态是200，内容是请求的资源，同时会有一个Last-Modified的属性标记此文件在服务器端最后被修改的时间。<br>客户端第二次请求此URL时，根据HTTP协议的规定，浏览器会向服务器传送If-Modified-Since报头，询问该时间之后文件是否有被修改过。<br>若服务器端的资源没有发生变化，则自动返回304状态码，内容为空，节省了传输数据量。<br><strong>Etag</strong>：是资源的唯一表示字符串。</p><p>浏览器缓存中存在请求结果和缓存标识，但根据缓存规则结果已经失效，只返回缓存标识。<br>①浏览器携带该资源的缓存标识发起HTTP请求，服务器验证缓存标识发现资源无更新，返回304，不更新资源。<br>②浏览器携带该资源的缓存标识发起HTTP请求，服务器验证缓存标识发现资源更新了，则返回200，重新返回请求结果和缓存标识。</p><h4 id="四、常用Git指令"><a href="#四、常用Git指令" class="headerlink" title="四、常用Git指令"></a>四、常用Git指令</h4><p><strong>git add</strong> 将工作区文件加入暂存区；<br><strong>git commit</strong> 将暂存区文件加入本地仓库；<br><strong>git push</strong> 将本地仓库推送到远程仓库。<br><strong>git fetch</strong> 将远程仓库的更新下拉到<strong>本地仓库中远程副本</strong>，但不合并到本地分支当中，并更新FETCH_HEAD<br>本地搭建：<br>初始化一个Git仓库，使用<strong>git init</strong>命令。在一个文件夹内。使用UTF-8编码编辑文本，避免冲突（不用记事本）<br>添加文件到Git仓库，分两步<br>git add <file>添加多个文件时使用空格分开，也可以输入文件夹名称；<br>使用命令git commit -m <message>，上传本地仓库。<br><strong>git status</strong> 可以查看本地仓库的状态，而如果有改动发生，则使用<strong>git diff</strong>这个命令<br><strong>克隆远程仓库</strong><br>在一个文件夹中打开git Bash并运行<strong>git clone [url]<strong>将克隆远程仓库并相关联<br>关联远程库<br>git remote add origin git@……<code>可以关联到远程仓库， 与origin远程库关联之后，需要pull </code>git pull origin <branch><code> 一下建立链接消除冲突， 然后将自己的代码push上去。</code>git push –set-upstream origin <branch><br><strong>取消关联</strong><br><code>git remote rm origin</code> 即可取消与远程仓库的关联。<br><strong>历史记录 git log</strong><br><code>git log</code> 查看历史记录<br><code>git log --pretty=oneline</code>  参数得到一行信息 <code>--graph</code>获得拓扑图<br><code>--oneline</code> 选项来查看历史记录的简洁的版本<br><code>git reflog</code>  用来记录版本操作命令<br><code>git blame &lt;file&gt;</code> 显示文件修改记录<br><strong>工作区和暂存区</strong><br>在电脑内部的文件目录就是</strong>工作</strong>，其中有一个版本库（本地仓库）存放了很多东西，其中最重要的就是称为stage（或index）的<strong>暂存区</strong>，还有Git为我们自动创建的第一个分支<code>master</code>，以及指向<code>master</code>的一个指针叫<code>HEAD</code><br>我们使用 <code>git add</code> 就是将文件添加到暂存区，然后用 <code>git commit</code> 将暂存区的文件提交到分支上 （本地仓库）</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS</title>
    <link href="/2022/05/12/CSS/"/>
    <url>/2022/05/12/CSS/</url>
    
    <content type="html"><![CDATA[<h1 id="零、网页布局准则"><a href="#零、网页布局准则" class="headerlink" title="零、网页布局准则"></a>零、网页布局准则</h1><p>一、多个块级元素纵向排列找标准流，多个块级元素横向排列找浮动流。<br>二、先设置盒子大小，再设置盒子位置。</p><p><strong>一般策略</strong>：先用标准流的父元素排列上下位置，再用内部子元素采取浮动排列找左右位置。</p><h4 id="页面布局思路"><a href="#页面布局思路" class="headerlink" title="页面布局思路"></a>页面布局思路</h4><p>1.确定页面的版心（中心可视区）<br>2.分析页面中的行模块，以及每个行模块中的列模块。<br>3.一行中的列模块经常浮动布局，先确定每个列的大小，之后确定列的位置。<br>4.制作html结构，先有结构，后有样式。</p><h1 id="一、CSS常用属性"><a href="#一、CSS常用属性" class="headerlink" title="一、CSS常用属性"></a>一、CSS常用属性</h1><h2 id="一、文字相关"><a href="#一、文字相关" class="headerlink" title="一、文字相关"></a>一、文字相关</h2><ul><li>font-family：定义文本的字体，可以多个字体，每个字体用逗号分隔，靠前的字体先用。</li><li>font-size：定义字体的大小，单位为px。</li><li>font-weight：设置文字粗细，normal正常，bold粗体。可以直接写数字，400为normal，700为bold。</li><li>font-style：设置字体样式，normal为正常。italic斜体，inherit继承父元素样式。</li><li>font：每个具体属性用空格隔开，顺序不能更换：font-style、font-weight、font-size&#x2F;line-height、font-family。必须有font-size和font-family。</li><li>color：设置文字颜色。可以直接英文单词，或者#后跟十六进制树，或者rgb(a,b,c)</li><li>text-align：设置文本内容的水平对齐方式center、left、right。<strong>行内元素或行内块元素水平居中给其父元素添加text-align:center</strong>。</li><li>text-decoration：给文本添加下划线（underline）、上划线（overline）、删除线（line-through）、默认无线（none）。<strong>一般用于去除链接的下划线</strong>。</li><li>text-indent：用于指定文本第一行的缩进，通常是将段落首行进行缩进。单位为px或em（1个文字大小）。</li><li>line-height：用于设置行高。<strong>文字垂直居中时直接设置行高和盒子高一样</strong>。行高小于盒子高度文字会偏上，行高大于盒子高度文字会偏下。</li><li>text-shadow：文本阴影。h-shadow必须，水平阴影的位置，允许负值。v-shadow必须，垂直阴影的位置。blur可选，模糊距离，表示阴影的深浅。color可选，阴影颜色。</li><li>white-space：规定段落p中的文本是否换行。默认normal换行，nowrap不换行。</li><li>text-overflow：规定当文本溢出包含元素时发生的事情。clip默认值，修剪文本。ellipsis用省略号代替被修剪的文字。string用给定的字符串来代表被修剪的文字。</li></ul><h2 id="二、盒子背景相关"><a href="#二、盒子背景相关" class="headerlink" title="二、盒子背景相关"></a>二、盒子背景相关</h2><ul><li>background-color：背景颜色，transparent默认透明色。</li><li>background-image：背景图片，便于控制位置、logo或者大图片。none或者url(url)。</li><li>background-repeat：对背景图片进行平铺repeat、不平铺no-repeat、x轴方向平铺repeat-x、y轴方向平铺repeat-y。默认是平铺的。</li><li>background-position：改变图片在背景中的位置。x和y代表坐标，可以使用方位名词或精确单位。方位名词和顺序没有关系，只写一个方位另一个默认居中对其：left、right、top、center、bottom。精确单位先x后y。可以使用混合单位，第一个一定是x，第二个一定是y。</li><li>background-attachment：设置背景图像固定或者随着页面滚动。scroll滚动（默认），fixed固定。</li><li>background：背景颜色、背景图片地址、背景平铺、背景图像滚动、背景图片位置。</li><li>background:rgba(0,0,0,0)：前面三个是rgb，最后是透明(0~1)。只有背景色半透明。</li><li>background-size: width height：设置背景图片的宽度和高度。可以直接用百分比，相对于父盒子。cover完全覆盖盒子（可能有部分背景显示不全）、content把图像扩大到最大区域，高度宽度等比例拉伸，宽度或高度铺满盒子时就不再进行拉伸。</li><li>background:linear-gradient(起始方向，颜色1，颜色2…..）：设置背景线渐变颜色。</li></ul><img src="/2022/05/12/CSS/%E8%83%8C%E6%99%AF%E6%B8%90%E5%8F%98.png" class=""> <h2 id="三、盒子模型"><a href="#三、盒子模型" class="headerlink" title="三、盒子模型"></a>三、盒子模型</h2><ul><li>border：边框UC逆袭，样式，颜色。</li><li>border-width：边框粗细，单位px。边框占盒子以外宽度，<strong>边框会额外增加盒子的实际大小</strong>，测量时要么不量边框，要么高宽减去边框粗细。</li><li>border-style：边框样式，默认none，solid实线边框，dashed虚线边框，dotted点线边框。</li><li>border-color：边框颜色。</li><li>border-collapse：collapse合并两个盒子的边框。</li><li>border-radius：用于设置元素的外边框圆角，数值length是圆的半径，单位可以是px或者%。左上角、右上角、右下角、左下角。若想使用椭圆角，每个值为apx&#x2F;bpx。</li></ul><img src="/2022/05/12/CSS/%E5%9C%86%E8%A7%92.png" class=""> <ul><li>border-top-left-radius、border-top-right-radius、border-bottom-left-radius、border-bottom-right-radius</li><li>padding：内边距，单位px。<strong>内边距会撑大盒子原来宽高，如果盒子本身没有指定width&#x2F;height属性，则此时padding不会撑开盒子大小。</strong></li></ul><img src="/2022/05/12/CSS/%E5%86%85%E8%BE%B9%E8%B7%9D.png" class=""> <ul><li>padding-left、padding-right、padding-top、padding-bottom：左右上下边框。</li><li>margin：外边距，控制盒子之间的距离，用法同上。</li><li>box-shadow：为盒子添加阴影。h-shadow必须，水平阴影的位置，允许负值。v-shadow必须，垂直阴影的位置，允许负值。blur可选，模糊距离，表示阴影的深浅。spread可选，阴影的尺寸。inset可选，将外部阴影改为内部阴影，默认outset。<strong>阴影不占空间</strong>。</li></ul><h2 id="四、表单"><a href="#四、表单" class="headerlink" title="四、表单"></a>四、表单</h2><ul><li>outline：值为0或者none来去掉input表单默认的蓝色边框。</li><li>resize：给textarea添加该属性，值为none，用户就不能自由拖拽文本域大小。</li></ul><h2 id="五、杂项"><a href="#五、杂项" class="headerlink" title="五、杂项"></a>五、杂项</h2><ul><li>list-style：none。去除li前面的小圆点。</li><li>float：浮动。none不浮动，默认值。left元素左浮动，right元素右浮动。</li><li>position：定位模式，包括static静态定位、relative相对定位、absolute绝对定位和fixed固定定位。</li><li>display：block元素显示，none元素隐藏。</li><li>visibility：visible元素可视，hidden元素隐藏。</li><li>overflow：内容溢出一个元素的框时是否显示。visible默认可视；hidden隐藏；scroll溢出部分显示滚动条，不溢出也显示滚动条；auto溢出的时候才显示滚动条。</li><li>vertical-align：设置元素的垂直对齐方式，只针对行内元素或者行内块元素，<strong>常用与设置图片或表单和文字垂直对齐</strong>。basline默认，元素放在父元素的基线上。top把元素的顶端与行中最高元素的顶端对齐。middle把此元素放在父元素的中部。bottom把元素的底端与行中最低的元素的底端对齐。<strong>图片底部默认与外盒子有空白缝隙，是因为行内块元素会和文字的基线对齐，解决方法是给图片添加vertical-align:middle | top | bottom，或者把图片转换为块级元素</strong>。</li><li>transition：实现过渡效果，当元素从一种样式变换为另一种样式时为元素添加效果，常常与hover搭配使用。包括：要过渡的属性、花费时间、运动曲线（默认ease先快后慢）、何时开始。</li></ul><h2 id="六、CSS3新增"><a href="#六、CSS3新增" class="headerlink" title="六、CSS3新增"></a>六、CSS3新增</h2><ul><li>autoplay：video或者audio是否自动播放。autoplay自动播放。</li><li>controls：video或者audio是否向用户展示播放控件，controls播放控件。</li><li>loop：video或者audio是否循环播放，loop循环播放。</li></ul><hr><p>video相关</p><ul><li>muted：是否静音。muted静音模式。</li><li>preload：是否预加载视频。auto预先加载视频，none不预先加载视频。</li><li>poster：加载等待的画面图片，为url地址。</li></ul><hr><p>input表单相关</p><ul><li>type：email限制用户输入必须为email类型。url限制用户输入必须为url类型。date限制用户输入必须为日期类型。time限制用户输入必须为时间类型。month限制用户输入必须为月类型。week限制用户输入必须为周类型。number限制用户输入必须为数字类型。tel限制用户输入必须为手机号码。search搜索框。color生成颜色选择表单。</li><li>required：required输入不能为空。</li><li>placeholder：提示文本。修改文本样式在style里input::placeholder调用设置。</li><li>autofocus：autofocus进入页面时自动获取焦点。</li><li>autocomplete：on&#x2F;off。浏览器之前输入的值显示在字段中填写的选项，表单必须有name属性。</li><li>multiple：multiple可以多选文件提交。</li></ul><h1 id="二、常用html标签"><a href="#二、常用html标签" class="headerlink" title="二、常用html标签"></a>二、常用html标签</h1><img src="/2022/05/12/CSS/%E6%A0%87%E7%AD%BE1.PNG" class=""> <img src="/2022/05/12/CSS/%E6%A0%87%E7%AD%BE2.PNG" class=""> <img src="/2022/05/12/CSS/%E6%A0%87%E7%AD%BE3.PNG" class=""> <h1 id="三、CSS盒模型"><a href="#三、CSS盒模型" class="headerlink" title="三、CSS盒模型"></a>三、CSS盒模型</h1><p>两种盒模型，box-sizing属性：content-box | border-box | inherit</p><ul><li>content-box 默认值：<strong>标准盒模型</strong>。边框border和内边距padding的值不包含在width之内。对象的实际宽度等于设置的width值和border、padding之和。</li></ul><img src="/2022/05/12/CSS/content-box.png" class="" title="标准盒模型"> <ul><li>border-box <strong>IE盒模型</strong>。边框border和内边距padding的值是包含在width之内的。对象的实际宽度就等于设置的width值。</li></ul><img src="/2022/05/12/CSS/border-box.png" class="" title="IE盒模型"> <h1 id="四、块级元素和行级元素（内联元素）"><a href="#四、块级元素和行级元素（内联元素）" class="headerlink" title="四、块级元素和行级元素（内联元素）"></a>四、块级元素和行级元素（内联元素）</h1><ol><li>块级元素：每个块级元素独占一行，元素的高度、宽度、行高和边距可设置，元素的宽度不设置的话默认为父元素的宽度（父元素宽的100%），里面可以放其他元素，<strong>文字类块元素中不允许再放其他元素</strong>。包括：div、p、ul、li、h、form、hr、ol、dl、dt、dd、address、article、figure、audio、video、section、table、canvas、header、footer。</li><li>行级元素：每个行内元素可以和别的行内元素共享一行，相邻的行内元素会排列到同一行内，直到一行排不下了，才会换行。行内元素的高度、宽度、行高及顶部和底部边距不可设置。元素的宽度就是它包含的文字或图片的宽度，不可改变。包括span、a、br、img、input、textare、select、sup、sub、em、del</li><li>行内块元素：一行上可以有多个，默认为自己的宽，高度宽度内外边距都可以控制。包括img、input、td。</li><li>区别：<br>①排列方式：块级元素会独占一行，内联元素和内联块元素会在一行内显示。<br>②宽高边距设置：块级元素和内联块元素可以设置宽高，内联元素设置无效。<br>③默认宽度：块级元素width默认为100%，内联元素则是根据自身的内容或子元素来决定其宽度。</li><li>转换</li></ol><ul><li>display: block; 把行内元素转换为块元素。</li><li>display：inline; 把块元素转换为行内元素。</li><li>display: inline-block; 把元素转换为行内块元素。</li></ul><h1 id="五、CSS的单位"><a href="#五、CSS的单位" class="headerlink" title="五、CSS的单位"></a>五、CSS的单位</h1><ul><li>px：像素，相对长度单位，相对于显示器屏幕分辨率而言的。可以设置绝对字体大小。1px在高清屏幕下可能占用2个甚至3个物理像素。</li><li>em：相对长度单位，相对于当前对象内文本的一个字体的尺寸。根据其<strong>父元素</strong>的字体大小font-size来设置。</li><li>rem：相对单位，相对于根元素（一般为html）的font-size来计算，适用于响应式页面。通过它既可以做到只修改根元素就成比例地调整所有字体的大小，又可以避免字体大小逐层复合的连锁反应。</li><li>%：相对于父元素的长度高度。position:fixed时，无论当前元素仿真哪里，将相对于窗口宽度。position:absolute时，将相对于其相对的元素宽度（递归父元素直到第一个设置了position的元素）</li><li>vh&#x2F;vw：相对于视窗Viewport的高度和宽度，1vh等于1&#x2F;100的视窗高度，1vw等于1&#x2F;100的视窗宽度。视窗是指浏览器内部的课时区域大小，即window.innerWidth&#x2F;window.innerHeight大小，不包含任务栏标题栏以及底部工具栏的浏览器区域大小。</li><li>vmin&#x2F;vmax：vmin取视窗高度和宽度的最小值作为基准。vmax取视窗高度和宽度的最大值作为基准。使用场景是保持字体在横屏和竖屏状态下显示的字体大小一致。</li></ul><h1 id="六、绝对路径和相对路径"><a href="#六、绝对路径和相对路径" class="headerlink" title="六、绝对路径和相对路径"></a>六、绝对路径和相对路径</h1><h4 id="相对路径"><a href="#相对路径" class="headerlink" title="相对路径"></a>相对路径</h4><ul><li>同一级路径：url直接是调用的文件名。</li></ul><img src="/2022/05/12/CSS/%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84.jpg" class="" title="相对路径"> <h4 id="绝对路径"><a href="#绝对路径" class="headerlink" title="绝对路径"></a>绝对路径</h4><p>目录下的绝对位置。”&quot;或者完整网络地址。</p><h1 id="七、伪类与伪元素"><a href="#七、伪类与伪元素" class="headerlink" title="七、伪类与伪元素"></a>七、伪类与伪元素</h1><p>CSS引入伪类和伪元素概念是为了格式化文档树之外的信息，也就是说伪类和伪元素是用来修饰不在文档树中的部分。比如，一句话中的一个字母，或者是列表中的第一个元素。</p><h4 id="伪类"><a href="#伪类" class="headerlink" title="伪类"></a>伪类</h4><p>伪类用于定义元素的特殊状态。如：</p><ul><li>a:link 选择所有未被访问的链接。</li><li>a:visited 选择所有已被访问的链接。</li><li>a:hover 选择鼠标指针位于其上的链接。</li><li>a:active 选择活动链接（鼠标按下未抬起的链接）</li><li>:focus 选取获得焦点的表单元素，一般input类表单元素才能获取。<br>伪类用于当已有元素处于某个状态时，为其添加对应的样式，这个样式是根据用户的行为而动态变化的。<figure class="highlight html"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-tag">p</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">display</span>: none;</span><br><span class="language-css">    <span class="hljs-attribute">background-color</span>: red;</span><br><span class="language-css">    <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span>;</span><br><span class="language-css">&#125;</span><br><span class="language-css"> <span class="hljs-selector-tag">div</span>: hover p &#123;</span><br><span class="language-css">    <span class="hljs-attribute">display</span>: block;</span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>鼠标移动到我上面来显示p元素<br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我在这里<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="伪元素"><a href="#伪元素" class="headerlink" title="伪元素"></a>伪元素</h4><p>伪元素用于将特殊的效果添加到某些选择器，伪元素代表了某个元素的子元素，这个元素虽然逻辑上存在，但却并不实际存在于文档树中。<br>伪元素用于设置元素指定部分的样式，如：</p><table><thead><tr><th align="left">选择器</th><th align="left">例子</th><th align="left">例子描述</th></tr></thead><tbody><tr><td align="left"><a href="https://www.w3school.com.cn/cssref/selector_after.asp">::after</a></td><td align="left">p::after</td><td align="left">在每个 <p> 元素之后插入内容。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/cssref/selector_before.asp">::before</a></td><td align="left">p::before</td><td align="left">在每个 <p> 元素之前插入内容。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/cssref/selector_first-letter.asp">::first-letter</a></td><td align="left">p::first-letter</td><td align="left">选择每个 <p> 元素的首字母。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/cssref/selector_first-line.asp">::first-line</a></td><td align="left">p::first-line</td><td align="left">选择每个 <p> 元素的首行。</td></tr><tr><td align="left"><a href="https://www.w3school.com.cn/cssref/selector_selection.asp">::selection</a></td><td align="left">p::selection</td><td align="left">选择用户选择的元素部分。</td></tr></tbody></table><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">selector::pseudo-element &#123;<br>    property: value;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="八、CSS选择器与权重"><a href="#八、CSS选择器与权重" class="headerlink" title="八、CSS选择器与权重"></a>八、CSS选择器与权重</h1><p>1、!important：加在样式属性值后，权重值为无穷大。如color:green!important。<br>2、行内样式style&#x3D;””：权重1000，直接写在标签内。<br>3、ID选择器：权重100，如#content。<br>4、类(.)、伪类和属性选择器，如content、:hover，权重为10。<br>5、标签选择器和伪元素选择器，如div、p、::before权重值为1。<br>6、通配符选择器（*）、子选择器（&gt;）、相邻选择器（+）、同胞选择器（~），权重为0。<br>7、后代选择器：如div .title {color: red}。前一个选择器跟后一个选择器。<br>8、子元素选择器：只在儿子层找，如div&gt;p {color: red}<br>9、并集选择器：同时匹配所有选择元素，div,p,h1 {color: red}<br>10、毗邻选择器：紧挨着相邻的，只找下面的不找上面的，只找一个。如.c2+p {color: red}<br>11、兄弟选择器：同一级之后的所有，如.c2~p {color: red}<br>12、属性选择器：选择具有某个属性的元素。<br>E[art]选择具有art属性的E元素。<br>E[att&#x3D;val]选择具有att属性且属性值等于val的E元素。<br>E[att^&#x3D;val]选择具有att属性且属性值以val开头的E元素。<br>E[att$&#x3D;val]选择具有att属性且属性值以val结尾的E元素。<br>E[att*&#x3D;val]选择具有att属性且属性值中含有val的E元素。</p><p>E[att~&#x3D;val]选择具有att属性且属性值中含有单个val单词的E元素。</p><p>13、结构伪类选择器：根据文档结构来选择元素。<br>E:first-child：匹配父元素中第一个子元素E。<br>E:last-child：匹配父元素中最后一个E元素。<br>E:nth-child(n)：匹配父元素中的第n个子元素E。<br>E:first-of-type：指定标签为E的第一个。<br>E:last-of-type：指定标签为E的最后一个。<br>E:nth-of-type(n)：指定标签为E的第n个。</p><h1 id="九、实现扇形、半圆、圆形、椭圆"><a href="#九、实现扇形、半圆、圆形、椭圆" class="headerlink" title="九、实现扇形、半圆、圆形、椭圆"></a>九、实现扇形、半圆、圆形、椭圆</h1><h4 id="扇形"><a href="#扇形" class="headerlink" title="扇形"></a>扇形</h4><p>一个角是圆角，其它三个角都是直角。圆角的值为宽和高一样的值，其它三个角的值为0。border-radius的四个值顺序是：左上角、右上角、右下角、左下角。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-tag">div</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">100px</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span>;</span><br><span class="language-css">        <span class="hljs-attribute">background-color</span>: blue;</span><br><span class="language-css">    &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><img src="/2022/05/12/CSS/%E6%89%87%E5%BD%A2.png" class=""> <h4 id="半圆"><a href="#半圆" class="headerlink" title="半圆"></a>半圆</h4><p>相邻的两个角的半径一样。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-tag">div</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">100px</span> <span class="hljs-number">100px</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span>;</span><br><span class="language-css">        <span class="hljs-attribute">background-color</span>: blue;</span><br><span class="language-css">    &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><img src="/2022/05/12/CSS/%E5%8D%8A%E5%9C%86.png" class=""><h4 id="圆"><a href="#圆" class="headerlink" title="圆"></a>圆</h4><p>正方形里四个角的半径都是宽高的一半。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-tag">div</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">100px</span> <span class="hljs-number">100px</span> <span class="hljs-number">100px</span> <span class="hljs-number">100px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">background-color</span>: blue;</span><br><span class="language-css">    &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="椭圆"><a href="#椭圆" class="headerlink" title="椭圆"></a>椭圆</h4><p>盒子长宽不同直接用相同百分比或apx&#x2F;bpx。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-tag">div</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">50%</span>；</span><br><span class="language-css">        background-color: blue;</span><br><span class="language-css">    &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><img src="/2022/05/12/CSS/%E6%A4%AD%E5%9C%86.png" class=""><h4 id="扇形-1"><a href="#扇形-1" class="headerlink" title="扇形"></a>扇形</h4><p>给透明圆的某一个边的方向增加颜色。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-tag">div</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">        <span class="hljs-attribute">border</span>: <span class="hljs-number">100px</span> solid transparent;</span><br><span class="language-css">        <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">border-top-color</span>: red;</span><br><span class="language-css">    &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><img src="/2022/05/12/CSS/%E4%B8%8B%E8%A7%92%E6%89%87%E5%BD%A2.png" class=""><h1 id="十、网页布局的三种方式"><a href="#十、网页布局的三种方式" class="headerlink" title="十、网页布局的三种方式"></a>十、网页布局的三种方式</h1><ul><li>标准文档流：标签按照默认规定好的方式进行排列。从上到下，从左到右，盒子模型尺寸等于边框+外边距+内边距+盒子中间内容尺寸。</li><li>浮动流：可以改变元素标签默认的排列方式。</li><li>绝对定位流：包括静态定位、相对对位、绝对定位。有层叠概念，可以让多个盒子前后叠压来显示，如果元素自由在某个黑子内移动就用定位布局。</li></ul><h1 id="十一、浮动float、高度塌陷和去除浮动"><a href="#十一、浮动float、高度塌陷和去除浮动" class="headerlink" title="十一、浮动float、高度塌陷和去除浮动"></a>十一、浮动float、高度塌陷和去除浮动</h1><h4 id="一、浮动float"><a href="#一、浮动float" class="headerlink" title="一、浮动float"></a>一、浮动float</h4><ul><li>浮动属性用于创建浮动框，将其按照指定方向移动，直到左边缘或者右边缘触及包含块或另一个浮动框的边缘（直接贴到一起）。</li><li>float：浮动。none不浮动，默认值。left元素左浮动，right元素右浮动。</li></ul><h4 id="二、浮动特性"><a href="#二、浮动特性" class="headerlink" title="二、浮动特性"></a>二、浮动特性</h4><ul><li>浮动元素会脱离标准流的控制，移动到指定位置，浮动的盒子不再保留原来的位置，浮动只会压住后面的标准流，不会压住前面的。</li><li>浮动的元素会一行内显示并且元素顶端对齐，如果装不下了会自动换行。</li><li><strong>浮动的元素会具有行内块元素的特性</strong>。如果元素有了浮动，<strong>不需要转换直接可以给高度和宽度</strong>。如果元素没有设置宽度，添加浮动后，它的大小根据内容来决定。</li></ul><h4 id="三、高度塌陷"><a href="#三、高度塌陷" class="headerlink" title="三、高度塌陷"></a>三、高度塌陷</h4><p>一个元素设置了浮动之后，会影响其兄弟元素的位置和父级盒子的高度。父级盒子在很多情况下，不方便给高度，但是盒子浮动不占有位置，不会撑起父级盒子的高度，最后导致父级盒子高度为0，会影响后续的标准流盒子。<br>1、如果兄弟元素是块级元素，会无视这个浮动的边框，使自身尽可能与这个浮动元素处于同一行，导致被浮动元素覆盖。除非这些div设置了宽度，并且父元素的宽度不足以包含它们，导致强制换行。<br>2、若是内联元素，则会尽可能围绕浮动元素。如<strong>浮动元素不会压住后续盒子里的文字，文字会围绕浮动元素显示</strong>。</p><h4 id="四、清除浮动"><a href="#四、清除浮动" class="headerlink" title="四、清除浮动"></a>四、清除浮动</h4><ul><li>额外标签法（隔离法）：在浮动元素末尾添加一个空的标签（必须为块级元素），并将该标签设置为clear:both。<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs applescript">.clear&#123;<br>    clear: both;<br>&#125;<br>&lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;clear&quot;</span>&gt;&lt;/<span class="hljs-keyword">div</span>&gt;<br></code></pre></td></tr></table></figure></li><li>父级元素添加overflow属性：属性值设定为hidden、auto或scroll。用在同一个容器内形成BFC独立容器避免浮动造成的元素塌陷。</li><li>父级添加after伪元素：<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dts">.clearfix:<span class="hljs-title class_">after</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    content:</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">;</span><br><span class="hljs-symbol">    display:</span> <span class="hljs-attr">block</span><span class="hljs-punctuation">;</span><br><span class="hljs-symbol">    height:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">;</span><br><span class="hljs-symbol">    clear:</span> <span class="hljs-attr">both</span><span class="hljs-punctuation">;</span><br><span class="hljs-symbol">    visibility:</span> <span class="hljs-attr">hidden</span><span class="hljs-punctuation">;</span><br><span class="hljs-punctuation">&#125;</span><br>.<span class="hljs-title class_">clearfix</span> <span class="hljs-punctuation">&#123;</span> <span class="hljs-comment">/* IE6、7专有*/</span><br>    *zoom: <span class="hljs-number">1</span><span class="hljs-punctuation">;</span><br><span class="hljs-punctuation">&#125;</span><br><span class="hljs-params">&lt;div class=&quot;clearfix&quot;&gt;</span><span class="hljs-params">&lt;/div&gt;</span><br></code></pre></td></tr></table></figure></li><li>父级添加双伪元素:<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs applescript">.clearfix:<span class="hljs-keyword">before</span>,<br>.clearfix:<span class="hljs-keyword">after</span> &#123;<br>    content: <span class="hljs-string">&quot;&quot;</span>;<br>    display: table;<br>&#125;<br>.clearfix:<span class="hljs-keyword">after</span> &#123;<br>    clear: both;<br>&#125;<br>.clearfix &#123;<br>    *zoom: <span class="hljs-number">1</span>;<br>&#125;<br>&lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;clearfix&quot;</span>&gt;&lt;/<span class="hljs-keyword">div</span>&gt;<br></code></pre></td></tr></table></figure></li><li>为父级元素单独定义高度</li></ul><h1 id="★十二、position定位和子绝父相"><a href="#★十二、position定位和子绝父相" class="headerlink" title="★十二、position定位和子绝父相"></a>★十二、position定位和子绝父相</h1><p>将盒子定在某一位置，包括定位模式和边偏移。定位模式用于指定一个元素在文档中的定位方式，边偏移决定了该元素的最终位置。<br><strong>定位模式</strong>：position属性设置，包括static静态定位、relative相对定位、absolute绝对定位和fixed固定定位。<br><strong>边偏移</strong>：定位盒子移动到最终位置，包括top、bottom、left和right，元素相对于其父元素边线的位置。例如left:50%</p><ul><li>static静态定位：默认定位方式，无定位。按照标准流特性摆放位置，没有边偏移。</li><li>relative相对定位：相对于其原本的位置进行定位。<strong>原来在标准流的位置继续占有</strong>，后续盒子仍以标准流的方式对待它。</li><li>absolute绝对定位：元素相对于其第一个父元素进行定位。如果没有祖先元素或者祖先元素没有定位，则以浏览器为准定位。<strong>绝对定位不再占有原来的位置</strong>。</li><li>fixed固定定位：相对于浏览器的可视窗口进行定位。<strong>使用场景是浏览器页面滚动时元素的位置不会改变</strong>。跟父元素没有任何关系，不随滚动条滚动而滚动。<strong>不占原来的位置</strong>。<br><strong>tips</strong>：固定定位在版心右侧时，可以让盒子left:50%，然后margin-left:版心宽度的一半，多走版心宽度一半的位置。</li><li>sticky粘性定位：相对定位和固定定位的结合。在屏幕中时按常规流排版，当移动到屏幕外时表现如fixed。<strong>占有原来位置</strong>。必须添加top、left、right和bottom其中之一才有效果。</li><li>center：以祖先元素的中心点为参考，盒子在其包容容器内垂直水平居中。与absolute绝对定位一致。</li><li>page：与absolute一致。元素在分页媒体或者区域块内，元素的包含块始终是初始包含块，否则取决于每个absolute模式。</li></ul><h4 id="子绝父相"><a href="#子绝父相" class="headerlink" title="子绝父相"></a>子绝父相</h4><p>子元素是绝对定位的话，父元素要用相对定位。子级绝对定位，不会占有位置，可以放到父盒子里面的任何一个地方，不会影响其他的兄弟盒子。父盒子需要加定位限制子盒子在父盒子内的显示。父盒子布局时，需要占有文职，因此父亲只能是相对定位。</p><ul><li>z-index：控制盒子的前后次序。可以是正整数、负整数或者0。数值越大，盒子越靠上。如果数值相同，按照书写顺序，后面的在上面。数字不能加单位，只有设置了定位的盒子才能这么写。</li><li>绝对定位和固定定位盒子居中：水平居中:left:50%;   margin-left:-盒子宽&#x2F;2。垂直居中类似。</li></ul><h1 id="十三、display、position与float区别"><a href="#十三、display、position与float区别" class="headerlink" title="十三、display、position与float区别"></a>十三、display、position与float区别</h1><ol><li>首先判断display属性是否为none，如果为none，则position和float属性的值不影响最后元素的表现。</li><li>然后判断position的值是否为absolute或者fixed。如果是，则float属性失效，并且display的值应该被设置为table或者block，具体转换需要看初始转换值。</li><li>如果position的值不为absolute或者fixed，则判断float属性的值是否为none。如果不是，则display的值按上面的规则进行转换。如果position的值为relative且float属性的值存在，则relative相对于浮动后的最终定位。</li><li>如果float值为none，则判断元素是否为根元素。如果是根元素则display属性按照上面的规则转换，如果不是则保持指定的display属性不变。</li><li><strong>总的来说，可以把它看作是一个类似优先级的机制，”position:absolute”和”position:fixed”优先级最高，有它存在的时候，浮动不起作用，’display’的值也需要调整；其次，元素的’float’特性的值不是”none”的时候或者它是根元素的时候，调整’display’的值；最后，非根元素，并且非浮动元素，并且非绝对定位的元素，’display’特性值同设置值。</strong></li></ol><h1 id="十四、display布局"><a href="#十四、display布局" class="headerlink" title="十四、display布局"></a>十四、display布局</h1><ul><li>block：把行内元素转换为块元素。默认为父元素宽度，显示元素。可设置宽高、换行显示。</li><li>none：元素不显示，并从文档流中移除。隐藏后的元素不再占有原来位置。</li><li>inline：把块元素转换为行内元素。默认宽度为内容宽度，不可设置宽高，同行显示。</li><li>inline-block：把元素转换为行内块元素。默认宽度为内容宽度，可以设置宽高，同行显示。</li><li>list-item：像块类型元素一样显示，并添加样式列表标记。</li><li>table：此元素作为块级表格来显示。</li><li>inherit：规定应该从父元素继承display属性的值。</li></ul><h1 id="★十五、隐藏元素的方法"><a href="#★十五、隐藏元素的方法" class="headerlink" title="★十五、隐藏元素的方法"></a>★十五、隐藏元素的方法</h1><ul><li>display:none ：显示隐藏，隐藏后元素不再占有原来位置。会导致浏览器的重排和重绘。元素会从渲染树中消失，渲染时不会占据任何空间。是非继承属性，子孙节点会随着父节点从渲染树中消失，通过修改子孙节点的属性也无法显示。<strong>修改元素的display通常会造成文档的重排</strong>。</li><li>visibility:hidden ：显示隐藏，隐藏后元素依旧占据原来位置。元素在页面小时后，只会导致浏览器重绘，不会重排，适用于元素隐藏后不希望页面布局发生变化的场合。是继承属性，子孙节点消失是由于继承了hidden，通过设置visibility:visible来让子孙节点显示。修改visibility只会导致本元素的重绘。</li><li>opacity:0 ：设置元素透明度为0，占物理位置。元素隐藏后依旧占据原来空间，只是隐身了，元素仍存在于页面中。 </li><li>text-shadow：文本阴影。h-shadow必须，水平阴影的位置，允许负值。v-shadow必须，垂直阴影的位置。blur可选，模糊距离，表示阴影的深浅。color可选，阴影颜色。</li></ul><h1 id="十六、根据子元素数量不同设置不同样式，并判断子元素数量"><a href="#十六、根据子元素数量不同设置不同样式，并判断子元素数量" class="headerlink" title="十六、根据子元素数量不同设置不同样式，并判断子元素数量"></a>十六、根据子元素数量不同设置不同样式，并判断子元素数量</h1><ul><li>:only-child：匹配属于其父元素的唯一子元素的每个元素。</li><li>:last-child：选择属于其父元素的最后一个匹配子元素。</li><li>:first-child：选择属于其父元素的第一个匹配子元素。</li><li>:nth-child(n)：选择属于其父元素的第n个子元素。可以是数字（从1开始）、关键字和公式。even偶数，odd奇数。</li><li>:nth-last-child(n)：选择属于其父元素从后往前数的第n个子元素。</li><li>～ 是与所选元素同级，位于所选元素之后的所有兄弟元素。</li></ul><hr><p>例如，要实现以下功能：<br>①一张图片一行显示尺寸690px；<br>②2张图片一行显示尺寸320px，4张图片两行显示，每行2张各占320px。<br>③大于3张图片，每行3张排列，每张图片各占200px。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">750px</span>;<br>    <span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> solid gray;<br>&#125;<br>// 默认<span class="hljs-number">3</span>张以上的样式（不包括<span class="hljs-number">4</span>张)<br><span class="hljs-selector-tag">div</span> <span class="hljs-selector-tag">img</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>    <span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> solid red;<br>&#125;<br>        <br>// 当只有一张图片的样式<br><span class="hljs-selector-tag">div</span> <span class="hljs-selector-tag">img</span><span class="hljs-selector-pseudo">:only-child</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">690px</span>;<br>    <span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> solid red;<br>&#125;<br>        <br>// 既是倒数第二张又是第一张说明有两张图片<br><span class="hljs-selector-tag">div</span> <span class="hljs-selector-tag">img</span><span class="hljs-selector-pseudo">:nth-last-child</span>(<span class="hljs-number">2</span>)<span class="hljs-selector-pseudo">:first</span>-child,<br>// ~表示同属于父类的所有<span class="hljs-selector-tag">img</span>兄弟元素<br><span class="hljs-selector-tag">img</span><span class="hljs-selector-pseudo">:nth-last-child</span>(<span class="hljs-number">2</span>)<span class="hljs-selector-pseudo">:first</span>-child~<span class="hljs-selector-tag">img</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">320px</span>;<br>    <span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> solid red;<br>&#125;<br>        <br>// 表示有四张图片<br><span class="hljs-selector-tag">div</span> <span class="hljs-selector-tag">img</span><span class="hljs-selector-pseudo">:nth-last-child</span>(<span class="hljs-number">4</span>)<span class="hljs-selector-pseudo">:first</span>-child,<br><span class="hljs-selector-tag">img</span><span class="hljs-selector-pseudo">:nth-last-child</span>(<span class="hljs-number">4</span>)<span class="hljs-selector-pseudo">:first</span>-child~<span class="hljs-selector-tag">img</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">320px</span>;<br>    <span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> solid red;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="十七、实现三角形"><a href="#十七、实现三角形" class="headerlink" title="十七、实现三角形"></a>十七、实现三角形</h1><p><strong>思路</strong>：盒子的高宽设为0，三角以哪个边为底，就设置这个边border的粗细、颜色、solid，其余的要么不设置，要么设置为transparent透明来挤出盒子的边。</p><ul><li>三角形</li></ul><img src="/2022/05/12/CSS/%E4%B8%89%E8%A7%92%E5%BD%A2.png" class=""><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#triangle-up</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">border-left</span>: <span class="hljs-number">50px</span> solid transparent;<br>    <span class="hljs-attribute">border-right</span>: <span class="hljs-number">50px</span> solid transparent;<br>    <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">100px</span> solid red;<br>&#125;<br><span class="hljs-selector-id">#triangle-down</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">border-left</span>: <span class="hljs-number">50px</span> solid transparent;<br>    <span class="hljs-attribute">border-right</span>: <span class="hljs-number">50px</span> solid transparent;<br>    <span class="hljs-attribute">border-top</span>: <span class="hljs-number">100px</span> solid red;<br>&#125;<br><span class="hljs-selector-id">#triangle-left</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">border-top</span>: <span class="hljs-number">50px</span> solid transparent;<br>    <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">50px</span> solid transparent;<br>    <span class="hljs-attribute">border-right</span>: <span class="hljs-number">100px</span> solid red;<br>&#125;<br><span class="hljs-selector-id">#triangle-right</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">border-top</span>: <span class="hljs-number">50px</span> solid transparent;<br>    <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">50px</span> solid transparent;<br>    <span class="hljs-attribute">border-left</span>: <span class="hljs-number">100px</span> solid red;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>直角三角形</li></ul><img src="/2022/05/12/CSS/%E7%9B%B4%E8%A7%92%E4%B8%89%E8%A7%92%E5%BD%A2.png" class=""><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#triangle-topleft</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">border-top</span>: <span class="hljs-number">100px</span> solid red;<br>    <span class="hljs-attribute">border-right</span>: <span class="hljs-number">100px</span> solid transparent;<br>&#125;<br><span class="hljs-selector-id">#triangle-topright</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">border-top</span>: <span class="hljs-number">100px</span> solid red;<br>    <span class="hljs-attribute">border-left</span>: <span class="hljs-number">100px</span> solid transparent;<br>&#125;<br><span class="hljs-selector-id">#triangle-bottomleft</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">100px</span> solid red;<br>    <span class="hljs-attribute">border-right</span>: <span class="hljs-number">100px</span> solid transparent;<br>&#125;<br><span class="hljs-selector-id">#triangle-bottomright</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">100px</span> solid red;<br>    <span class="hljs-attribute">border-left</span>: <span class="hljs-number">100px</span> solid transparent;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="十八、实现文本溢出显示省略号"><a href="#十八、实现文本溢出显示省略号" class="headerlink" title="十八、实现文本溢出显示省略号"></a>十八、实现文本溢出显示省略号</h1><h4 id="单行文本溢出显示省略号"><a href="#单行文本溢出显示省略号" class="headerlink" title="单行文本溢出显示省略号"></a>单行文本溢出显示省略号</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.txt</span> &#123;<br>    // 先强制一行内显示文本<br>    <span class="hljs-attribute">white-space</span>: nowrap;<br>    // 超出的部分隐藏<br>    <span class="hljs-attribute">overflow</span>: hidden;<br>    // 文字用省略号代替超出的部分<br>    <span class="hljs-attribute">text-overflow</span>: ellipsis;<br>&#125;   <br></code></pre></td></tr></table></figure><h4 id="多行文本溢出显示省略号"><a href="#多行文本溢出显示省略号" class="headerlink" title="多行文本溢出显示省略号"></a>多行文本溢出显示省略号</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.txt</span> &#123;<br>    <span class="hljs-attribute">overflow</span>: hidden;<br>    <span class="hljs-attribute">text-overflow</span>: ellipsis;<br>    // 弹性伸缩盒子模型显示<br>    <span class="hljs-attribute">display</span>: -webkit-box;<br>    // 限制在一个块元素显示的文本的行数<br>    -webkit-line-clamp: <span class="hljs-number">2</span>;<br>    // 设置或检索伸缩盒对象的子元素的排列方式<br>    -webkit-box-orient: vertical;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="十九、link与-import区别"><a href="#十九、link与-import区别" class="headerlink" title="十九、link与@import区别"></a>十九、link与@import区别</h1><ol><li>从属关系区别：@import是CSS方式，只有导入样式表的作用。link是html提供的标签，不仅可以加载CSS文件，还可以定义RSS、rel连接属性等。可通过rel&#x3D;”alternate stylesheet’指定候选样式。</li><li>加载顺序区别：link标签引入的CSS被同时加载，最大限度支持并行下载。@import引入的CSS将在页面加载完毕后被加载。</li><li>兼容性区别：@import是CSS2.1才有的语法，只有IE5+才能识别。link作为HTML元素，不存在兼容性问题。</li><li>DOM可控性区别：可以通过JS操作DOM，插入link标签来改变样式。由于DOM方法是基于文档的，无法使用@import的方式插入样式。</li><li>权重区别：link引入的样式权重大于@import引入的样式。link书写方式：&lt;link herf&#x3D;”style.css” rel&#x3D;”stylesheet” type&#x3D;”text&#x2F;css”&gt;</li></ol><h1 id="二十、2D转换与3D转换"><a href="#二十、2D转换与3D转换" class="headerlink" title="二十、2D转换与3D转换"></a>二十、2D转换与3D转换</h1><h4 id="2D转换"><a href="#2D转换" class="headerlink" title="2D转换"></a>2D转换</h4><p>改变标签在二维平面上的位置和形状的技术。向右x轴方向，向下y轴方向。<br>transform：转换，实现元素的位移、旋转、缩放等效果。各个操作有先后顺序，会影响变化效果。</p><ul><li>translate：位移，不会影响其它元素的位置，如果值是百分比是相对于自身元素，对行内元素没有效果。使用方法如下：<br>transform:translate(x,y)<br>transform:translateX(a)<br>transform:translateY(b)</li><li>rotate：单位deg（度），正值顺时针，负值逆时针，默认旋转中心为元素中心。使用方法如下：<br>transform:rotate(度数deg)<br>transform-origin: x y z：设置旋转中心点的位置，x和y也可以用方位名词和百分比值，z单位是em或px。</li><li>scale：实现2D缩放。x和y无单位时是原来的倍数，不会影响其它盒子，可以设置中心点，设置中心点的方法同上。使用方法如下：<br>transform:scale(x,y)</li><li>skew(x角度,y角度)：定义沿着x轴和Y轴的倾斜转换。如将正方形转换为平行四边形。</li><li>skewX(角度)、skewY(角度)：定义沿着X\Y轴的2D倾斜转换。</li><li>matrix()：矩阵变换，可接收6个参数，包括数学函数，实现旋转、缩放、平移和倾斜元素。如martix(scaleX(),skewY(),skewX(),scaleY(),translateX(),translateY()。<h4 id="3D转换"><a href="#3D转换" class="headerlink" title="3D转换"></a>3D转换</h4>近大远小，物体有前后遮挡。z轴垂直屏幕，往外正往内负。</li><li>translate3d：位移，z轴单位一般为px。用法类似2D。translate3d(x,y,z)、translateZ(c)</li><li>perspective属性：透视，网页产生3D效果需要使用透视。必须写在被观察元素的父盒子上，单位为px，表示观察元素的位置。数值越小元素越大。</li><li>rotateX：沿X轴顺时针旋转。左手准则，大拇指x轴方向，食指方向为旋转方向。</li><li>rotateY：沿Y轴顺时针旋转。左手大拇指y轴方向。</li><li>rotateZ：沿Z轴顺时针旋转。</li><li>rotated3D(x,y,z,a)：沿哪个轴转哪个就是1，否则为0。a是旋转角度，单位为deg。</li><li>scale：同上，scaleX(x)、scaleY(y)、scaleZ(z)、scale3d(x,y,z)</li><li>transform-style：3d呈现，控制子元素是否3D呈现。默认flat不开启3D空间，preserve-3d元素开启立体空间，写给要展示元素的父元素。</li></ul><h1 id="二十一、动画效果与过渡效果"><a href="#二十一、动画效果与过渡效果" class="headerlink" title="二十一、动画效果与过渡效果"></a>二十一、动画效果与过渡效果</h1><h4 id="动画效果"><a href="#动画效果" class="headerlink" title="动画效果"></a>动画效果</h4><p>可以实现自动连续播放等效果，先定义后使用。定义方法为</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@keyframes</span> 动画名称&#123;<br>    <span class="hljs-number">0%</span>(或者<span class="hljs-selector-tag">from</span>) &#123;<br>        初始样式<br>    &#125;<br>    <span class="hljs-number">100%</span>(或者<span class="hljs-selector-tag">to</span>) &#123;<br>        结束样式。<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用动画：直接在元素样式里面写属性animation-name:动画名称，animation-duration:动画持续时间。<br>可以设置多个关键帧，如0%、20%、40%<br><strong>动画属性</strong>：</p><ul><li>animation-function：规定动画运动曲线，默认ease（先变快后变慢），linear匀速，steps()步长，分多少步走完动画。</li><li>animation-delay：规定动画何时开始，默认是0.</li><li>animation-iteration-count：规定动画播放次数，默认1次，infinite无限次。</li><li>animation-direction：规定动画是否反方向播放，默认normal&#x2F;forwards，反方向alternate，both前面两个状态轮流使用。</li><li>animation-fill-mode：规定动画结束状态。默认backwards回到起始状态，forwards停留在结束状态。</li><li>animation-play-state：播放状态。running默认播放动画，paused暂停动画。</li><li>animation：动画名称、持续时间、运动曲线、何时开始…….（简写，动画名称和持续时间必须写）<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@keyframes</span> move &#123;<br>    <span class="hljs-number">0%</span> &#123;<br>    &#125;<br>    <span class="hljs-number">100%</span> &#123;<br>        <span class="hljs-attribute">width</span>:<span class="hljs-number">200px</span>;<br>    &#125;<br>&#125;<br><span class="hljs-selector-tag">div</span> &#123;<br>    <span class="hljs-attribute">width</span>:<span class="hljs-number">100px</span><br>    height: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">animation-name</span>: move;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="过渡效果"><a href="#过渡效果" class="headerlink" title="过渡效果"></a>过渡效果</h4>transition过渡允许CSS的属性值在一段时间内平滑过渡。这种效果可以在<strong>鼠标单击、获得焦点、被点击或元素发生任何改变时触发</strong>，以动画效果改变CSS的属性值。写在变化前元素的属性中，包括如下四个属性（可以直接在transition里简写，多个过渡效果用逗号隔开）：</li><li>transition-property：指定当元素改变其中一个属性时的过渡效果。none默认值，没有属性会获得过渡效果；all默认值，所有属性都获得过渡效果；property定义应用过渡效果的CSS属性名称列表，以逗号分隔。</li><li>transition-duration：指定元素过渡所需时间，单位为秒或者毫秒，默认值为0。</li><li>transition-timeing-function：指定元素变化曲线，即元素变换速率的变化。linear以相同速度从开始到结束进行过渡；ease默认值，慢速开始，逐渐变快，再逐渐变慢结束的过渡效果；ease-in以慢速开始的过渡效果；ease-out以慢速结束的过渡效果；ease-in-out以慢速开始和结束的过渡效果；cublic-bezier（n，n，n，n）在函数中设置四个-1~1的值定义过渡变化速度。</li><li>transition-delay：指定过渡开始执行的时间，即延迟时间。单位为秒或毫秒，默认为0。<br><strong>注意事项</strong></li></ul><ol><li>不是所有的CSS属性都支持transition。 </li><li>transition需要明确知道开始状态和结束状态的具体数值，才能计算出中间状态。比如，无法计算0px到auto的中间状态，如果设置为auto就不会产生过渡动画效果。</li><li>transition需要事件触发，无法在网页加载时自动发生。</li><li>transition是一次性的，不能重复发生，除非再次触发。</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">background</span>: red;<br>    <span class="hljs-attribute">transition</span>: width <span class="hljs-number">2s</span>, height: <span class="hljs-number">4s</span>;<br>&#125;<br><span class="hljs-selector-tag">div</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="二十二、移动端（流式布局、flex弹性布局）"><a href="#二十二、移动端（流式布局、flex弹性布局）" class="headerlink" title="二十二、移动端（流式布局、flex弹性布局）"></a>二十二、移动端（流式布局、flex弹性布局）</h1><p><strong>单独制作移动端页面（主流）</strong>：网址域名前加m一般可以打开移动端页面，通过判断设备，如果是是移动设备打开，则跳转到移动端界面。包括：流式布局（百分比布局）、flex弹性布局<br><strong>响应式页面兼容移动端（其次）</strong>：通过判断屏幕宽度来改变样式，比较麻烦，需要解决兼容性问题。</p><h4 id="流式布局"><a href="#流式布局" class="headerlink" title="流式布局"></a>流式布局</h4><p>通过设置盒子的宽度的百分比来根据屏幕的宽度进行伸缩，不受固定像素的限制。<br>可以设置盒子宽度的最大最小值：max-width、min-width。</p><h4 id="flex弹性布局"><a href="#flex弹性布局" class="headerlink" title="flex弹性布局"></a>flex弹性布局</h4><p>又称为伸缩布局、伸缩盒布局、弹性盒布局。<br>任何一个容器都可以指定为flex布局。方式为：<br>display:flex<br>行内元素也可以使用flex布局。<strong>父元素设置flex布局后子元素的float、clear和vertical-align属性将失效。</strong><br>设置了flex的元素称为容器，它的所有子元素自动成为容器成员，称为容器项目。<br>容器默认存在两根轴：水平的主轴和垂直的交叉轴。主轴的开始位置叫做main start，结束位置叫做main end，交叉轴开始位置叫做cross start，结束位置叫corss end。项目默认沿主轴排列，单个项目占据的主轴空间叫main size，占据的交叉轴空间称为cross size。<br><strong>容器的属性</strong>：</p><ul><li>flex-direction：决定主轴的方向。row默认，主轴为水平方向，起点在左端；row-reverse主轴为水平方向，起点在右端。column主轴为垂直方向，起点在上端；column-reverse主轴为垂直方向，起点在下侧。</li><li>flex-wrap：设置子元素是否换行。nowrap默认不换行，如果装不开会缩小子元素宽度；wrap换行，第一行在上方；wrap-reverse换行，第一行在下方。</li><li>flex-flow：是flex-direction和flex-wrap属性的简写形式，默认值为row nowrap。</li><li>justify-content：设置主轴子元素的排列。flex-start默认值从头开始；flex-end从尾部开始；center主轴居中对其；space-around平分剩余空间；space-between两端对齐，先贴两边再平分剩余空间。</li><li>align-items：设置侧轴子元素的排列（单行）。flex-start从上到下；flex-end从下到上；center垂直居中；stretch默认值，如果项目未设置高度或者设置为auto，则进行拉伸，占满整个容器。</li><li>align-content：设置侧轴子元素的排列（多行），适用于换行情况。flex-start从上到下；flex-end从下到上；center垂直居中；stretch默认值拉伸；space-around项目在侧轴上平分剩余空间；space-between子项先在侧轴两侧对齐，再平分剩余空间。<br><strong>项目的属性</strong></li><li>order：数字，定义项目的排列顺序，数越小越靠前，默认为0。</li><li>flex：定义在剩余空间中子项占多少份。可以简写为flex-grow、flex-shrink、flex-basis。</li><li>flex-grow：定义项目的放大比例，默认为0，即如果存在剩余空间也不放大。（为0的先分空间，其余的按比例分剩余所有空间）</li><li>flex-shrink：定义项目的缩小比例，默认为1，即如果空间不足，该项目将缩小（设置为1的空间不足一起缩小）</li><li>flex-basis：定义了在分配多余空间之前，项目占据的主轴空间。浏览器根据这个属性，计算主轴是否有多余空间，它的默认值为auto，即项目本来大小。如果设置了会覆盖width属性。</li><li>align-self：控制子项在自己侧轴的排列方式，允许单个项目对齐方式与其它项目不同。可以覆盖align-items属性，默认值为auto，表示继承父元素的align-items属性，如果没有父元素则等同于stretch。</li></ul><h4 id="rem适配布局"><a href="#rem适配布局" class="headerlink" title="rem适配布局"></a>rem适配布局</h4><p>rem是相对于html元素字体大小来说的，可以通过修改html里面的文字大小来改变页面中元素的大小达到整体控制。<br>根据设备宽高不同，内部内容等比例发生变化，文字的缩放比例和屏幕缩放比例最好一样。<br>使用方法是设置初始html的font-size，后面设置的每个内容长度都用它除来转化，例如70rem&#x2F;50.</p><h4 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h4><p>针对不同的屏幕尺寸设置不同的样式。</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs elm">@media media<span class="hljs-keyword">type</span> and|not|only (media feature)&#123;<br>    <span class="hljs-type">CSS</span>-code;<br>&#125;<br></code></pre></td></tr></table></figure><p>mediatype：媒体类型。all用于所有设备、print用于打印机和打印预览、screen用于电脑屏幕、平板电脑、智能手机等。<br>and、only、not：关键字，and用于将多个媒体特性连接到一起(必须）、not排除某个媒体类型、only指定某个特定的媒体类型。<br>媒体特性：width定义输出设备中页面可见区域的宽度、min-width最小可见区域、max-width最大可见区域。</p><h4 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a>响应式布局</h4><p>响应不同的设备显示发生变化，使用媒体查询针对不同宽度的设备进行布局和样式的设置，从而适配不同设备的目的。<br>需要一个父级容器，来配合子元素实现变化效果。在不同屏幕下通过媒体查询来改变布局容器的大小，再改变里面子元素的排列方式和大小，从而实现不同屏幕下看到不同的页面布局和样式变化。</p><img src="/2022/05/12/CSS/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B0%BA%E5%AF%B8%E5%88%92%E5%88%86.png" class=""><p><strong>使用@media的三种方式</strong>：</p><ol><li>直接在CSS文件中使用<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">max-width</span>:<span class="hljs-number">980px</span>)&#123;<br>    <span class="hljs-selector-tag">body</span>&#123;<br>        <span class="hljs-attribute">background-color</span>: red;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>使用@import导入。<br>@import url(“css&#x2F;movie.css”) all and  (max-width:980px);</li><li>使用link连接，media属性用于设置查询方式。<br>&lt;link rel&#x3D;”stylesheet” type&#x3D;”text&#x2F;css” href&#x3D;”css&#x2F;index.css” media&#x3D;”all and (max-width&#x3D;980px)” &#x2F;&gt;</li></ol><h1 id="二十三、CSS3新特性"><a href="#二十三、CSS3新特性" class="headerlink" title="二十三、CSS3新特性"></a>二十三、CSS3新特性</h1><ul><li>CSS3实现了圆角border-radius、阴影box-shadow</li><li>对文字增加了特效text-shadow、线性渐变gradient、变换transform。</li><li>transform：rotate旋转、translate平移、scale缩放、skew倾斜</li><li>transition：property过渡属性名称、duration完成过渡需要的时间、timing-function过渡函数、delay延迟时间。</li></ul><h1 id="二十四、实现两栏布局"><a href="#二十四、实现两栏布局" class="headerlink" title="二十四、实现两栏布局"></a>二十四、实现两栏布局</h1><h4 id="左固定宽-右自适应宽"><a href="#左固定宽-右自适应宽" class="headerlink" title="左固定宽+右自适应宽"></a>左固定宽+右自适应宽</h4><ul><li><p><strong>方法一：左侧float:left 右侧margin-left</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span>&#123;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-selector-class">.left</span>,<br><span class="hljs-selector-class">.right</span>&#123;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;<br>&#125;<br><span class="hljs-selector-class">.left</span>&#123;<br>    <span class="hljs-attribute">float</span>: left;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>    <span class="hljs-attribute">background</span>: red;<br>&#125;<br><span class="hljs-selector-class">.right</span>&#123;<br>    <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">200px</span>;<br>    <span class="hljs-attribute">background</span>: green;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>方法二：左侧float:left 右侧overflow:hidden</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span>&#123;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-selector-class">.left</span>,<br><span class="hljs-selector-class">.right</span>&#123;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;<br>&#125;<br><span class="hljs-selector-class">.left</span>&#123;<br>    <span class="hljs-attribute">float</span>: left;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>    <span class="hljs-attribute">background</span>: red;<br>&#125;<br><span class="hljs-selector-class">.right</span>&#123;<br>    <span class="hljs-attribute">overflow</span>: hidden;<br>    <span class="hljs-attribute">background</span>: green;<br>&#125;<br></code></pre></td></tr></table></figure><p>右盒子设置的overflow: hidden会触发块级格式上下文BFC。具有BFC特性的元素不会在布局上影响外面的元素，并且BFC具有普通元素没有的特性，如下边距不发生折叠、可以清除浮动、可以阻止元素被覆盖。正因为有了这些特性，所以右边盒子可以使用触发BFC的元素来清除左边浮动的影响。<br>触发了BFC的元素任然保持流体特性，也就是说BFC元素虽然不与浮动交集，自动退避浮动元素宽度的距离，但本身作为普通元素的流体特性依然存在，反应在布局上就是自动填满除去浮动内容以外的剩余空间。<br><strong>注意</strong>：如果右边宽度固定，左边宽度自适应，那么html结构应该调整为.right的div写在.left的div上方；如果.right写在下方，.left元素不会脱离标准文档流，right会自称一行，达不到想要的效果。</p></li><li><p><strong>方法三：绝对定位</strong><br>通过设置right: 0来限制右边块级元素的高度。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.wrap</span>&#123;<br>    <span class="hljs-attribute">position</span>: relative;<br>&#125;<br><span class="hljs-selector-class">.left</span>&#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>&#125;<br><span class="hljs-selector-class">.right</span>&#123;<br>    <span class="hljs-attribute">position</span>: absolute;<br>    <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">left</span>: <span class="hljs-number">200px</span>;<br>    <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>方法四：弹性布局</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span>&#123;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-selector-class">.wrap</span>&#123;<br>    <span class="hljs-attribute">display</span>: flex;<br>&#125;<br><span class="hljs-selector-class">.left</span>,<br><span class="hljs-selector-class">.right</span>&#123;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;<br>&#125;<br><span class="hljs-selector-class">.left</span>&#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>    <span class="hljs-attribute">background</span>: red;<br>&#125;<br><span class="hljs-selector-class">.right</span>&#123;<br>    <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;<br>    <span class="hljs-attribute">background</span>: green;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="左不定宽-右自适应"><a href="#左不定宽-右自适应" class="headerlink" title="左不定宽+右自适应"></a>左不定宽+右自适应</h4></li><li><p><strong>方法一：左侧float:left 右侧overflow:hidden</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span>&#123;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-selector-class">.left</span>,<br><span class="hljs-selector-class">.right</span>&#123;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;<br>&#125;<br><span class="hljs-selector-class">.left</span>&#123;<br>    <span class="hljs-attribute">float</span>: left;<br>    <span class="hljs-attribute">background</span>: red;<br>&#125;<br><span class="hljs-selector-class">.right</span>&#123;<br>    <span class="hljs-attribute">overflow</span>: hidden;<br>    <span class="hljs-attribute">background</span>: green;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>方法二：弹性布局</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span>&#123;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-selector-class">.wrap</span>&#123;<br>    <span class="hljs-attribute">display</span>: flex;<br>&#125;<br><span class="hljs-selector-class">.left</span>,<br><span class="hljs-selector-class">.right</span>&#123;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;<br>&#125;<br><span class="hljs-selector-class">.left</span>&#123;<br>    <span class="hljs-attribute">background</span>: red;<br>&#125;<br><span class="hljs-selector-class">.right</span>&#123;<br>    <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;<br>    <span class="hljs-attribute">background</span>: green;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="二十五、实现三栏布局"><a href="#二十五、实现三栏布局" class="headerlink" title="二十五、实现三栏布局"></a>二十五、实现三栏布局</h1><h4 id="两边宽度固定，中间自适应"><a href="#两边宽度固定，中间自适应" class="headerlink" title="两边宽度固定，中间自适应"></a>两边宽度固定，中间自适应</h4><ul><li><strong>方法一：绝对定位法</strong><br>将左右两边使用absolute定位，使其脱离文档流，后面的center会自动流动到他们上面。然后使用margin属性，留出左右元素的宽度，既可以使中间元素自适应平面宽度。<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span>&#123;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-selector-class">.wrap</span>&#123;<br>    <span class="hljs-attribute">position</span>: relative;<br>&#125;<br><span class="hljs-selector-class">.left</span>,<br><span class="hljs-selector-class">.right</span>&#123;<br>    <span class="hljs-attribute">position</span>: absolute;<br>    <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;<br>    <span class="hljs-attribute">background</span>: red;<br>&#125;<br><span class="hljs-selector-class">.left</span>&#123;<br>    <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-selector-class">.right</span>&#123;<br>    <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-selector-class">.center</span>&#123;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">2px</span> <span class="hljs-number">200px</span>;<br>    <span class="hljs-attribute">background</span>: green;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><strong>方法二：自身浮动法</strong><br>对左右盒子分别使用float:left和float:right，使得左右两个盒子脱离文档流，中间元素正常显示在文档流中，使用margin指定左右外边距对其进行定位。<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span>&#123;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-selector-class">.left</span>,<br><span class="hljs-selector-class">.right</span>&#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;<br>    <span class="hljs-attribute">background</span>: red;<br>&#125;<br><span class="hljs-selector-class">.left</span>&#123;<br>    <span class="hljs-attribute">float</span>: left;<br>&#125;<br><span class="hljs-selector-class">.right</span>&#123;<br>    <span class="hljs-attribute">float</span>: right;<br>&#125;<br><span class="hljs-selector-class">.center</span>&#123;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> <span class="hljs-number">200px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;<br>    <span class="hljs-attribute">background</span>: green;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><strong>方法三：圣杯布局</strong><br>原理是margin负值法。使用圣杯布局首先需要在center元素外面包含一个div，包含div需要设置float属性使其成为一个BFC，并设置宽度，且这个宽度要和left块的margin负值进行配合。<br>为了使得中间内容先加载，所以中间盒子标签要先加载，左侧盒子就挪到下面去了，为了使其在同一行必须使用margin-left。<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">        <span class="hljs-selector-class">.wrap</span>&#123;</span><br><span class="language-css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;</span><br><span class="language-css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">background</span>: white;</span><br><span class="language-css">            <span class="hljs-attribute">float</span>: left;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">        <span class="hljs-selector-class">.wrap</span> <span class="hljs-selector-class">.center</span>&#123;</span><br><span class="language-css">            <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> <span class="hljs-number">200px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">background</span>: red;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">        <span class="hljs-selector-class">.left</span>,</span><br><span class="language-css">        <span class="hljs-selector-class">.right</span>&#123;</span><br><span class="language-css">            <span class="hljs-attribute">float</span>: left;</span><br><span class="language-css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">background</span>: green;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">        <span class="hljs-selector-class">.left</span>&#123;</span><br><span class="language-css">            <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">100%</span>;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">        <span class="hljs-selector-class">.right</span>&#123;</span><br><span class="language-css">            <span class="hljs-attribute">margin-right</span>: -<span class="hljs-number">200px</span>;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;wrap&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><strong>方法四：飞翼布局</strong><br>飞翼布局类似于圣杯布局，只是少了relative与left、right的步骤和共同的父元素，主内容元素多了层父元素。<br>实现方式：<br>两栏和自适应元素都设置统一方向的浮动。<br>main元素设置左右margin值，值为左右两栏的宽度。main父元素设置宽度为100%。<br>左边栏margin-left为负100%，右边栏margin-left为负自身宽度。<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">        <span class="hljs-selector-class">.wrap</span>&#123;</span><br><span class="language-css">            <span class="hljs-attribute">float</span>: left;</span><br><span class="language-css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span></span><br><span class="language-css">            overflow: hidden:</span><br><span class="language-css">            clear: both;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">        <span class="hljs-selector-class">.left</span>,</span><br><span class="language-css">        <span class="hljs-selector-class">.right</span>&#123;</span><br><span class="language-css">            <span class="hljs-attribute">float</span>: left;</span><br><span class="language-css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">background</span>: green;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">        <span class="hljs-selector-class">.center</span>&#123;</span><br><span class="language-css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> <span class="hljs-number">200px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">background</span>: red;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">        <span class="hljs-selector-class">.left</span>&#123;</span><br><span class="language-css">            <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">100%</span></span><br><span class="language-css">        &#125;</span><br><span class="language-css">        <span class="hljs-selector-class">.right</span>&#123;</span><br><span class="language-css">            <span class="hljs-attribute">margin-right</span>: -<span class="hljs-number">200px</span>;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;wrap&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><strong>方法五：flex布局</strong><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.content</span>&#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">80%</span>;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;<br>    <span class="hljs-attribute">display</span>: flex;<br>&#125;<br><span class="hljs-selector-class">.left</span>&#123;<br>    <span class="hljs-attribute">flex</span>: <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">300px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;<br>    <span class="hljs-attribute">background</span>: red;<br>&#125;<br><span class="hljs-selector-class">.right</span>&#123;<br>    <span class="hljs-attribute">flex</span>: <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">300px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;<br>    <span class="hljs-attribute">background</span>: red;<br>&#125;<br><span class="hljs-selector-class">.center</span>&#123;<br>    <span class="hljs-attribute">flex-grow</span>: <span class="hljs-number">1</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;<br>    <span class="hljs-attribute">background</span>: green;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="二十六、BFC格式化上下文"><a href="#二十六、BFC格式化上下文" class="headerlink" title="二十六、BFC格式化上下文"></a>二十六、BFC格式化上下文</h1>BFC（Block Formatting Context）格式化上下文是web页面中盒模型布局的css渲染模式，指一个独立的渲染区域或者说是一个隔离的独立容器。<h4 id="形成BFC的条件（任一）"><a href="#形成BFC的条件（任一）" class="headerlink" title="形成BFC的条件（任一）"></a>形成BFC的条件（任一）</h4></li></ul><ol><li>浮动元素，float除none之外的值。</li><li>定位元素，position的absolute、fixed。</li><li>display为其中之一：inline-block、table-cell、table-caption、flex、inline-flex。</li><li>overflow除了visible之外的值：hidden、auto、scroll。<h4 id="BFC的特性"><a href="#BFC的特性" class="headerlink" title="BFC的特性"></a>BFC的特性</h4></li><li>内部的Box会在垂直方向上一个接一个的放置。</li><li>盒子垂直方向的距离由margin决定，同属一个bfc的盒子的margin会重叠（比如，上一个盒子有下边距，下一个盒子有上边距，两个盒子之间的距离实际为边距的最大值）</li><li>bfc的区域不会与float的元素区域重叠。</li><li>计算bfc的高度时，浮动元素也参与计算（bfc会清除浮动，bfc的高度也会参考内部浮动元素的高度）</li><li>bfc是页面上一个独立容器，它内部元素产生的布局不会影响外部元素，外部元素的布局也不会影响到bfc中的内部元素。一个bfc就像是一个隔离区域，和其它区域互不影响。</li></ol><h1 id="★二十七、实现水平-x2F-垂直居中"><a href="#★二十七、实现水平-x2F-垂直居中" class="headerlink" title="★二十七、实现水平&#x2F;垂直居中"></a>★二十七、实现水平&#x2F;垂直居中</h1><h4 id="一、水平居中"><a href="#一、水平居中" class="headerlink" title="一、水平居中"></a>一、水平居中</h4><p><strong>行内元素</strong>：自身不具备宽度和高度，设置高度和宽度不起作用，由自身内容来撑大。比如a、b（加粗）、strong（强调）、i、span、img、input、select，给父级元素设置<strong>text-align:center</strong>。<br><strong>块级-宽高固定</strong>：块级元素（div、p、ul、li、ol、h1~h6、dl、dt、dd、address、article、figure、audio、video、section、table、canvas、header、footer）独自占据一行，支持高度和宽度。<br>当固定宽高时：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;parent&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;child&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-class">.parent</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">    <span class="hljs-selector-class">.child</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">    &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><p>实现以下效果：</p><img src="/2022/05/12/CSS/%E5%9D%97%E7%BA%A7-%E5%AE%BD%E9%AB%98%E5%9B%BA%E5%AE%9A.png" class=""><ul><li>方法一：margin: 0 auto<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;style&gt;<br>    <span class="hljs-selector-class">.child</span>&#123;<br>        <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;<br>    &#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure></li><li>方法二：absolute + margin-left<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;style&gt;<br>    <span class="hljs-selector-class">.parent</span>&#123;<br>        <span class="hljs-attribute">position</span>: relative;<br>    &#125;<br>    <span class="hljs-selector-class">.child</span>&#123;<br>        <span class="hljs-attribute">position</span>: absolute;<br>        <span class="hljs-attribute">margin-left</span>:  -<span class="hljs-number">50px</span>;<br>        <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;<br>    &#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure></li><li>方法三：absolute + calc<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;style&gt;<br>    <span class="hljs-selector-class">.parent</span>&#123;<br>        <span class="hljs-attribute">position</span>: relative;<br>    &#125;<br>    <span class="hljs-selector-class">.child</span>&#123;<br>        <span class="hljs-attribute">position</span>: absolute;<br>        <span class="hljs-attribute">left</span>: <span class="hljs-built_in">calc</span>(<span class="hljs-number">50%</span> - <span class="hljs-number">50px</span>);<br>    &#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure></li><li>方法四：absolute + left + right + margin-left</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;style&gt;<br>    <span class="hljs-selector-class">.parent</span>&#123;<br>        <span class="hljs-attribute">position</span>: relative;<br>    &#125;<br>    <span class="hljs-selector-class">.child</span>&#123;<br>        <span class="hljs-attribute">position</span>: absolute;<br>        <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;<br>        <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;<br>        <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;<br>    &#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><p><strong>块级-宽高不定</strong>：当宽高不定时，测试用例如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;parent&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;child&quot;</span>&gt;</span>测试示例<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">  <span class="hljs-selector-class">.parent</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">  &#125;</span><br><span class="language-css">    <span class="hljs-selector-class">.child</span> &#123;</span><br><span class="language-css">  &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><p>显示效果为：</p><img src="/2022/05/12/CSS/%E5%9D%97%E7%BA%A7-%E5%AE%BD%E9%AB%98%E4%B8%8D%E5%AE%9A.png" class=""><ul><li><p>方法一：transform属性</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;style&gt;<br>    <span class="hljs-selector-class">.child</span>&#123;<br>        <span class="hljs-attribute">position</span>: aboslute;<br>        <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;<br>        <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(-<span class="hljs-number">50%</span>);<br>    &#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure></li><li><p>方法二：flex布局（justify-content设置主轴横轴对齐方式）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;style&gt;<br>    <span class="hljs-selector-class">.parent</span>&#123;<br>        <span class="hljs-attribute">display</span>: flex;<br>        <span class="hljs-attribute">justify-content</span>: center;<br>    &#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><p>显示效果为：</p><img src="/2022/05/12/CSS/%E5%9D%97%E7%BA%A7-%E5%AE%BD%E9%AB%98%E4%B8%8D%E5%AE%9A2.png" class=""></li><li><p>方法一：width: fit-content</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;style&gt;<br>  <span class="hljs-selector-class">.child</span> &#123;<br>    &lt;!--盒子正好等于内容宽度--&gt;<br>    <span class="hljs-attribute">width</span>: fit-content;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;<br>  &#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><p>fit-content是css3中给width属性新增的一个属性值，它配合margin可以实现水平居中。</p></li></ul><h4 id="二、垂直居中"><a href="#二、垂直居中" class="headerlink" title="二、垂直居中"></a>二、垂直居中</h4><h5 id="行内元素"><a href="#行内元素" class="headerlink" title="行内元素"></a>行内元素</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;parent&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;child&quot;</span>&gt;</span>测试示例<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-class">.parent</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">text-align</span>: center;</span><br><span class="language-css">    &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li><p><strong>line-heigh(单行文本)</strong>:行高等于外盒高。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-class">.child</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">line-height</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">    &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><p>实现效果为：</p><img src="/2022/05/12/CSS/%E5%8D%95%E8%A1%8C%E6%96%87%E6%9C%AC.png" class=""></li><li><p><strong>多行文本</strong>会样式错乱，需要用到vertical-align：middle布局。<br><strong>display:table-cell + vertical-align(多行文本)</strong>:<br>可用vertical-align属性，而该属性只有在父元素为td或th时才会生效，对于其它块级元素默认不支持。为了使用vertical-align，需要设置父元素display：table，子元素display：table-cell；vertical-align：middle。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-class">.parent</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">display</span>: table;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">    <span class="hljs-selector-class">.child</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">display</span>: table-cell;</span><br><span class="language-css">        <span class="hljs-attribute">vertical-align</span>: middle;</span><br><span class="language-css">    &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><p>实现效果为：</p><img src="/2022/05/12/CSS/%E5%A4%9A%E8%A1%8C%E6%96%87%E6%9C%AC.png" class=""></li><li><p><strong>display: grid布局</strong>：网格布局，给父元素设置。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-class">.parent</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">display</span>: grid;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">    <span class="hljs-selector-class">.child</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">margin</span>: auto;</span><br><span class="language-css">    &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><p>实现效果为：</p><img src="/2022/05/12/CSS/%E5%A4%9A%E8%A1%8C%E6%96%87%E6%9C%AC.png" class=""></li><li><p><strong>display：inline-block + vertical-align</strong>：隐式幽灵节点<br>设置幽灵节点的高度以及幽灵节点的基线（通过line-height），来设置幽灵节点的x-height，是span的中线与幽灵节点的中线对齐，同样也可以使vertical-align：middle居中。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-class">.parent</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">line-height</span>: <span class="hljs-number">100px</span>; <span class="hljs-comment">/* 通过line-heigh设置幽灵节点的基线 */</span></span><br><span class="language-css">    &#125;</span><br><span class="language-css">    <span class="hljs-selector-class">.child</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">vertical-align</span>: middle;</span><br><span class="language-css">        <span class="hljs-attribute">line-height</span>: normal; <span class="hljs-comment">/* 块级元素时需要添加 */</span></span><br><span class="language-css">        <span class="hljs-attribute">display</span>: inline-block; <span class="hljs-comment">/* 把line-height设置成normal，否则会继承100px */</span></span><br><span class="language-css">    &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>writing-mode布局</strong>：<br>writing-mode属性定义了文本在水平或垂直方向上如何排布。</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-class">.parent</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">writing-mode</span>: vertical-lr; <span class="hljs-comment">/* 垂直方向内容从上到下，水平方向从左到右 */</span></span><br><span class="language-css">        <span class="hljs-attribute">text-align</span>: center;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">    <span class="hljs-selector-class">.child</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">writing-mode</span>: horizontal-tb;</span><br><span class="language-css">    &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="块级元素"><a href="#块级元素" class="headerlink" title="块级元素"></a>块级元素</h5><p><strong>宽高固定</strong>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;parent&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;child&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">      <span class="hljs-selector-tag">body</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">background-color</span>: aqua;</span><br><span class="language-css">      &#125;</span><br><span class="language-css">      <span class="hljs-selector-class">.child</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">50px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">50px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">background-color</span>: blueviolet;</span><br><span class="language-css">      &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li><strong>方法一：absolute+margin_top</strong>：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-class">.parent</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">position</span>: relative;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">    <span class="hljs-selector-class">.child</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">position</span>: absolute;</span><br><span class="language-css">        <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">25px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;</span><br><span class="language-css">        <span class="hljs-attribute">margin-top</span>: -<span class="hljs-number">25px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;</span><br><span class="language-css">    &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><strong>方法二：absolute+calc</strong>：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-class">.parent</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">position</span>: relative;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">    <span class="hljs-selector-class">.child</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">position</span>: absolute;</span><br><span class="language-css">        <span class="hljs-attribute">left</span>: <span class="hljs-built_in">calc</span>(<span class="hljs-number">50%</span>-<span class="hljs-number">25px</span>);</span><br><span class="language-css">        <span class="hljs-attribute">top</span>: <span class="hljs-built_in">calc</span>(<span class="hljs-number">50%</span>-<span class="hljs-number">25px</span>);</span><br><span class="language-css">    &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><strong>方法三：absolute+left+right+top+bottom</strong><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-class">.parent</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">position</span>: relative;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">    <span class="hljs-selector-class">.child</span>&#123;</span><br><span class="language-css">        positon: absolute;</span><br><span class="language-css">        <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">        <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">        <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">        <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">        <span class="hljs-attribute">margin</span>: auto;</span><br><span class="language-css">    &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><strong>宽高不定</strong>：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;parent&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;child&quot;</span>&gt;</span>测试示例<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">      <span class="hljs-selector-class">.parent</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">background-color</span>: aqua;</span><br><span class="language-css">      &#125;</span><br><span class="language-css">      <span class="hljs-selector-class">.child</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">background-color</span>: blueviolet;</span><br><span class="language-css">      &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><strong>方法一：transform</strong>：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-class">.parent</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">position</span>: relative;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">    <span class="hljs-selector-class">.child</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">position</span>: absolute;</span><br><span class="language-css">        <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;</span><br><span class="language-css">        <span class="hljs-attribute">top</span>: <span class="hljs-number">50px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(-<span class="hljs-number">50%</span>,-<span class="hljs-number">50%</span>);</span><br><span class="language-css">    &#125;</span><br><span class="language-css"> </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><strong>方法二：flex布局</strong>：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-class">.parent</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">display</span>: flex;</span><br><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;</span><br><span class="language-css">        <span class="hljs-attribute">justify-content</span>: center; <span class="hljs-comment">/* 主轴水平居中 */</span></span><br><span class="language-css">        <span class="hljs-attribute">align-items</span>: center; <span class="hljs-comment">/* 侧轴垂直居中 */</span></span><br><span class="language-css">    &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><h1 id="二十八、实现底部对齐"><a href="#二十八、实现底部对齐" class="headerlink" title="二十八、实现底部对齐"></a>二十八、实现底部对齐</h1><ul><li>方法一：使用table-cell+vertical-align实现。<br>实现效果：</li></ul><img src="/2022/05/12/CSS/%E5%BA%95%E9%83%A8%E5%AF%B9%E9%BD%90.png" class=""><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;top&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;top-container&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>我是第一个li元素<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>我是第二个li元素<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>我是第三个li元素<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>我是第四个li元素<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>我是第五个li元素<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;bottom&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>我是第一个li元素<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>我是第二个li元素<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>我是第三个li元素<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>我是第四个li元素<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>我是第五个li元素<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    *&#123;</span><br><span class="language-css">        <span class="hljs-attribute">margin</span>:<span class="hljs-number">0</span>;</span><br><span class="language-css">        <span class="hljs-attribute">padding</span>:<span class="hljs-number">0</span>;</span><br><span class="language-css">        <span class="hljs-attribute">box-sizing</span>: border-box;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">    <span class="hljs-selector-class">.container</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">position</span>: relative;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">500px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">margin</span>: <span class="hljs-number">10px</span> auto;</span><br><span class="language-css">        <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#f60</span>;</span><br><span class="language-css">        <span class="hljs-attribute">color</span>: <span class="hljs-number">#fff</span>;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">    <span class="hljs-selector-class">.top</span>,</span><br><span class="language-css">    <span class="hljs-selector-class">.bottom</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">50%</span>;</span><br><span class="language-css">        <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">overflow</span>: auto;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">    <span class="hljs-selector-class">.top</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#da2e22</span>;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">    <span class="hljs-selector-class">.top-container</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">display</span>: table;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;</span><br><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">    <span class="hljs-selector-class">.top-container</span>&gt;<span class="hljs-selector-tag">ul</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">display</span>: table-cell;</span><br><span class="language-css">        <span class="hljs-attribute">vertical-align</span>: bottom;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;</span><br><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">    <span class="hljs-selector-class">.bottom</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#1e1e1e</span>;</span><br><span class="language-css">    &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>方法二：设置文字所在盒子，例如p。为：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-tag">p</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">position</span>: absolute;</span><br><span class="language-css">        <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">    &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="二十九、实现瀑布流"><a href="#二十九、实现瀑布流" class="headerlink" title="二十九、实现瀑布流"></a>二十九、实现瀑布流</h1><ul><li><p>方法一：使用column属性。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;waterfalls&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;pic&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;1.jpg&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;pic&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;1.jpg&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;pic&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;1.jpg&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    *&#123;</span><br><span class="language-css">        <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">        <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">    <span class="hljs-selector-class">.waterfalls</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">position</span>: relative;</span><br><span class="language-css">        <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;</span><br><span class="language-css">        <span class="hljs-attribute">columns</span>: <span class="hljs-number">200px</span>; <span class="hljs-comment">/* 每列每个元素的最小宽度，或者设置column-count列数 */</span></span><br><span class="language-css">        <span class="hljs-attribute">column-gap</span>: <span class="hljs-number">20px</span>; <span class="hljs-comment">/* 每列的距离 */</span></span><br><span class="language-css">    &#125;</span><br><span class="language-css">    <span class="hljs-selector-class">.box</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">break-inside</span>: avoid; <span class="hljs-comment">/* 设置多列布局下的内容盒子如何中断，配合columns使用。不加的话每列头个元素就不会置顶 */</span></span><br><span class="language-css">        <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">15px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">color</span>: white;</span><br><span class="language-css">        <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">5px</span>;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">    <span class="hljs-selector-class">.pic</span> <span class="hljs-selector-tag">img</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>; <span class="hljs-comment">/* 不设置宽高容易溢出外层盒子 */</span></span><br><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;</span><br><span class="language-css">        <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">5px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#ccc</span>;</span><br><span class="language-css">        <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">10px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0.2</span>);</span><br><span class="language-css">    &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><p>不加break-inside:avoid就是每列元素不置顶。<br>实现效果：</p><img src="/2022/05/12/CSS/%E7%80%91%E5%B8%83%E6%B5%811.png" class=""><p><strong>优点</strong>：简单，只需要给父盒子设置column和column-gap。列数不会随着浏览器的宽度而改变。<br><strong>缺点</strong>：图片位置按照从上往下排序，如果需要动态加载图片，新加入的图片不会加入页面的最低端。</p></li><li><p>方法二：使用flex布局。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;con&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../img/1.jpeg&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../img/2.jpeg&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../img/3.jpeg&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../img/4.jpeg&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../img/5.jpeg&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../img/6.jpeg&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../img/7.jpeg&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../img/8.jpeg&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../img/9.jpeg&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../img/10.jpeg&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../img/11.jpeg&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../img/12.jpeg&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../img/13.jpeg&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../img/14.jpeg&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../img/15.jpeg&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-class">.container</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">display</span>:flex;</span><br><span class="language-css">        <span class="hljs-attribute">flex-direction</span>: column;</span><br><span class="language-css">        <span class="hljs-attribute">flex-wrap</span>: wrap;</span><br><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">800px</span>;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">    <span class="hljs-selector-class">.item</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">25%</span>;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">    <span class="hljs-selector-class">.item</span> <span class="hljs-selector-tag">img</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;</span><br><span class="language-css">    &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><p>实现效果：</p><img src="/2022/05/12/CSS/%E7%80%91%E5%B8%83%E6%B5%812.png" class=""><p><strong>优点</strong>：简单，有多少列就设置item宽度为100&#x2F;x%。如果每列图片数量相同，可以实现新的图片显示在最下方的业务。<br><strong>缺点</strong>：列数不会随着浏览的宽度而改变。需要指定高度，并且在每一列放置合适数量的图片。如果没有给容器设置固定宽度，则当容器宽度缩小时，图片的宽度相应的缩小。由于图片的高度是auto，即按图片原比例展示，因此图片高度会相应减少。由于高度指定，图片数量固定，则可能会出现图片占不满列数的情况。</p></li></ul><h1 id="三十、预处理less和sass"><a href="#三十、预处理less和sass" class="headerlink" title="三十、预处理less和sass"></a>三十、预处理less和sass</h1><h2 id="一、什么是CSS预处理器"><a href="#一、什么是CSS预处理器" class="headerlink" title="一、什么是CSS预处理器"></a>一、什么是CSS预处理器</h2><p>CSS预处理器定义了一种新的语言，其基本思想是，用一种专门的编程语言，为CSS增加了一些编程的特性，将CSS作为目标生成文件，然后开发者就只要使用这种语言就行CSS的编码工作。</p><h2 id="二、为什么要使用CSS预处理器"><a href="#二、为什么要使用CSS预处理器" class="headerlink" title="二、为什么要使用CSS预处理器"></a>二、为什么要使用CSS预处理器</h2><p>CSS仅仅是一个标记语言，不可以自定义变量，不可以引用。<br><strong>CSS</strong>缺点：<br>①语法不够强大，比如无法嵌套书写，导致模块化开发中需要书写很多重复的选择器。<br>②没有变量和合理的样式复用机制，使得逻辑上相关的属性值必须以字面量的形式重复输出，导致难以维护。<br>③预编译很容易造成后代选择器的滥用。<br><strong>使用预处理器优点</strong>：<br>①提供CSS层缺失的样式层复用机制。<br>②减少代码冗余。<br>③提高样式代码的可维护性。</p><h2 id="三、less和sas"><a href="#三、less和sas" class="headerlink" title="三、less和sas"></a>三、less和sas</h2><ul><li><strong>Less</strong> （Leaner Style Sheets 的缩写） 是一门向后兼容的 CSS 扩展语言。因为 Less 和 CSS 非常像，Less 仅对 CSS 语言增加了少许方便的扩展，学习很容易。<br>Less 是一门 CSS 预处理语言，它扩展了 CSS 语言，增加了变量、Mixin、函数等特性，使 CSS 更易维护和扩展。<br>Less 可以运行在 Node 或浏览器端。一个合法的CSS代码段本身也是一段合法的LESS代码段。<br>LESS 提供了变量、嵌套、混合、操作符、函数、导入等一般编程所需的抽象机制。<br>less变量用@变量名:值的方式，使用变量名时也用@变量名，用来代替许多相同的值，修改时可以一次性修改。</li><li><strong>sass</strong>，作为”世界上最成熟、最稳定、最强大的专业级CSS扩展语言”。兼容所有版本的css，且有无数框架使用sass构建，如Compass，Bourbon，和Susy。<br>Sass 是一款强化 CSS 的辅助工具，它在 CSS 语法的基础上增加了变量 (variables)、嵌套 (nested rules)、混合 (mixins)、导入 (inline imports) 等高级功能，这些拓展令 CSS 更加强大与优雅。</li></ul><p><strong>特色功能</strong> <strong>(Features)</strong><br>1.完全兼容 CSS3<br>2.在 CSS 基础上增加变量、嵌套 (nesting)、混合 (mixins) 等功能<br>3.通过函数进行颜色值与属性值的运算<br>4.提供控制指令 (control directives)等高级功能<br>5.自定义输出格式<br>SASS版本3.0之前的后缀名为.sass，而版本3.0之后的后缀名.scss。<br>Sass 和 Less 这类语言，其实可以理解成 CSS 的超集，它们在CSS 原本的语法格式基础上，增加了编程语言的特性，如变量的使用、逻辑语句的支持、函数等。让 CSS 代码更容易维护和复用。<br>但浏览器最终肯定是只认识 CSS 文件的，它无法处理 CSS 中的那些变量、逻辑语句，所以需要有一个编译的过程，将 Sass 或 Less 写的代码转换成标准的 CSS 代码，这个过程就称为 CSS 预处理。</p><h2 id="四、相同与差异"><a href="#四、相同与差异" class="headerlink" title="四、相同与差异"></a>四、相同与差异</h2><p><strong>相同</strong>：<br>1、混入(Mixins)——class中的class；<br>2、参数混入——可以传递参数的class，就像函数一样；<br>3、嵌套规则——Class中嵌套class，从而减少重复的代码；<br>4、运算——CSS中用上数学；<br>5、颜色功能——可以编辑颜色；<br>6、名字空间(namespace)——分组样式，从而可以被调用；<br>7、作用域——局部修改样式；<br>8、JavaScript 赋值——在CSS中使用JavaScript表达式赋值。<br><strong>不同</strong>：</p><table><thead><tr><th><strong>类别</strong></th><th><strong>Sass</strong></th><th><strong>less</strong></th></tr></thead><tbody><tr><td>环境</td><td>dart或其他</td><td>基于javascript，可以运行在 Node 或浏览器端</td></tr><tr><td>使用</td><td>复杂</td><td>简单(相对而言)</td></tr><tr><td>功能</td><td>复杂</td><td>简单(相对而言)</td></tr><tr><td>处理机制</td><td>服务端处理</td><td>可以运行在 Node 或浏览器端</td></tr><tr><td>变量</td><td>以 $ 开头</td><td>以 @ 开头</td></tr><tr><td>文件后缀</td><td>.sass 或. scss</td><td>.less</td></tr><tr><td>目前大部分的实现都是随着前端项目一起打包构建，只在学习或演示的时候才区分使用环境，所以不用在意处理机制，以上只是单纯的对比两者本身。</td><td></td><td></td></tr><tr><td>请不要忘记Dart Sass，它快速，易于安装，并且可以编译为纯JavaScript，从而可以轻松集成到现代Web开发工作流中。</td><td></td><td></td></tr></tbody></table><ul><li>在Less中，仅允许循环数值。<br>在Sass中，我们可以遍历任何类型的数据。但在Less中，我们只能使用递归函数循环数值。</li><li>条件语句<br>Less 中并不支持条件语句，当然，可以通过内置函数 if 以及 and，or，not 这些来模拟条件语句。<br>在 Sass 中是支持条件语句的，但也不是像其他编程语言直接 if 这样通过保留字来编写，需要加个 @ 符号</li></ul><h1 id="三十一、层叠上下文和index"><a href="#三十一、层叠上下文和index" class="headerlink" title="三十一、层叠上下文和index"></a>三十一、层叠上下文和index</h1><p>层叠上下文，指在Z轴上的层叠关系。层叠顺序，指元素发生层叠时有特定的垂直显示顺序。<br>由上到下分别是：<br>（1）背景和边框：建立当前层叠上下文元素的背景和边框。<br>（2）负的z-index：当前层叠上下文中，z-index属性值为负的元素。<br>（3）块级盒：文档流内非行内级非定位后代元素。<br>（4）浮动盒：非定位浮动元素。<br>（5）行内盒：文档流内行内级非定位后代元素。<br>（6）z-index:0：层叠级数为0的定位元素。<br>（7）正z-index：z-index属性值为正的定位元素。<br><strong>注意:</strong> 当定位元素z-index:auto，生成盒在当前层叠上下文中的层级为 0，不会建立新的层叠上下文，除非是根元素。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计网杂项</title>
    <link href="/2022/05/12/%E8%AE%A1%E7%BD%91%E6%9D%82%E9%A1%B9/"/>
    <url>/2022/05/12/%E8%AE%A1%E7%BD%91%E6%9D%82%E9%A1%B9/</url>
    
    <content type="html"><![CDATA[<h2 id="一、冲突域和广播域"><a href="#一、冲突域和广播域" class="headerlink" title="一、冲突域和广播域"></a>一、冲突域和广播域</h2><ul><li><strong>冲突域</strong>：冲突域是指同一时间只有一台设备发送信息的范围，说白了就是一次只有一个设备发送信息，其他的只能等待。因为如果同一个物理网段中的两台设备同时传输数据，将发生冲突，导致设备必须在以后重传数据。（基于物理层）</li><li><strong>广播域</strong>：广播是一种信息的传播方式，指网络中的某一设备同时向网络中的所有其它设备发送数据，这个数据所能广播到的范围就是广播域。广播域就是指网络中所有能接受到同样广播消息的设备的集合。（基于数据链路层）</li><li>有一个n个端口的以太网交换机，其冲突域有n个，广播域有1个。</li></ul><h2 id="二、OSI七层模型"><a href="#二、OSI七层模型" class="headerlink" title="二、OSI七层模型"></a>二、OSI七层模型</h2><p>OSI即开放式系统互联，定义了网络互联的七层框架（物理层、数据链路层、网络层、传输层、会话层、表示层、应用层）。</p><h3 id="1、应用层"><a href="#1、应用层" class="headerlink" title="1、应用层"></a>1、应用层</h3><p>OSI参考模型中最靠近用户的一层，是为计算机用户提供应用接口，也为用户直接提供各种网络服务。我们常见应用层的网络服务协议有：HTTP，HTTPS，FTP，POP3、SMTP等。<br>HTTP（超文本传输协议）在前后端通信中常用，FTP是文件传输协议，SMTP是简单邮件传输协议，在用户邮箱验证登陆时用到。</p><h3 id="2、表示层"><a href="#2、表示层" class="headerlink" title="2、表示层"></a>2、表示层</h3><p>表示层提供各种用于应用层数据的编码和转换功能,确保一个系统的应用层发送的数据能被另一个系统的应用层识别。如果必要，该层可提供一种标准表示形式，用于将计算机内部的多种数据格式转换成通信中采用的标准表示形式。数据压缩和加密也是表示层可提供的转换功能之一。<br>在项目中，为方便数据传输，可以使用base64对数据进行编码和解码。</p><h3 id="3、会话层"><a href="#3、会话层" class="headerlink" title="3、会话层"></a>3、会话层</h3><p>负责建立、管理和终止表示层实体之间的通信会话。该层的通信由不同设备中的应用程序之间的服务请求和响应组成。</p><h3 id="4、传输层"><a href="#4、传输层" class="headerlink" title="4、传输层"></a>4、传输层</h3><p>传输层建立了主机端到端的链接，传输层的作用是为上层协议提供端到端的可靠和透明的数据传输服务，包括处理差错控制和流量控制等问题。该层向高层屏蔽了下层数据通信的细节，使高层用户看到的只是在两个传输实体间的一条主机到主机的、可由用户控制和设定的、可靠的数据通路。我们通常说的，TCP UDP就是在这一层。端口号既是这里的“端”。</p><h3 id="5、网络层"><a href="#5、网络层" class="headerlink" title="5、网络层"></a>5、网络层</h3><p>本层通过IP寻址来建立两个节点之间的连接，为源端的运输层送来的分组，选择合适的路由和交换节点，正确无误地按照地址传送给目的端的运输层。就是通常说的IP层。这一层就是我们经常说的IP协议层。IP协议是Internet的基础。</p><h3 id="6、数据链路层"><a href="#6、数据链路层" class="headerlink" title="6、数据链路层"></a>6、数据链路层</h3><p>将比特组合成字节,再将字节组合成帧,使用链路层地址 (以太网使用MAC地址)来访问介质,并进行差错检测。数据链路层又分为2个子层：逻辑链路控制子层（LLC）和媒体访问控制子层（MAC）。<br>MAC子层处理CSMA&#x2F;CD算法、数据出错校验、成帧等；<br>LLC子层定义了一些字段使上次协议能共享数据链路层。 在实际使用中，LLC子层并非必需的。</p><h3 id="7、物理层"><a href="#7、物理层" class="headerlink" title="7、物理层"></a>7、物理层</h3><p>实际最终信号的传输是通过物理层实现的。通过物理介质传输比特流。规定了电平、速度和电缆针脚。常用设备有（各种物理设备）集线器、中继器、调制解调器、网线、双绞线、同轴电缆。这些都是物理层的传输介质。</p><h3 id="特点：对等通信"><a href="#特点：对等通信" class="headerlink" title="特点：对等通信"></a>特点：对等通信</h3><p>为了使数据分组从源传送到目的地，源端OSI模型的每一层都必须与目的端的对等层进行通信，这种通信方式称为对等层通信。在每一层通信过程中，使用本层自己协议进行通信。</p><h3 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h3><p>较为复杂而且不实用，运行效率很低，指定标准的周期太长，层次划分不合理，有些功能在多个层次中重复出现。</p><h2 id="三、TCP-x2F-IP五层模型"><a href="#三、TCP-x2F-IP五层模型" class="headerlink" title="三、TCP&#x2F;IP五层模型"></a>三、TCP&#x2F;IP五层模型</h2><p>分为应用层、传输层、网络层、数据链路层、物理层。</p><h3 id="1、应用层-1"><a href="#1、应用层-1" class="headerlink" title="1、应用层"></a>1、应用层</h3><p>直接为应用进程提供服务，应用层协议定义的是应用进程间通讯和交互的规则，不同的网络应用需要不同的应用协议。如HTTP（超文本传输协议）、FTP（文件传输协议）、SMTP（简单邮件传输协议）、DNS（域名查询）。应用层交互数据的单元称为报文。</p><h3 id="2、传输层"><a href="#2、传输层" class="headerlink" title="2、传输层"></a>2、传输层</h3><p>它负责为两台主机进程之间的通信提供通用的数据传输服务，应用进程利用该服务传送应用层报文。多种应用可以使用同一个传输层服务，传输层具有复用和分用的功能。复用指多个应用层进程可以同时使用下面传输层的服务，分用是指传输层把收到的信息分别交付到上面应用层中的相应进程。<br>TCP传输控制协议：提供面向连接的、可靠的数据传输服务。<br>UDP用户数据协议：提供无连接的、尽最大努力的数据传输服务。</p><h3 id="3、网络层（IP层）"><a href="#3、网络层（IP层）" class="headerlink" title="3、网络层（IP层）"></a>3、网络层（IP层）</h3><p>它负责为分组交换网上的不同主机提供通信服务，并通过选择合适的路由将数据传递到目标主机。</p><h3 id="4、数据链路层"><a href="#4、数据链路层" class="headerlink" title="4、数据链路层"></a>4、数据链路层</h3><p>负责将网络层交下来的IP数据报组装成帧，在两个相邻的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息、差错控制、地址信息等）。在接收数据时，控制信息使接收端能知道一个帧从哪个比特开始和到哪个比特结束。数据链路层在收到一个帧后提取出数据部分交给网络层。控制信息还使接收端能够检测到所收到的帧中有无误差，如果有差错就丢弃该帧，或者进行纠错。</p><h3 id="5、物理层"><a href="#5、物理层" class="headerlink" title="5、物理层"></a>5、物理层</h3><p>作用是实现相邻计算机节点之间比特流的透明传送，确保数据可以在各种物理媒介上进行传输，为数据的传输提供可靠的环境。</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络层</title>
    <link href="/2022/05/11/%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    <url>/2022/05/11/%E7%BD%91%E7%BB%9C%E5%B1%82/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统</title>
    <link href="/2022/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9D%82%E9%A1%B9/"/>
    <url>/2022/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9D%82%E9%A1%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="一、单级索引文件结构"><a href="#一、单级索引文件结构" class="headerlink" title="一、单级索引文件结构"></a>一、单级索引文件结构</h1><p>使用单级文件结构时，索引表表项占用a，物理块大小为b，该系统可以管理的磁盘大小为：（b&#x2F;a）*b</p><h1 id="二、高响应比优先调度算法和先来先服务调度算法"><a href="#二、高响应比优先调度算法和先来先服务调度算法" class="headerlink" title="二、高响应比优先调度算法和先来先服务调度算法"></a>二、高响应比优先调度算法和先来先服务调度算法</h1><ul><li>高响应比优先调度算法：根据响应比优先选择响应比高的作业执行。<br>响应比 &#x3D; （等待时间+要求服务时间）&#x2F;要求服务时间</li><li>先来先服务调度算法：优先选择先到达的作业执行。</li></ul><h1 id="三、页面置换算法"><a href="#三、页面置换算法" class="headerlink" title="三、页面置换算法"></a>三、页面置换算法</h1><h2 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h2><ul><li>当出现缺页异常，需调入新页面而内存已满时，置换算法选择被置换的物理页面。尽可能减少页面的调入调出次数。</li><li>局部置换算法：在内存中，给每个进程分配的页面总数不会变化。</li><li>全局置换算法：置换页面的选择范围是所有可换出的物理页面。<h2 id="二、局部置换算法"><a href="#二、局部置换算法" class="headerlink" title="二、局部置换算法"></a>二、局部置换算法</h2></li><li><strong>最优置换算法</strong>：置换未来最长时间不访问的页面。缺页最少，难以实现。</li><li><strong>先进先出算法</strong>：选择在内存驻留时间最长的页面进行置换。最简单。</li><li><strong>最近最久未使用算法</strong>：选择最长时间没有被引用的页面进行置换。开销大。</li><li><strong>最不常用算法</strong>：置换访问次数最少页面。</li><li><strong>时钟重置算法</strong>：页面装入内存时，访问位初始化为0，访问页面时，访问位置1.缺页时，从指针当前位置顺序检查环形链表：访问位为0，置换该页；访问位为1，则访问位置0，并指针移动到下一个页面，直到找到可以置换的页面。<br>（空的放入时不算进行置换操作，直接放入）</li><li><strong>堆栈型算法</strong>：随着分配给程序的主存页面数增加，主存的命中率会提高。<strong>只有先进先出算法不是堆栈型算法</strong><h2 id="三、全局置换算法"><a href="#三、全局置换算法" class="headerlink" title="三、全局置换算法"></a>三、全局置换算法</h2></li><li>工作集置换算法</li><li>缺页率置换算法</li><li><strong>抖动</strong>：进程物理页面太少，不能包含工作集，造成大量缺页，频繁置换，进程运行速度变慢。<strong>产生原因</strong>是随着驻留内存的进程数目增加，分配给每个进程的物理页数不断减少，缺页率不断上升。操作系统需在并发水平和缺页率之间达到一个平衡。</li><li><strong>负载控制</strong>：当缺页间隔时间大于缺页异常处理时间时，处理器就来得及处理缺页；如果是小于的话，就满负荷运行了，处理不过来了。所以需要找到一个负载均衡点，使得两者恰好相等。通过调节并发进程数来进行系统负载控制。</li></ul><h1 id="★四、进程和线程"><a href="#★四、进程和线程" class="headerlink" title="★四、进程和线程"></a>★四、进程和线程</h1><ul><li><strong>进程是系统进行资源分配和调度的一个独立单位</strong>，代表CPU所能处理的单个任务。任一时刻CPU总是运行一个进程。（系统调度）</li><li>一个进程包括多个线程，每个线程共享进程的所有内存空间。互斥锁可以防止其他线程使用。一个进程内部可能包含了很多顺序执行流，每个顺序执行流就是一个线程。线程是进程的一个实体，<strong>是CPU调度和分派的基本单位</strong>，是比进程更小的能独立运行的基本单位。（CPU调度）</li><li>一个进程内部可能包含了很多顺序执行流，每个顺序执行流就是一个线程。单线程就是只有一个顺序执行流，多线程是多条顺序执行流“同时”执行。</li><li>并发：同一时刻只能有一条指令（或一个进程、一个线程）运行，但是宏观上看有多条指令同时执行。</li><li>并行：同一时刻多条指令在多个处理机上同时执行。</li><li>进程和线程主要区别在于它们是不同操作系统资源管理方式。进程有独立的地址空间，进程崩溃后在保护模式下不会对其他进程产生影响。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉等于整个进程死掉。<strong>所以多进程比多线程健壮。</strong>进程切换时耗费资源大、效率差，但对于一些要求同时进行并且又要共享某些变量的并发操作只能使用线程，不能用进程。</li><li>一个程序至少有一个进程，一个进程至少有一个线程。多线程程序的并发性高。进程在执行过程中有独立的内存单元，而多个线程共享内存，极大提高了程序的运行效率。</li><li>每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</li><li>从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。</li></ul><h1 id="五、什么时候会引发进程切换"><a href="#五、什么时候会引发进程切换" class="headerlink" title="五、什么时候会引发进程切换"></a>五、什么时候会引发进程切换</h1><p>进程切换一定发生在中断&#x2F;异常&#x2F;系统调用处理过程中，常见有以下情况：<br>①时间片中断、IO中断后更改优先级进程（导致被中断进程进入就绪状态）<br>②阻塞式系统调用、虚拟地址异常（导致被中断进程进入等待态）<br>③终止用系统调用、不能继续执行的异常（导致被中断进程进行终止态）<br>例如：</p><ul><li>时钟中断：操作系统确定当前正在运行的进程的执行时间是否已经超过了最大允许时间段，如果超过了，进程必须切换到就绪态，调度另一个进程。</li><li>I&#x2F;O中断：操作系统确定是否发生了I&#x2F;O活动。如果I&#x2F;O活动是一个或多个进程正在等待的时事件，操作系统就把所有相应的阻塞态转换到就绪态，操作系统必须决定继续执行当前处于运行态的进程，还是让具有更高优先级的就绪态抢占这个进程。</li><li>虚拟地址异常（内存失效）：处理器访问一个虚拟内存地址，且此地址单元不在内存中，操作系统必须从外存把包含这个引用的内存块（页或者段）调入到内存中，在发出调入内存块的I&#x2F;O请求之后，操作系统可以执行一个进程切换，以回复另一个进程的执行。发生内存失效的进程被设置为阻塞态，当想要的块调入内存中时，该进程被置位就绪态。</li><li>对于陷阱：操作系统确定错误或异常条件是否是致命的。如果是，当前正在运行的进程被转换到退出态，并发生进程切换；如果不是，操作系统的动作取决于错误的种类和操作系统的设计，其行为可以是试图恢复或通知用户，操作系统可能会进行一次进程切换或者继续执行当前正在运行的进程。</li><li>操作系统可能被来自正在执行的程序的系统调用激活。例如：一个用户进程正在进行，并且正在执行一条请求I&#x2F;O操作的指令，如打开文件，这个调用导致转移到作为操作系统代码的一部分的一个例程上进行。通常，使用系统调用会导致把用户线程设置为阻塞态。</li></ul><h1 id="六、进程、线程、协程概念"><a href="#六、进程、线程、协程概念" class="headerlink" title="六、进程、线程、协程概念"></a>六、进程、线程、协程概念</h1><p><strong>协程</strong>：一种用户态的轻量级线程，拥有自己的寄存器上下文和栈，无需线程上下文切换的开销，协程的本质是单个线程，它不能同时在单个CPU的多个核上使用。<br>从本质上说，进程和线程都是CPU工作时间片的一个描述：进程描述了 CPU 在运行指令及加载和保存上下文所需的时间，放在应用上来说就代表了一个程序。线程是进程中的更小单位，描述了执行一段指令所需的时间。<br><strong>协程优势</strong>：<br>节省 CPU：避免系统内核级的线程频繁切换，造成的 CPU 资源浪费。而协程是用户态的线程，用户可以自行控制协程的创建于销毁，极大程度避免了系统级线程上下文切换造成的资源浪费。<br>节约内存：在 64 位的Linux中，一个线程需要分配 8MB 栈内存和 64MB 堆内存，系统内存的制约导致我们无法开启更多线程实现高并发。而在协程编程模式下，可以轻松有十几万协程，这是线程无法比拟的。<br>稳定性：前面提到线程之间通过内存来共享数据，这也导致了一个问题，任何一个线程出错时，进程中的所有线程都会跟着一起崩溃。<br>开发效率：使用协程在开发程序之中，可以很方便的将一些耗时的IO操作异步化，例如写文件、耗时IO请求等。<br><strong>进程是系统进行资源分配的最小单位，线程是CPU调度的最小单位</strong>。<br>一个进程就是一个程序的运行实例。详细解释就是，启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫<strong>进程</strong>。<strong>进程是运行在虚拟内存上的，虚拟内存是用来解决用户对硬件资源的无限需求和有限的硬件资源之间的矛盾的。从操作系统角度来看，虚拟内存即交换文件；从处理器角度看，虚拟内存即虚拟地址空间。</strong><br>如果程序很多时，内存可能会不够，操作系统为每个进程提供一套独立的虚拟地址空间，从而使得同一块物理内存在不同的进程中可以对应到不同或相同的虚拟地址，变相的增加了程序可以使用的内存。</p><hr><p>进程和线程之间的关系有以下四个特点：<br>（1）<strong>进程中的任意一线程执行出错，都会导致整个进程的崩溃。</strong>因此多进程程序更健壮，进程有自己独立的地址空间。<br>（2）<strong>线程之间共享进程中的全局变量、静态变量等数据。</strong>因此线程之间通信更方便，CPU切换一个线程的花费比进程小很多，同时创建一个线程的开销也比进程小很多。<br>（3）<strong>当一个进程关闭之后，操作系统会回收进程所占用的内存，</strong> 当一个进程退出时，操作系统会回收该进程所申请的所有资源；即使其中任意线程因为操作不当导致内存泄漏，当进程退出时，这些内存也会被正确回收。<br>（4）<strong>进程之间的内容相互隔离。</strong> 进程隔离就是为了使操作系统中的进程互不干扰，每一个进程只能访问自己占有的数据，也就避免出现进程 A 写入数据到进程 B 的情况。正是因为进程之间的数据是严格隔离的，所以一个进程如果崩溃了，或者挂起了，是不会影响到其他进程的。如果进程之间需要进行数据的通信，这时候，就需要使用用于进程间通信的机制了。</p><h1 id="七、进程和线程区别"><a href="#七、进程和线程区别" class="headerlink" title="七、进程和线程区别"></a>七、进程和线程区别</h1><ul><li>进程可以看做独立应用，线程不能。</li><li>资源：进程是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）；线程是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）。</li><li>通信方面：线程间可以通过直接共享同一进程中的资源，而进程通信需要借助 进程间通信。</li><li>调度：进程切换比线程切换的开销要大。线程是CPU调度的基本单位，线程的切换不会引起进程切换，但某个进程中的线程切换到另一个进程中的线程时，会引起进程切换。</li><li>系统开销：由于创建或撤销进程时，系统都要为之分配或回收资源，如内存、I&#x2F;O 等，其开销远大于创建或撤销线程时的开销。同理，在进行进程切换时，涉及当前执行进程 CPU 环境还有各种各样状态的保存及新调度进程状态的设置，而线程切换时只需保存和设置少量寄存器内容，开销较小。</li></ul><h1 id="八、死锁"><a href="#八、死锁" class="headerlink" title="八、死锁"></a>八、死锁</h1><p><strong>死锁</strong>：多个线程&#x2F;进程在运行过程中因为争夺资源导致的，它们中的一个或全部都在等待某个资源被释放。<br>系统中的资源可分为：<br><strong>可剥夺资源</strong>，是指某进程在获得这类资源后，该资源可以再被其他进程或系统剥夺，CPU和主存均属于可剥夺性资源；<br><strong>不可剥夺资源</strong>，当系统把这类资源分配给某进程后，再不能强行收回，只能在进程用完后自行释放，如磁带机、打印机等。<br><strong>产生死锁的必要条件</strong>：</p><ol><li><strong>互斥条件</strong>：该资源任意⼀个时刻只由⼀个线程占⽤。</li><li><strong>请求与保持条件</strong>：⼀个进程因请求资源⽽阻塞时，对已获得的资源保持不放。</li><li><strong>不剥夺条件</strong>:线程已获得的资源在末使⽤完之前不能被其他线程强⾏剥夺，只有⾃⼰使⽤完毕 后才释放资源。</li><li><strong>循环等待条件</strong>:若⼲进程之间形成⼀种头尾相接的循环等待资源关系。</li></ol><p><strong>产生死锁的原因</strong>：</p><ol><li><strong>竞争资源</strong>：产生死锁中的竞争资源之一指的是<strong>竞争不可剥夺资源</strong>（例如：系统中只有一台打印机，可供进程P1使用，假定P1已占用了打印机，若P2继续要求打印机打印将阻塞）；产生死锁中的竞争资源另外一种资源指的是<strong>竞争临时资源</strong>（临时资源包括硬件中断、信号、消息、缓冲区内的消息等），通常消息通信顺序进行不当，则会产生死锁。</li><li><strong>进程间推进顺序非法</strong>：若P1保持了资源R1，P2保持了资源R2，系统处于不安全状态，因为这两个进程再向前推进，便可能发生死锁。例如，当P1运行到P1：Request（R2）时，将因R2已被P2占用而阻塞；当P2运行到P2：Request（R1）时，也将因R1已被P1占用而阻塞，于是发生进程死锁。</li></ol><p><strong>死锁的预防</strong>：</p><ul><li>资源一次性分配：一次性分配所有资源，这样就不会再有请求了（破坏请求条件）</li><li>只要有一个资源得不到分配，也不给这个进程分配其他的资源（破坏请保持条件）</li><li>可剥夺资源：即当某进程获得了部分资源，但得不到其它资源，则释放已占有的资源（破坏不可剥夺条件）</li><li>资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件）</li></ul><p><strong>死锁消除</strong>：</p><ol><li><strong>进程回退</strong>策略：即让参与死锁的进程回退到没有发生死锁前某一点处，并由此点处继续执行，以求再次执行时不再发生死锁。虽然这是个较理想的办法，但是操作起来系统开销极大，要有堆栈这样的机构记录进程的每一步变化</li><li>撤消进程，<strong>剥夺资源</strong>。终止参与死锁的进程，收回它们占有的资源，从而解除死锁。一次性撤消参与死锁的全部进程，剥夺全部资源；或者逐步撤消参与死锁的进程，逐步收回死锁进程占有的资源。</li></ol>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据链路层</title>
    <link href="/2022/05/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
    <url>/2022/05/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/</url>
    
    <content type="html"><![CDATA[<h2 id="一、回退N帧"><a href="#一、回退N帧" class="headerlink" title="一、回退N帧"></a>一、回退N帧</h2><p>发送方已经发送了编号为0~10的帧，当计时器超时时，若发送方只收到0、2、4号帧的确认，则发送方需要重发的帧数为6。</p><ul><li>在后退N帧协议中，发送方可以连续发送若干个数据帧，如果收到接收方的确认帧，则可以继续发送。</li><li>若某个帧出错，接收方只是简单丢弃该帧及其后所有的后续帧，发送方超时后需重传该数据帧及其后续的所有数据帧。</li><li>连续ARQ协议中，接收方一般采用积累确认的方式，即接收方按序到达的最后一个分组发送确认。题目中收到4的确认帧就代表编号0、1、2、3、4的帧已接收，发送方未收到1、3的帧只能代表确认帧在返回到 过程中丢失了，而不代表1号帧未到达接收方。因此要重传5、6、7、8、9、10</li></ul><h2 id="二、数据链路层使用的信道"><a href="#二、数据链路层使用的信道" class="headerlink" title="二、数据链路层使用的信道"></a>二、数据链路层使用的信道</h2><ul><li>点对点信道：点对点的通信方式。</li><li>广播信道：一对多的方式，整个过程比较复杂，必须使用一些信道协议来协调网络中的主机数据发送。<h2 id="三、链路层的意义和工作过程"><a href="#三、链路层的意义和工作过程" class="headerlink" title="三、链路层的意义和工作过程"></a>三、链路层的意义和工作过程</h2>物理层的线路由传输介质与通信设备组成，比特流在传输介质上传输时肯定会产生误差。引入数据链路层在物理层之上，采用差错检测、差错控制和流量控制等方法，向网络层提供高质量的数据传输服务。对于网络层，由于链路层的存在，不需要关心物理层具体采用了哪种传输介质和通信设备。<br>工作过程：建立数据链路、帧传输、释放数据链路。<h2 id="四、链路层的功能有哪些？需要完成哪些事情？"><a href="#四、链路层的功能有哪些？需要完成哪些事情？" class="headerlink" title="四、链路层的功能有哪些？需要完成哪些事情？"></a>四、链路层的功能有哪些？需要完成哪些事情？</h2></li></ul><ol><li>链路管理，帧同步，组帧。</li><li>流量控制，差错控制，可靠交付。</li><li>数据和控制信息分开</li><li>透明传输和寻址，链路接入：点对点链路、广播链路<h2 id="五、链路层怎么进行组帧？怎么进行帧的界定？"><a href="#五、链路层怎么进行组帧？怎么进行帧的界定？" class="headerlink" title="五、链路层怎么进行组帧？怎么进行帧的界定？"></a>五、链路层怎么进行组帧？怎么进行帧的界定？</h2></li></ol><ul><li>组帧就是在帧的前后添加首部和尾部，这样就能界定帧的边界了。MTU（Maximum Transmission Unit，网络上传送的最大数据包）就是帧的数据部分的最大长度，也就是IP数据报的最大长度。</li><li>帧的界定是在帧的开始和结束的地方加上特定的字符（帧的定界符），一般是0X7E。<h2 id="六、链路层怎么进行透明传输"><a href="#六、链路层怎么进行透明传输" class="headerlink" title="六、链路层怎么进行透明传输"></a>六、链路层怎么进行透明传输</h2>如果帧内部的数据出现了0x7e，则需要进行转义，转义的方法有下面两种：</li><li>字符填充：因为0x7e&#x3D;0111 1110，字符填充是在这两个字节中填充进0xd5，变为（0x7d，0x5e），即0111 1101 1001 1110.</li><li>零比特填充：因为0x7e&#x3D;0111 1110，带有连续的6个1，因此发送端发送帧数据时，每当发现有5个连续的1，立即填充一个0发送。接收端对帧中的比特流扫码，每当发现5个连续的1，就把后面的一个0删除。即0111 1110变成0111 1101 0进行传输。<h2 id="七、差错产生的原因"><a href="#七、差错产生的原因" class="headerlink" title="七、差错产生的原因"></a>七、差错产生的原因</h2>差错是不可避免的，而且不同的传输介质的差错程度也是不同的。链路层的任务就是分析差错产生的原因，检查差错，然后纠正差错。当数据信号从发送端发送到物理线路时，由于物理线路存在噪声，因此数据信号经过物理线路的噪声，到达接收端时，已经是数据+噪声的叠加，这就是差错的来源。<h2 id="八、怎么进行差错控制"><a href="#八、怎么进行差错控制" class="headerlink" title="八、怎么进行差错控制"></a>八、怎么进行差错控制</h2>差错控制分为两种不同的策略：</li><li>纠错码：每个传输的分组带上足够的冗余信息，接收端能发现并自动纠正差错。</li><li>检测码：分组包含能够发现差错的冗余信息，接收端能够发现差错。<br>由于纠错码实现比较复杂，检测码虽不能纠错，但是足够简单，能够检测出差错，配合重传机制即可，所以广泛采用检测码。<br>四种基本方式：检错重发、前向纠错（接收端进行差错纠正）、反馈校验（接受端将收到的数据原封不动发回传送端）、检错丢弃。<br>检测码有循环冗余编码（CRC）等方式，见下图：</li></ul><img src="/2022/05/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/CRC.png" class=""> <h2 id="九、滑动窗口协议"><a href="#九、滑动窗口协议" class="headerlink" title="九、滑动窗口协议"></a>九、滑动窗口协议</h2><p>帧传输过程中如果发生了错误，就需要滑动窗口协议来解决，滑动窗口协议分为以下两种类型：<br><strong>单帧停止等待协议</strong>：发送端发送1帧之后，需要等待接收端返回确认帧，如果收到ack，表示ok，发送下一帧；如果收到nak，表示传输错误，重新发送该帧。<br><strong>多帧发送协议</strong>：分为两种类型：</p><ul><li>回退N帧（GBN）：发送端窗口较大，可以在未得到确认前连续发送多个分组，但接收窗口大小仅为1，只能接收1个按序到达的分组，未按序到达的分组或者某个分组差错，就会引起发送方重发该分组及其之后的所有分组。</li><li>选择重发（SR）：增加接收方的缓存能力，缓存正确到达但失序的分组，只要求发送方发送未被接收方确认的分组。<h2 id="十、滑动窗口机制"><a href="#十、滑动窗口机制" class="headerlink" title="十、滑动窗口机制"></a>十、滑动窗口机制</h2>在GBN和SR中，发送端可以连续发送多个数据帧，从流量控制的角度出发，发送端连续发送数据帧的数量必然会受到限制：</li></ul><ol><li>接收端的缓冲区可以用于接收新的帧的容量。</li><li>接收端处理数据帧的速度。</li><li>接收端需要等待重传的帧数量。<br>引入滑动窗口的目的：对可以连续发出的最多帧数（已发出但未确认的帧）作限制。<br>发送窗口（ws）:表示在收到对方确认信息之前，以连续发出的最多数据帧数。<br>接收窗口（wr）：可以连续接收的最多数据帧数（只有序号在窗口内的帧才可以接收，否则丢弃）。</li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>进程与线程</title>
    <link href="/2022/05/11/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
    <url>/2022/05/11/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h4 id="一、进程和线程"><a href="#一、进程和线程" class="headerlink" title="一、进程和线程"></a>一、进程和线程</h4><ul><li><strong>进程是系统进行资源分配和调度的一个独立单位</strong>，代表CPU所能处理的单个任务。任一时刻CPU总是运行一个进程。（系统调度）</li><li>一个进程包括多个线程，每个线程共享进程的所有内存空间。互斥锁可以防止其他线程使用。一个进程内部可能包含了很多顺序执行流，每个顺序执行流就是一个线程。线程是进程的一个实体，<strong>是CPU调度和分派的基本单位</strong>，是比进程更小的能独立运行的基本单位。（CPU调度）</li><li>一个进程内部可能包含了很多顺序执行流，每个顺序执行流就是一个线程。单线程就是只有一个顺序执行流，多线程是多条顺序执行流“同时”执行。</li><li>并发：同一时刻只能有一条指令（或一个进程、一个线程）运行，但是宏观上看有多条指令同时执行。</li><li>并行：同一时刻多条指令在多个处理机上同时执行。</li><li>进程和线程主要区别在于它们是不同操作系统资源管理方式。进程有独立的地址空间，进程崩溃后在保护模式下不会对其他进程产生影响。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉等于整个进程死掉。<strong>所以多进程比多线程健壮。</strong>进程切换时耗费资源大、效率差，但对于一些要求同时进行并且又要共享某些变量的并发操作只能使用线程，不能用进程。</li><li>一个程序至少有一个进程，一个进程至少有一个线程。多线程程序的并发性高。进程在执行过程中有独立的内存单元，而多个线程共享内存，极大提高了程序的运行效率。</li><li>每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</li><li>从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。</li></ul>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序算法</title>
    <link href="/2022/05/11/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <url>/2022/05/11/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h3 id="一、排序算法"><a href="#一、排序算法" class="headerlink" title="一、排序算法"></a>一、排序算法</h3><img src="/2022/05/11/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F.png" class="" title="排序"><ul><li>稳定：如果a原本在b的前面，a&#x3D;b，排序之后a仍在b的前面。<h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a><strong>冒泡排序</strong></h4></li><li>重复走访要排序的序列，一次比较两个元素，若顺序错误就进行交换，直到不再发生交换。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>;i&lt;arr.<span class="hljs-property">length</span>-<span class="hljs-number">1</span>;i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> j=<span class="hljs-number">0</span>;j&lt;arr.<span class="hljs-property">length</span>-i-<span class="hljs-number">1</span>;j++)&#123;<br>        <span class="hljs-keyword">if</span>(arr[j]&gt;arr[j+<span class="hljs-number">1</span>]&#123;<br>            <span class="hljs-keyword">var</span> temp = arr[j];<br>            arr[j] = arr[j+<span class="hljs-number">1</span>];<br>            arr[j+<span class="hljs-number">1</span>] = temp;<br>       &#125;<br> &#125;<br></code></pre></td></tr></table></figure><h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a><strong>选择排序</strong></h4><ul><li>首先在未排序序列中找到最小（最大）元素，存放到排序序列的起始位置（进行交换），然后再从剩余未排序元素汇总继续寻找最小（最大）。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">selectionSort</span>(<span class="hljs-params">array</span>)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;array.<span class="hljs-property">length</span>-<span class="hljs-number">1</span>;i++)&#123;<br>        <span class="hljs-keyword">let</span> minIndex = i;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j=i+<span class="hljs-number">1</span>;j&lt;array.<span class="hljs-property">length</span>;j++)&#123;<br>            <span class="hljs-keyword">if</span>(array[j]&lt;array[minindex]&#123;<br>                minindex = j;<br>            &#125;<br>        &#125;<br>        [array[i],array[minindex]] = [array[minindex],array[i]];<br>    &#125;<br>    <span class="hljs-keyword">return</span> array;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a><strong>插入排序</strong></h4><ul><li>在已经排好的数据序列中插入一个数，插入后仍然有序。从头往后，每次选择一个数插入到前面排序好的序列中。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> insertSort = <span class="hljs-keyword">function</span>(<span class="hljs-params">arr</span>)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;arr.<span class="hljs-property">length</span>;i++)&#123;<br>        <span class="hljs-keyword">let</span> temp = arr[i];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j=i-<span class="hljs-number">1</span>;j&gt;=<span class="hljs-number">0</span>;j--)&#123;<br>            <span class="hljs-keyword">if</span>(temp&lt;arr[j])&#123;<br>                arr[j+<span class="hljs-number">1</span>] = arr[j];<br>            &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">break</span>&#125;<br>        &#125;<br>        arr[j+<span class="hljs-number">1</span>] = temp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="希尔排序-缩小增量排序"><a href="#希尔排序-缩小增量排序" class="headerlink" title="希尔排序(缩小增量排序)"></a><strong>希尔排序(缩小增量排序)</strong></h4><ul><li>先将整个待排元素序列分割成若干个子序列，分别进行直接插入排序，然后依次缩减增量再进行排序。</li></ul><p>案例：</p><img src="/2022/05/11/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/1.png" class="" title="一"><p>第一次增量：10&#x2F;2&#x3D;5，组内排序</p><img src="/2022/05/11/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/2.png" class="" title="二"><p>排序后：</p><img src="/2022/05/11/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/3.png" class="" title="三"><p>第二次增量：5&#x2F;2&#x3D;2，组内排序</p><img src="/2022/05/11/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/4.png" class="" title="四"><p>排序后：</p><img src="/2022/05/11/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/5.png" class="" title="五"><p>第三次增量：2&#x2F;2&#x3D;1，排序：</p><img src="/2022/05/11/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/6.png" class="" title="六"><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> shallSort = <span class="hljs-keyword">function</span>(<span class="hljs-params">arr</span>)&#123;<br>    <span class="hljs-keyword">let</span> len = arr.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> gap = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(len/<span class="hljs-number">2</span>);gap&gt;<span class="hljs-number">0</span>;gap=<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(gap/<span class="hljs-number">2</span>))&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=gap;i&lt;len;i++)&#123;<br>            <span class="hljs-keyword">let</span> j = i;<br>            <span class="hljs-keyword">let</span> current = arr[i];<br>            <span class="hljs-keyword">while</span>(j-gap&gt;=<span class="hljs-number">0</span>&amp;&amp;current&lt;arr[j-gap])&#123;<br>                arr[j] = arr[j-gap];<br>                j = j -gap;<br>            &#125;<br>            arr[j] = current;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure><p>原版：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">_quickSort</span> = array =&gt; &#123;<br>    <span class="hljs-comment">// 补全代码</span><br>    <span class="hljs-title function_">quickSort</span>(array, <span class="hljs-number">0</span>, array.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>)<br>    <span class="hljs-comment">// 别忘了返回数组</span><br>    <span class="hljs-keyword">return</span> array<br>&#125;<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">quickSort</span> = (<span class="hljs-params">array, start, end</span>) =&gt; &#123;<br>    <span class="hljs-comment">// 注意递归边界条件</span><br>    <span class="hljs-keyword">if</span>(end - start &lt; <span class="hljs-number">1</span>)    <span class="hljs-keyword">return</span><br>    <span class="hljs-comment">// 取第一个数作为基准</span><br>    <span class="hljs-keyword">const</span> base = array[start]<br>    <span class="hljs-keyword">let</span> left = start<br>    <span class="hljs-keyword">let</span> right = end<br>    <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>        <span class="hljs-comment">// 从右往左找小于基准元素的数，并赋值给右指针 array[right]</span><br>        <span class="hljs-keyword">while</span>(left &lt; right &amp;&amp;  array[right] &gt;= base)    right--<br>        array[left] = array[right]<br>        <span class="hljs-comment">// 从左往右找大于基准元素的数，并赋值给左指针 array[left]</span><br>        <span class="hljs-keyword">while</span>(left &lt; right &amp;&amp; array[left] &lt;= base)    left++<br>        array[right] = array[left]<br>    &#125;<br>    <span class="hljs-comment">// 双指针重合处，将基准元素填到这个位置。基准元素已经事先保存下来了，因此不用担心上面的赋值操作会覆盖掉基准元素的值</span><br>    <span class="hljs-comment">// array[left] 位置已经确定，左边的都比它小，右边的都比它大</span><br>    array[left] = base<br>    <span class="hljs-title function_">quickSort</span>(array, start, left - <span class="hljs-number">1</span>)<br>    <span class="hljs-title function_">quickSort</span>(array, left + <span class="hljs-number">1</span>, end)<br>    <span class="hljs-keyword">return</span> array<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a><strong>快速排序</strong></h4><ul><li>一趟排序中将要排序的数据分成独立的两部分，一部分所有数据比另一部分所有数据都小。</li><li>先找一个基准点（一般是数组中部），然后数据分为两部分，依次与该基准点数据比较，小放左边大放右边。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">quickSort</span>(<span class="hljs-params">arr</span>)&#123;<br>    <span class="hljs-keyword">if</span>(arr.<span class="hljs-property">length</span>&lt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> arr;<br>    <span class="hljs-keyword">const</span> num = arr[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">let</span> left = [],right = [];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">1</span>;i&lt;arr.<span class="hljs-property">length</span>;i++)&#123;<br>        <span class="hljs-keyword">if</span>(arr[i]&lt;=num) left.<span class="hljs-title function_">push</span>(arr[i]);<br>        <span class="hljs-keyword">else</span> right.<span class="hljs-title function_">push</span>(arr[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">quickSort</span>(left).<span class="hljs-title function_">concat</span>([num],<span class="hljs-title function_">quickSort</span>(right));<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a><strong>归并排序</strong></h4><ul><li>将数组分成等长的，对每部分进行排序，然后再合并排序。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">mergeSort</span>(<span class="hljs-params">arr</span>)&#123;<br>    <span class="hljs-keyword">if</span>(arr.<span class="hljs-property">length</span>===<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">return</span> arr;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">let</span> mid = <span class="hljs-built_in">parseInt</span>(arr.<span class="hljs-property">length</span>/<span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">let</span> left  =arr.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>,mid);<br>        <span class="hljs-keyword">let</span> right = arr.<span class="hljs-title function_">slice</span>(mid);<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">merge</span>(<span class="hljs-title function_">mergeSort</span>(left),<span class="hljs-title function_">mergeSort</span>(right));<br>    &#125;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">merge</span>(<span class="hljs-params">left,right</span>)&#123;<br>    <span class="hljs-keyword">let</span> temp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>();<br>    <span class="hljs-keyword">while</span>(left.<span class="hljs-property">length</span>&gt;<span class="hljs-number">0</span> &amp;&amp; right.<span class="hljs-property">length</span>&gt;<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">if</span>(left[<span class="hljs-number">0</span>]&lt;right[<span class="hljs-number">0</span>])&#123;<br>            temp.<span class="hljs-title function_">push</span>(left.<span class="hljs-title function_">shift</span>());<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            temp.<span class="hljs-title function_">push</span>(right.<span class="hljs-title function_">shift</span>());<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> temp.<span class="hljs-title function_">concat</span>(left,right);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a><strong>堆排序</strong></h4><ul><li>堆是完全二叉树，每个节点大于等于左右孩子节点的值， 称为大顶堆；每个结点的值小于等于左右孩子结点的值，称为小顶堆。将待排序序列构建一个大顶堆，整个序列最大值是堆顶的根节点。将其与末尾元素进行交换，末尾为最大值，然后将剩余n-1个元素重新构造一个堆，重复此操作。（只需要总根大于等于所有子结点）</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//建堆，arr数组，x数组下标，len堆大小。给出根节点下标，判断左右子节点是否小于根节点，否则进行交换，从被交换的节点位置进一步判断其左右子节点。</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">heapify</span>(<span class="hljs-params">arr,x,len</span>)&#123;    <br>    <span class="hljs-keyword">var</span> l =<span class="hljs-number">2</span> * x + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">var</span> r = <span class="hljs-number">2</span> * x + <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">var</span> largset = x;<br>    <span class="hljs-keyword">var</span> temp;<br>    <span class="hljs-keyword">if</span>(l&lt;len&amp;&amp;arr[l]&gt;arr[largset])&#123;<br>        largset = l;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(r&lt;len&amp;&amp;arr[r]&gt;arr[largset]&#123;<br>        largset = r;<br>    &#125;   <span class="hljs-comment">//判断给定结点、左子结点和右子结点最大值。</span><br>    <span class="hljs-keyword">if</span>(largset!=x)&#123;<br>        temp = arr[x];<br>        arr[x] = arr[largset];<br>        arr[largset] = temp;<br>        <span class="hljs-title function_">heapify</span>(arr,largset,len);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">heapSort</span>(<span class="hljs-params">arr</span>)&#123;<br>    <span class="hljs-keyword">var</span> heapSize = arr.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">var</span> temp;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(heapSize/<span class="hljs-number">2</span>)-<span class="hljs-number">1</span>,i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>        <span class="hljs-title function_">heapify</span>(arr,i,heapSize);  <span class="hljs-comment">//从倒数第二层最后一个有子节点的节点依次往前，将所有置为大顶堆</span><br>    &#125;<br>    <span class="hljs-comment">//首位为大顶堆的根，将其换到末尾，然后将末尾它之前的数组置为大顶堆，然后重复。</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j=heapSize-<span class="hljs-number">1</span>;j&gt;=<span class="hljs-number">1</span>;j--)&#123;<br>        temp = arr[<span class="hljs-number">0</span>];<br>        arr[<span class="hljs-number">0</span>] = arr[j];<br>        arr[j] = temp;<br>        <span class="hljs-title function_">heapify</span>(arr,<span class="hljs-number">0</span>,--heapSize);<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a><strong>桶排序</strong></h4><ul><li>把序列分成若干个桶，每个元素放到对应桶里，每个桶进行排序，对所有桶进行整合。后一个桶内所有元素其实大于前面桶内所有元素。<br>桶的数量&#x3D;（最大值-最小值）&#x2F;数组长度+1<br>元素位置&#x3D;（元素大小-最小值）&#x2F;数组长度</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">bucketSort</span>(<span class="hljs-params">arr</span>)&#123;<br>    <span class="hljs-keyword">let</span> max = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(...arr);<br>    <span class="hljs-keyword">let</span> min = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(...arr);<br>    <span class="hljs-keyword">let</span> bucketNum = <span class="hljs-built_in">parseInt</span>((max-min)/arr.<span class="hljs-property">length</span>)+<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">let</span> bucketArr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(bucketNum);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;bucketNum;i++)&#123;<br>        bucketArr[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>();<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i <span class="hljs-keyword">of</span> arr)&#123;<br>        <span class="hljs-keyword">let</span> num = <span class="hljs-built_in">parseInt</span>((i-min)/arr.<span class="hljs-property">length</span>);<br>        bucketArr[num].<span class="hljs-title function_">push</span>(i);<br>    &#125;<br>    <span class="hljs-comment">//放入桶完成</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i <span class="hljs-keyword">of</span> bucketArr)&#123;<br>        i.<span class="hljs-title function_">sort</span>();<br>    &#125;<br>    <span class="hljs-keyword">let</span> k=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;bucketArr.<span class="hljs-property">length</span>;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j=<span class="hljs-number">0</span>;j&lt;bucketArr[i].<span class="hljs-property">length</span>;j++)&#123;<br>            arr[k++]  =bucketArr[i][j];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a><strong>基数排序</strong></h4><ul><li>从个位开始，对每个数进行分类装桶（0,1,2…9）。然后根据排序后的序列再根据十位装桶，以此类推。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">radixSort</span>(<span class="hljs-params">arr</span>)&#123;<br>    <span class="hljs-keyword">let</span> length = arr.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">if</span>(!<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(arr)||length&lt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">let</span> loop = (<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(arr) + <span class="hljs-string">&#x27;&#x27;</span>).<span class="hljs-property">length</span>;  <span class="hljs-comment">//最大数的位数</span><br>    <span class="hljs-keyword">let</span> bucket = [];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)&#123;<br>        bucket[i] = [];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;loop;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j=<span class="hljs-number">0</span>;j&lt;length;j++)&#123;<br>            <span class="hljs-keyword">let</span> str = arr[j]+<span class="hljs-string">&#x27;&#x27;</span>;<br>            <span class="hljs-keyword">if</span>(str.<span class="hljs-property">length</span>&gt;=i+<span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">let</span> k = <span class="hljs-built_in">parseInt</span>(str[str.<span class="hljs-property">length</span>-<span class="hljs-number">1</span>-i]);<br>                bucket[k].<span class="hljs-title function_">push</span>(array[j]);<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                bucket[<span class="hljs-number">0</span>].<span class="hljs-title function_">push</span>(array[j]);<br>            &#125;<br>        &#125;<br>        arr..<span class="hljs-title function_">splice</span>(<span class="hljs-number">0</span>,length);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)&#123;<br>            array.<span class="hljs-title function_">concat</span>(bucket[i]);<br>            bucket[i] = [];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a><strong>计数排序</strong></h4><ul><li>直接记录从min到max每个数出现的频率，然后直接一个个按数量打印。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">countingSort</span>(<span class="hljs-params">arr</span>)&#123;<br>    <span class="hljs-keyword">let</span> tmp = [];<br>    <span class="hljs-keyword">let</span> result = [];<br>    <span class="hljs-keyword">let</span> len = arr.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>        <span class="hljs-keyword">if</span>(!(tmp[arr[i]]&gt;-<span class="hljs-number">1</span>))&#123;<br>            tmp[arr[i]] = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            tmp[arr[i]]++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">let</span> k =<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(tmp);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j=<span class="hljs-number">0</span>;j&lt;k.<span class="hljs-property">length</span>;j++)&#123;<br>        <span class="hljs-keyword">while</span>(tmp[k[j]]--)&#123;<br>            result.<span class="hljs-title function_">push</span>(<span class="hljs-built_in">parseInt</span>(k[j]));<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>传输层（TCP+UDP)</title>
    <link href="/2022/05/11/%E4%BC%A0%E8%BE%93%E5%B1%82/"/>
    <url>/2022/05/11/%E4%BC%A0%E8%BE%93%E5%B1%82/</url>
    
    <content type="html"><![CDATA[<h2 id="一、TCP报文头部结构标志位"><a href="#一、TCP报文头部结构标志位" class="headerlink" title="一、TCP报文头部结构标志位"></a>一、TCP报文头部结构标志位</h2><ul><li>急迫标识PSH：表明请求远地TCP报文将本报文段立即传送给其应用层，而不要等到全部缓存都填满了之后再向上交付（接受报文）。</li><li>复位标识ReSeT：表明出现严重错误，必须释放连接，然后再重建传输连接。还用来拒接一个不法的报文段或拒绝打开一个连接。</li><li>确认标识ACK：确认序号字段有意义。</li><li>紧急标识URGent：表明此报文段应尽快传送，而不要按本来的队列次序来传送。</li><li>同步标识SYN：在建立连接时使用。SYN&#x3D;1且ACK&#x3D;0时，表明这是一个连接请求报文段。对方若同意建立连接，在回复的报文段中使用SYN&#x3D;1和ACK&#x3D;1.</li><li>终止标识FINal：用来释放一个连接，当FIN&#x3D;1时，表明欲发送的字节已经发送完，并请求释放传输连接。</li></ul><h2 id="★二、TCP的三次握手四次挥手"><a href="#★二、TCP的三次握手四次挥手" class="headerlink" title="★二、TCP的三次握手四次挥手"></a>★二、TCP的三次握手四次挥手</h2><img src="/2022/05/11/%E4%BC%A0%E8%BE%93%E5%B1%82/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png" class="" title="三次握手"> <ul><li><p>一开始，客户端和服务端都处于CLOSED状态。先是服务端主动监听某个端口，处于LISTEN状态。</p></li><li><p>客户端发送SYN包(SYN&#x3D;1,seq&#x3D;x)至服务端，并处于SYN_SENT状态，等待服务器确认。。</p></li><li><p>服务端解析SYN，并发送SYN+ACK包(SYN&#x3D;1,ACK&#x3D;x+1,seq&#x3D;y)至客户端，并处于SYN_RECV状态，允许建立连接。（告诉服务器已经做好准备，可以发送数据）</p></li><li><p>客户端获取SYN+ACK并发送ACK包(ACK&#x3D;y+1,seq&#x3D;z)包至服务端，连接建立成功，即将发送数据。这次握手可以包含数据，通过快速打开（TFO）技术就可以实现这一功能。只要涉及到握手的协议，都可以使用类似TFO的方式，客户端和服务端存储相同的cookie，下次握手时发出cookie达到减少RTT的目的。</p><img src="/2022/05/11/%E4%BC%A0%E8%BE%93%E5%B1%82/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png" class="" title="四次挥手"> </li><li><p>客户端打算关闭连接，此时会发送一个TCP首部FIN标志位置为1的报文，即FIN报文，之后客户端进入FIN_WAIT_1状态。。</p></li><li><p>服务器收到该报文后，就向客户端发送ACK应答报文（FIN+1），接着服务器进入CLOSED_WAIT状态。此时服务端不再接收客户端发送的数据，但仍可以向客户端发送数据</p></li><li><p>客户端收到服务端的ACK应答报文后，进入FIN_WAIT_2状态。</p></li><li><p>等待服务端处理完数据后，也向客户端发送FIN报文，之后服务端进入LAST_ACK状态。（告诉客户端响应报文发送完毕）</p></li><li><p>客户端收到服务端的FIN报文后，回一个ACK应答报文，之后进入TIME_WAIT状态。</p></li><li><p>服务器收到ACK应答报文后，就进入了CLOSED状态，至此服务端已经完成连接的关闭。</p></li><li><p>客户端在经过2MSL时间后，自动进入CLOSED状态，至此客户端也完成连接的关闭。</p></li></ul><h2 id="三、为什么必须是三次握手"><a href="#三、为什么必须是三次握手" class="headerlink" title="三、为什么必须是三次握手"></a>三、为什么必须是三次握手</h2><p>如果没有第三次握手，就会出现一些丢包的情况，如果只握手 2 次，第二次握手时如果服务端发给客户端的确认报文段丢失，此时服务端已经准备好了收发数(可以理解服务端已经连接成功)据，而客户端一直没收到服务端的确认报文，所以客户端就不知道服务端是否已经准备好了(可以理解为客户端未连接成功)，这种情况下客户端不会给服务端发数据，也会忽略服务端发过来的数据。如果是三次握手，即便发生丢包也不会有问题，比如如果第三次握手客户端发的确认 ack 报文丢失，服务端在一段时间内没有收到确认 ack 报文的话就会重新进行第二次握手，也就是服务端会重发 SYN 报文段，客户端收到重发的报文段后会再次给服务端发送确认 ack 报文。</p><h2 id="四、TCP和UDP区别"><a href="#四、TCP和UDP区别" class="headerlink" title="四、TCP和UDP区别"></a>四、TCP和UDP区别</h2><ul><li>连接：TCP是面向连接的传输层协议，传输数据前需要先建立连接。UDP是不需要连接，即刻传输数据。</li><li>服务对象：TCP是一对一的两点服务，一条连接只有两个端点。UDP支持一对一、一对多、多对多的交互通信。</li><li>可靠性：TCP是可靠交付数据的，数据可以无差错、不丢失、不重复、按需到达。UDP是尽最大努力交付，不保证可靠交付数据。</li><li>拥塞控制、流量控制：TCP有拥塞控制和流量控制机制，保证数据传输的安全性。UDP没有，即使网络拥堵，也不会影响UDP的发送速率。</li><li>首部开销：TCP首部长度较长，会有一定开销。UDP首部只有8个字节，并且是固定不变的，开销较小。</li><li>传输方式：TCP是流式传输，没有边界，但保证顺序和可靠。UDP是一个包一个包的发送，是有边界的，但可能会丢包和乱序。</li><li>分片不同：TCP数据大小如果大于MSS大小，则会在传输层进行分片，目标主机收到后也同样在传输层组装TCP数据报，如果中途丢失一个分片，只需要传输丢失的分片。UDP的数据大小如果大于MTU大小，则会在IP层进行分片，目标主机收到后在IP层组装数据，接着再传给传输层，如果中途丢失一个分片，在实现可靠传输的UDP时需要重传所有的数据包。<h2 id="五、TCP和UDP应用场景"><a href="#五、TCP和UDP应用场景" class="headerlink" title="五、TCP和UDP应用场景"></a>五、TCP和UDP应用场景</h2></li><li>TCP：面向连接，能保证数据的可靠性交付，常用于FTP文件传输、HTTP&#x2F;HTTPS。效率要求相对较低，但对准确性要求相对较高的场景，例如文件传输、远程登录。</li><li>UDP：面向无连接，可以随时发送数据，本身处理简单高效，常用于包总量较少的通信，如DNS、SNMP等、视频、音频等多媒体通信，广播通信。效率要求相对较高，对准确性要求相对较低的场景。例如：聊天、在线视频、网络电话。</li></ul><h2 id="六、为什么客户端要进入TIME-WAIT状态，等待2MSL时间之后才进入CLOSED状态"><a href="#六、为什么客户端要进入TIME-WAIT状态，等待2MSL时间之后才进入CLOSED状态" class="headerlink" title="六、为什么客户端要进入TIME-WAIT状态，等待2MSL时间之后才进入CLOSED状态"></a>六、为什么客户端要进入TIME-WAIT状态，等待2MSL时间之后才进入CLOSED状态</h2><p>为了保证服务端能收到客户端的确认应答，实现TCP全双工连接的可靠释放。如果客服端发完确认应答后直接进入CLOSED状态，如果确认应答因为网络问题一直没有到达，那么会造成服务器不能正常关闭。这样可以让TCP再次发送最后的ACK以防止这个ACK丢失（服务超时并重发最后的FIN）。这种2MSL等待的另一个结果是这个TCP连接在2MSL等待期间，定义这个连接的插口（客户端的IP地址和端口号、服务器的IP地址和端口号）不能再被使用，只有在等待2MSL之后才能再次连接使用。<br>MSL是Maximum Segment Lifetime，也就是报文最大生存时间。它是任何报文段被丢弃前在网络内的最长时间。2MSL主动关闭的一方将继续等待一定时间，使两端的应用程序结束。</p><h2 id="七、为什么建立连接是三次握手，关闭连接是四次挥手"><a href="#七、为什么建立连接是三次握手，关闭连接是四次挥手" class="headerlink" title="七、为什么建立连接是三次握手，关闭连接是四次挥手"></a>七、为什么建立连接是三次握手，关闭连接是四次挥手</h2><p>建立连接时，因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。<br>关闭连接是，当收到对方的FIN报文时，仅仅表示客户端不再发送数据但还能接收数据，服务也未必把全部数据都发给了客户端，因此服务端可以立即close，也可以发送一些数据给对方后，再发送FIN报文交给对方表示同意关闭连接，因此ACK和FIN通常会分开发送。</p><h2 id="八、TCP协议如何保证可靠传输"><a href="#八、TCP协议如何保证可靠传输" class="headerlink" title="八、TCP协议如何保证可靠传输"></a>八、TCP协议如何保证可靠传输</h2><ul><li><strong>校验和</strong>：TCP将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何滨化。如果收到端的检验和有差错，TCP将丢弃这个报文段和确认收到此报文段。</li><li><strong>确认应答+序列号（累积确认+seq）</strong>：接收方收到报文就会确认（累积确认：对所有按序接收的数据的确认），TCP给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层，TCP的接收端会丢弃重复的数据。</li><li><strong>流量控制</strong>：TCP连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的频率，防止包丢失。TCP使用的流量控制协议是可改变大小的滑动窗口协议。<br>  TCP是每发送一个数据，都要进行一次确认应答。当上一个数据包收到了应答了，再发送下一个。缺点是效率比较低，数据包的往返时间越长，通信效率就越低。<br>  为解决这个问题，TCP引入窗口这个概念，即使在往返时间较长的情况下，它也不会降低网络通信的效率。有了窗口，就可以指定窗口大小，窗口大小就是指无需等待确认应答，而可以继续发送数据的最大值。<br>  窗口的实现实际上是操作系统开辟的一个缓存空间，发送方主机在等到确认应答返回之前，必须在缓冲区保留已发送的数据，如果按期收到确认应答，此时数据就可以从缓存区清除。<br>  窗口大小由什么来确定？TCP头里有一个字段叫做window，即窗口大小，这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。所以，通常窗口的大小是由接收方的窗口大小来决定的，发送方发送的数据大小不能超过接收方的窗口大小，否则接收方就无法正常收到数据。<br>  TCP滑动窗口方案使用三个指针来跟踪在四个传输类别中的每一个类别中的字节。其中两个指针是绝对指针（指特定的序列号），另一个是相对指针（需要做偏移）。<br>SND.WND：表示发送窗口的大小（大小是由接收方指定的）<br>SND.UNA：是一个绝对指针，它指向的是已发送但未确认收到的第一个字节的序列号，也就是#2的第一个字节。<br>SND.NXT：也是一个绝对指针，它指向未发送但可发送范围的第一个字节的序列号，也就是#3的第一个字节。指向#4的第一个字节是相对指针，它需要SND.UNA指针加上SND.WND大小的偏移，就可以指向#4的第一个字节了。<br><strong>可用窗口大小</strong>&#x3D;SND.NXT-SND.UNA。<br>RCV.WND：表示接收窗口的大小，它会通告给发送方。<br>RCV.NXT：是一个指针，它指向期望从发送方来的下一个数据字节的序列号，也就是#3的第一个字节。指向#4的第一个字节是个相对指针，它需要RCV.NXT指针加上RCV.WND大小的偏移，就可以指向#4的第一个字节了。<br><strong>接收窗口和发送窗口的大小并不是完全相等</strong>：接收窗口的大小是约等于发送窗口的大小。因为滑动窗口并不是一成不变的，比如，当接收方的应用进程读取数据的速度非常快的话，接收窗口可以很快的就空出来，那么新的接收窗口的大小是通过TCP报文中的windows字段来告诉发送方。那么这个传输过程是存在时延的，所以接收窗口和发送窗口是约等于的关系。</li><li><strong>拥塞控制</strong>：当网络拥塞时，减少数据的发送。</li><li><strong>停止等待协议</strong>：基本原理是每发送完一个分组就停止发送，等待对方确认，在收到确认后再发送下一个分组。</li><li><strong>超时重传</strong>：当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。<br>ARQ协议也就是超时重传机制，通过确认和超时机制保证了数据的正确送达，ARQ协议包含停止等待ARQ和连续ARQ两种协议。</li></ul><h2 id="九、TCP-和-UDP的概念及特点"><a href="#九、TCP-和-UDP的概念及特点" class="headerlink" title="九、TCP 和 UDP的概念及特点"></a>九、TCP 和 UDP的概念及特点</h2><p>TCP 和 UDP都是传输层协议，他们都属于TCP&#x2F;IP协议族：</p><h3 id="9-1-UDP"><a href="#9-1-UDP" class="headerlink" title="9.1 UDP"></a>9.1 UDP</h3><p>UDP的全称是<strong>用户数据报协议</strong>，在网络中它与TCP协议一样用于处理数据包，是一种无连接的协议。在OSI模型中，在传输层，处于IP协议的上一层。UDP有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。<br>它的特点如下：<br><strong>1）面向无连接</strong><br>不需要进行三次握手建立连接的，想发数据就可以开始发送了。只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作。</p><ul><li>在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了</li><li>在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作<br><strong>2）有单播，多播，广播的功能</strong><br>不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式， 提供了单播，多播，广播的功能。<br><strong>3）面向报文</strong><br>发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。因此，应用程序必须选择合适大小的报文<br><strong>4）不可靠性</strong><br>首先不可靠性体现在无连接上，通信不需要建立连接，想发就发。<br>收到什么数据就传递什么数据，不会备份数据，发送数据也不会关心对方是否已经正确接收到数据了。<br>再者网络环境时好时坏，但是 UDP 因为没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP。<br><strong>5）头部开销小，传输数据报文时是很高效的。</strong><br>UDP 头部包含了以下几个数据：</li><li>两个十六位的端口号，分别为源端口（可选字段）和目标端口</li><li>整个数据报文的长度</li><li>整个数据报文的检验和（IPv4 可选字段），该字段用于发现头部信息和数据中的错误<br>因此 UDP 的头部开销小，只有8字节，相比 TCP 的至少20字节要少得多，在传输数据报文时是很高效的。<h3 id="9-2-TCP"><a href="#9-2-TCP" class="headerlink" title="9.2 TCP"></a>9.2 TCP</h3>TCP的全称是传输控制协议是一种面向连接的、可靠的、基于字节流的传输层通信协议。TCP 是面向连接的、可靠的流协议（流就是指不间断的数据结构）。<br>它有以下几个特点：<br><strong>1）面向连接</strong><br>面向连接，是指发送数据之前必须在两端建立连接。建立连接的方法是“三次握手”，这样能建立可靠的连接。建立连接，是为数据的可靠传输打下了基础。<br><strong>2）仅支持单播传输</strong><br>每条TCP传输连接只能有两个端点，只能进行点对点的数据传输，不支持多播和广播传输方式。<br><strong>3）面向字节流</strong><br>TCP不像UDP一样那样一个个报文独立地传输，而是在不保留报文边界的情况下以字节流方式进行传输。<br><strong>4）可靠传输</strong><br>对于可靠传输，判断丢包、误码靠的是TCP的段编号以及确认号。TCP为了保证报文传输的可靠，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的字节发回一个相应的确认(ACK)；如果发送端实体在合理的往返时延(RTT)内未收到确认，那么对应的数据（假设丢失了）将会被重传。<br><strong>5）提供拥塞控制</strong><br>当网络出现拥塞的时候，TCP能够减小向网络注入数据的速率和数量，缓解拥塞。<br><strong>6）提供全双工通信</strong><br>TCP允许通信双方的应用程序在任何时候都能发送数据，因为TCP连接的两端都设有缓存，用来临时存放双向通信的数据。当然，TCP可以立即发送一个数据段，也可以缓存一段时间以便一次发送更多的数据段（最大的数据段大小取决于MSS）<h2 id="十、UDP协议为什么不可靠？"><a href="#十、UDP协议为什么不可靠？" class="headerlink" title="十、UDP协议为什么不可靠？"></a>十、UDP协议为什么不可靠？</h2>UDP在传输数据之前不需要先建立连接，远地主机的运输层在接收到UDP报文后，不需要确认，提供不可靠交付。总结就以下四点：</li><li>不保证消息交付：不确认，不重传，无超时</li><li>不保证交付顺序：不设置包序号，不重排，不会发生队首阻塞</li><li>不跟踪连接状态：不必建立连接或重启状态机</li><li>不进行拥塞控制：不内置客户端或网络反馈机制<h2 id="十一、TCP的重传机制"><a href="#十一、TCP的重传机制" class="headerlink" title="十一、TCP的重传机制"></a>十一、TCP的重传机制</h2>由于TCP的下层网络（网络层）可能出现<strong>丢失、重复或失序</strong>的情况，TCP协议提供可靠数据传输服务。为保证数据传输的正确性，TCP会重传其认为已丢失（包括报文中的比特错误）的包。TCP使用两套独立的机制来完成重传，一是<strong>基于时间</strong>，二是<strong>基于确认信息</strong>。<br>TCP在发送一个数据之后，就开启一个定时器，若是在这个时间内没有收到发送数据的ACK确认报文，则对该报文进行重传，在达到一定次数还没有成功时放弃并发送一个复位信号。<h2 id="十二、TCP的拥塞控制机制"><a href="#十二、TCP的拥塞控制机制" class="headerlink" title="十二、TCP的拥塞控制机制"></a>十二、TCP的拥塞控制机制</h2>TCP的拥塞控制机制主要是以下四种机制：<br>慢启动（慢开始）、拥塞避免、快速重传、快速恢复<h3 id="12-1-慢启动（慢开始）"><a href="#12-1-慢启动（慢开始）" class="headerlink" title="12.1 慢启动（慢开始）"></a>12.1 慢启动（慢开始）</h3></li><li>在开始发送的时候设置拥塞窗口 &#x3D; 1</li><li>思路：开始的时候不要发送大量数据，而是先测试一下网络的拥塞程度，由小到大增加拥塞窗口的大小。</li><li>为了防止拥塞窗口增长过大引起网络拥塞，设置一个慢开始门限(ssthresh 状态变量)<ul><li>当cnwd &lt; ssthresh，使用慢开始算法，每过一个RTT窗口大小乘二。</li><li>当cnwd &#x3D; ssthresh，既可使用慢开始算法，也可以使用拥塞避免算法</li><li>当cnwd &gt; ssthresh，使用拥塞避免算法<h3 id="12-2-拥塞避免"><a href="#12-2-拥塞避免" class="headerlink" title="12.2 拥塞避免"></a>12.2 拥塞避免</h3></li></ul></li><li>拥塞避免未必能够完全避免拥塞，是说在拥塞避免阶段将拥塞窗口控制为按线性增长，使网络不容易出现阻塞。</li><li>思路： 让拥塞窗口cwnd缓慢的增大，每经过一个RTT就把发送方的拥塞控制窗口加一。</li><li>无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞，就把慢开始门限（阈值）设置为出现拥塞时的发送窗口大小的一半。然后把拥塞窗口设置为1，执行慢开始算法。其中，判断网络出现拥塞的根据就是没有收到确认，虽然没有收到确认可能是其他原因的分组丢失，但是因为无法判定，所以都当做拥塞来处理。<h3 id="12-3-快速重传"><a href="#12-3-快速重传" class="headerlink" title="12.3 快速重传"></a>12.3 快速重传</h3>快速重传一般和快恢复一起出现。一旦接收端收到的报文出现失序的情况，接收端只会回复最后一个顺序正确的报文序号。如果发送端收到三个重复的 ACK，无需等待定时器超时而是直接启动快速重传算法。具体算法分为两种：<br>TCP Taho 实现如下：</li></ul><ol><li>将阈值设为当前拥塞窗口的一半</li><li>将拥塞窗口设为 1 MSS</li><li>重新开始慢开始算法<br>TCP Reno 实现如下：</li><li>拥塞窗口减半</li><li>将阈值设为当前拥塞窗口</li><li>进入快恢复阶段（重发对端需要的包，一旦收到一个新的 ACK 答复就退出该阶段，这种方式在丢失多个包的情况下就不那么好了</li><li>使用拥塞避免算法<h3 id="12-4-快速恢复"><a href="#12-4-快速恢复" class="headerlink" title="12.4 快速恢复"></a>12.4 快速恢复</h3></li></ol><ul><li>当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半。但是接下去并不执行慢开始算法。</li><li>考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将cwnd设置为ssthresh的大小，然后执行拥塞避免算法。<h2 id="十三、TCP粘包是怎么回事，如何处理"><a href="#十三、TCP粘包是怎么回事，如何处理" class="headerlink" title="十三、TCP粘包是怎么回事，如何处理?"></a>十三、TCP粘包是怎么回事，如何处理?</h2>默认情况下, TCP 连接会启⽤延迟传送算法 (Nagle 算法), 在数据发送之前缓存他们. 如果短时间有多个数据发送, 会缓冲到⼀起作⼀次发送，这样可以减少 IO 消耗提⾼性能。<br>如果是传输⽂件的话, 那么根本不⽤处理粘包的问题, 来⼀个包拼⼀个包就好了。但是如果是多条消息, 或者是别的⽤途的数据那么就需要处理粘包。<br>下面看⼀个例⼦, 连续调⽤两次 send 分别发送两段数据 data1 和 data2, 在接收端有以下⼏种常⻅的情况: A. 先接收到 data1, 然后接收到 data2 . B. 先接收到 data1 的部分数据, 然后接收到 data1 余下的部分以及 data2 的全部. C. 先接收到了 data1 的全部数据和 data2 的部分数据, 然后接收到了 data2 的余下的数据. D. ⼀次性接收到了 data1 和 data2 的全部数据.<br>其中的 BCD 就是我们常⻅的粘包的情况. ⽽对于处理粘包的问题, 常⻅的解决⽅案有:</li><li><strong>多次发送之前间隔⼀个等待时间</strong>：只需要等上⼀段时间再进⾏下⼀次 send 就好, 适⽤于交互频率特别低的场景. 缺点也很明显, 对于⽐较频繁的场景⽽⾔传输效率实在太低，不过⼏乎不⽤做什么处理.</li><li><strong>关闭 Nagle 算法</strong>：关闭 Nagle 算法, 在 Node.js 中你可以通过 socket.setNoDelay() ⽅法来关闭 Nagle 算法, 让每⼀次 send 都不缓冲直接发送。该⽅法⽐较适⽤于每次发送的数据都⽐较⼤ (但不是⽂件那么⼤), 并且频率不是特别⾼的场景。如果是每次发送的数据量⽐较⼩, 并且频率特别⾼的, 关闭 Nagle 纯属⾃废武功。另外, 该⽅法不适⽤于⽹络较差的情况, 因为 Nagle 算法是在服务端进⾏的包合并情况, 但是如果短时间内客户端的⽹络情况不好, 或者应⽤层由于某些原因不能及时将 TCP 的数据 recv, 就会造成多个包在客户端缓冲从⽽粘包的情况。 (如果是在稳定的机房内部通信那么这个概率是⽐较⼩可以选择忽略的)</li><li><strong>进⾏封包&#x2F;拆包：</strong> 封包&#x2F;拆包是⽬前业内常⻅的解决⽅案了。即给每个数据包在发送之前, 于其前&#x2F;后放⼀些有特征的数据, 然后收到数据的时 候根据特征数据分割出来各个数据包。<h2 id="十四、为什么UDP不会粘包？"><a href="#十四、为什么UDP不会粘包？" class="headerlink" title="十四、为什么UDP不会粘包？"></a>十四、为什么UDP不会粘包？</h2></li><li>TCP协议是⾯向流的协议，UDP是⾯向消息的协议。UDP段都是⼀条消息，应⽤程序必须以消息为单位提取数据，不能⼀次提取任意字节的数据</li><li>UDP具有保护消息边界，在每个UDP包中就有了消息头（消息来源地址，端⼝等信息），这样对于接收端来说就容易进⾏区分处理了。传输协议把数据当作⼀条独⽴的消息在⽹上传输，接收端只能接收独⽴的消息。接收端⼀次只能接收发送端发出的⼀个数据包,如果⼀次接受数据的⼤⼩⼩于发送端⼀次发送的数据⼤⼩，就会丢失⼀部分数据，即使丢失，接受端也不会分两次去接收。</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
