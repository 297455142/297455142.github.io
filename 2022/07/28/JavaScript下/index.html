

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="WBY">
  <meta name="keywords" content="">
  
    <meta name="description" content="四、类、对象和作用域一、 原型和原型链在JavaScript中是使用构造函数来新建一个对象的，每一个构造函数的内部都有一个 prototype 属性（原型对象，构造函数独有），它的属性值是一个对象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法。当使用构造函数新建一个对象后，在这个对象的内部将包含一个指针，这个指针指向构造函数的 prototype 属性对应的值，在 ES5 中这个指针被">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaScript下">
<meta property="og:url" content="http://example.com/2022/07/28/JavaScript%E4%B8%8B/index.html">
<meta property="og:site_name" content="前端面试总结">
<meta property="og:description" content="四、类、对象和作用域一、 原型和原型链在JavaScript中是使用构造函数来新建一个对象的，每一个构造函数的内部都有一个 prototype 属性（原型对象，构造函数独有），它的属性值是一个对象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法。当使用构造函数新建一个对象后，在这个对象的内部将包含一个指针，这个指针指向构造函数的 prototype 属性对应的值，在 ES5 中这个指针被">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-07-28T04:46:10.000Z">
<meta property="article:modified_time" content="2022-09-23T17:19:06.809Z">
<meta property="article:author" content="WBY">
<meta property="article:tag" content="原创">
<meta name="twitter:card" content="summary_large_image">
  
  
  <title>JavaScript下 - 前端面试总结</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"sOHs1UX9yhu45mOPqVuIjOkh-gzGzoHsz","app_key":"JlU9ppAdc6X2IEPeXLgdlFGc","server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.1.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>前端面试总结</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="JavaScript下">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-07-28 12:46" pubdate>
        2022年7月28日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      36k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      297 分钟
    </span>
  

  
  
    
      <!-- LeanCloud 统计文章PV -->
      <span id="leancloud-page-views-container" class="post-meta" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="leancloud-page-views"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">JavaScript下</h1>
            
            <div class="markdown-body">
              <h1 id="四、类、对象和作用域"><a href="#四、类、对象和作用域" class="headerlink" title="四、类、对象和作用域"></a>四、类、对象和作用域</h1><h2 id="一、-原型和原型链"><a href="#一、-原型和原型链" class="headerlink" title="一、 原型和原型链"></a>一、 原型和原型链</h2><p>在JavaScript中是使用构造函数来新建一个对象的，<strong>每一个构造函数的内部都有一个 prototype 属性（原型对象，构造函数独有），它的属性值是一个对象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法</strong>。当使用构造函数<strong>新建一个对象</strong>后，在这个对象的内部将包含一个指针，这个指针指向<strong>构造函数的 prototype 属性对应的值</strong>，在 ES5 中这个指针被称为对象的原型。一般来说不应该能够获取到这个值的，但是现在浏览器中都实现了 <strong>proto属性</strong>来访问这个属性，但是最好不要使用这个属性，因为它不是规范中规定的。ES5 中新增了一个 Object.getPrototypeOf() 方法，可以通过这个方法来获取对象的原型。<br><strong>当访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去，也就是原型链的概念</strong>。原型链的尽头一般来说都是 Object.prototype 所以这就是新建的对象为什么能够使用 toString() 等方法的原因。<br><strong>特点：</strong> JavaScript 对象是通过引用来传递的，创建的每个新对象实体中并没有一份属于自己的原型副本。当修改原型时，与之相关的对象也会继承这一改变。</p>
<h2 id="二、原型的修改、重写"><a href="#二、原型的修改、重写" class="headerlink" title="二、原型的修改、重写"></a>二、原型的修改、重写</h2><p><strong>p.constructor就是对象的构造函数Person</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>&#125;<br><span class="hljs-comment">// 修改原型</span><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;&#125;<br><span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;hello&#x27;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>) <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-property">__proto__</span> === p.<span class="hljs-property">constructor</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>) <span class="hljs-comment">// true</span><br><span class="hljs-comment">// p.constructor就是对象的构造函数Person</span><br><span class="hljs-comment">// 重写原型</span><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = &#123;<br>    <span class="hljs-attr">getName</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;&#125;<br>&#125;<br><span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;hello&#x27;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>)        <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-property">__proto__</span> === p.<span class="hljs-property">constructor</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>) <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure>
<p>可以看到修改原型的时候p的构造函数不是指向Person了，因为直接给Person的原型对象直接用对象赋值时，它的构造函数指向的了根构造函数Object，所以这时候p.constructor &#x3D;&#x3D;&#x3D; Object ，而不是p.constructor &#x3D;&#x3D;&#x3D; Person。要想成立，就要用constructor指回来：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = &#123;<br>    <span class="hljs-attr">getName</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;&#125;<br>&#125;<br><span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;hello&#x27;</span>)<br>p.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Person</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>)        <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-property">__proto__</span> === p.<span class="hljs-property">constructor</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>
<h2 id="三、原型链的指向"><a href="#三、原型链的指向" class="headerlink" title="三、原型链的指向"></a>三、原型链的指向</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>()<br>p.<span class="hljs-property">__proto__</span>  <span class="hljs-comment">// Person.prototype</span><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">__proto__</span>  <span class="hljs-comment">// Object.prototype</span><br>p.<span class="hljs-property">__proto__</span>.<span class="hljs-property">__proto__</span> <span class="hljs-comment">//Object.prototype</span><br>p.<span class="hljs-property">__proto__</span>.<span class="hljs-property">constructor</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">__proto__</span> <span class="hljs-comment">// Object.prototype</span><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">__proto__</span> <span class="hljs-comment">// Object.prototype</span><br>p1.<span class="hljs-property">__proto__</span>.<span class="hljs-property">constructor</span> <span class="hljs-comment">// Person</span><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span>  <span class="hljs-comment">// Person</span><br></code></pre></td></tr></table></figure>
<p>由于Object是构造函数，原型链终点是Object.prototype.__proto__，而Object.prototype.<strong>proto</strong>&#x3D;&#x3D;&#x3D; null &#x2F;&#x2F; true，所以，原型链的终点是null。原型链上的所有原型都是对象，所有的对象最终都是由Object构造的，而Object.prototype的下一级是Object.prototype.__proto__。 </p>
<h2 id="四、获得对象非原型链上的属性"><a href="#四、获得对象非原型链上的属性" class="headerlink" title="四、获得对象非原型链上的属性"></a>四、获得对象非原型链上的属性</h2><p>使用后hasOwnProperty()方法来判断属性是否属于原型链的属性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">iterate</span>(<span class="hljs-params">obj</span>)&#123;<br>   <span class="hljs-keyword">var</span> res=[];<br>   <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> obj)&#123;<br>        <span class="hljs-keyword">if</span>(obj.<span class="hljs-title function_">hasOwnProperty</span>(key))<br>           res.<span class="hljs-title function_">push</span>(key+<span class="hljs-string">&#x27;: &#x27;</span>+obj[key]);<br>   &#125;<br>   <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="★五、对this的理解-apply-call-bind区别"><a href="#★五、对this的理解-apply-call-bind区别" class="headerlink" title="★五、对this的理解(apply,call,bind区别)"></a>★五、对this的理解(apply,call,bind区别)</h2><p>this 是执行上下文中的一个属性，它指向最后一次调用这个方法的对象。在实际开发中，this 的指向可以通过四种调用模式来判断。</p>
<ul>
<li>第一种是<strong>函数调用模式</strong>，当一个函数不是一个对象的属性时，直接作为函数来调用时，this 指向全局对象。  </li>
<li>第二种是<strong>方法调用模式</strong>，如果一个函数作为一个对象的方法来调用时，this 指向这个对象。</li>
<li>第三种是<strong>构造器调用模式</strong>，如果一个函数用new调用时（构造函数），函数执行前会新创建一个对象，函数里的this指向这个新创建的对象。</li>
<li>第四种是 <strong>apply 、 call和bind 调用模式</strong>，这三个方法都可以显示的指定调用函数的 this 指向。<strong>apply方法</strong>接收两个参数：一个是this绑定的对象，一个是<strong>参数数组</strong>。<strong>call方法</strong>接收的参数，第一个是this绑定的对象，后面的其余参数是传入函数执行的参数，和apply区别是<strong>传入的参数数量不固定</strong>。在使用 call() 方法时，传递给函数的参数必须逐个列举出来。bind方法通过传入一个对象，返回一个this绑定了传入对象的新函数，<strong>和call区别是生成一个新函数</strong>。这个函数的this指向除了使用new时会被改变，其他情况下都不会改变。<br>这四种方式，使用构造器调用模式的优先级最高，然后是 apply、call 和 bind 调用模式，然后是方法调用模式，然后是函数调用模式。<h2 id="六、实现call、apply和bind"><a href="#六、实现call、apply和bind" class="headerlink" title="六、实现call、apply和bind"></a>六、实现call、apply和bind</h2><h3 id="6-1-call"><a href="#6-1-call" class="headerlink" title="6.1 call"></a>6.1 call</h3></li>
<li>判断调用对象是否为函数，即使是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li>
<li>判断传入上下文对象是否存在，如果不存在，则设置为 window 。</li>
<li>处理传入的参数，截取第一个参数后的所有参数。</li>
<li>将函数作为上下文对象的一个属性。</li>
<li>使用上下文对象来调用这个方法，并保存返回结果。</li>
<li>删除刚才新增的属性。</li>
<li>返回结果。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myCall</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">context</span>) &#123;<br>  <span class="hljs-comment">// 判断调用对象</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">this</span> !== <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;type error&quot;</span>);<br>  &#125;<br>  <span class="hljs-comment">// 获取参数</span><br>  <span class="hljs-keyword">let</span> args = [...<span class="hljs-variable language_">arguments</span>].<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>),<br>    result = <span class="hljs-literal">null</span>;<br>  <span class="hljs-comment">// 判断 context 是否传入，如果未传入则设置为 window</span><br>  context = context || <span class="hljs-variable language_">window</span>;<br>  <span class="hljs-comment">// 将调用函数设为对象的方法</span><br>  context.<span class="hljs-property">fn</span> = <span class="hljs-variable language_">this</span>;<br>  <span class="hljs-comment">// 调用函数</span><br>  result = context.<span class="hljs-title function_">fn</span>(...args);<br>  <span class="hljs-comment">// 将属性删除</span><br>  <span class="hljs-keyword">delete</span> context.<span class="hljs-property">fn</span>;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="6-2-apply"><a href="#6-2-apply" class="headerlink" title="6.2 apply"></a>6.2 apply</h3></li>
<li>判断调用对象是否为函数，即使是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li>
<li>判断传入上下文对象是否存在，如果不存在，则设置为 window 。</li>
<li>将函数作为上下文对象的一个属性。</li>
<li>判断参数值是否传入</li>
<li>使用上下文对象来调用这个方法，并保存返回结果。</li>
<li>删除刚才新增的属性</li>
<li>返回结果<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myApply</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">context</span>) &#123;<br>  <span class="hljs-comment">// 判断调用对象是否为函数</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">this</span> !== <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&quot;Error&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">let</span> result = <span class="hljs-literal">null</span>;<br>  <span class="hljs-comment">// 判断 context 是否存在，如果未传入则为 window</span><br>  context = context || <span class="hljs-variable language_">window</span>;<br>  <span class="hljs-comment">// 将函数设为对象的方法</span><br>  context.<span class="hljs-property">fn</span> = <span class="hljs-variable language_">this</span>;<br>  <span class="hljs-comment">// 调用方法</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">arguments</span>[<span class="hljs-number">1</span>]) &#123;<br>    result = context.<span class="hljs-title function_">fn</span>(...<span class="hljs-variable language_">arguments</span>[<span class="hljs-number">1</span>]);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    result = context.<span class="hljs-title function_">fn</span>();<br>  &#125;<br>  <span class="hljs-comment">// 将属性删除</span><br>  <span class="hljs-keyword">delete</span> context.<span class="hljs-property">fn</span>;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="6-3-bind"><a href="#6-3-bind" class="headerlink" title="6.3 bind"></a>6.3 bind</h3></li>
<li>判断调用对象是否为函数，即使是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li>
<li>保存当前函数的引用，获取其余传入参数值。</li>
<li>创建一个函数返回</li>
<li>函数内部使用 apply 来绑定函数调用，需要判断函数作为构造函数的情况，这个时候需要传入当前函数的 this 给 apply 调用，其余情况都传入指定的上下文对象。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myBind</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">context</span>) &#123;<br><span class="hljs-comment">// 判断调用对象是否为函数</span><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">this</span> !== <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&quot;Error&quot;</span>);<br>&#125;<br><span class="hljs-comment">// 获取参数</span><br><span class="hljs-keyword">var</span> args = [...<span class="hljs-variable language_">arguments</span>].<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>),<br>  fn = <span class="hljs-variable language_">this</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Fn</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 根据调用方式，传入不同绑定值</span><br>  <span class="hljs-keyword">return</span> fn.<span class="hljs-title function_">apply</span>(<br>    <span class="hljs-variable language_">this</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Fn</span> ? <span class="hljs-variable language_">this</span> : context,<br>    args.<span class="hljs-title function_">concat</span>(...<span class="hljs-variable language_">arguments</span>)<br>  );<br>&#125;;<br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="七、对象创建的方式"><a href="#七、对象创建的方式" class="headerlink" title="七、对象创建的方式"></a>七、对象创建的方式</h2><ul>
<li>**{}**：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> o = &#123;&#125;<br>o.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;jack&#x27;</span><br>o.<span class="hljs-property">age</span> = <span class="hljs-number">20</span><br></code></pre></td></tr></table></figure></li>
<li><strong>工厂模式</strong>：使用函数来创建对象，问题是创建出来的对象无法与某个类型联系起来，只是简单封装了复用代码，没有建立起对象和和类型之间的关系。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createObject</span>(<span class="hljs-params">name</span>)&#123;<br>    <span class="hljs-keyword">var</span> o = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    o.<span class="hljs-property">name</span> = name;<br>    o.<span class="hljs-property">sayName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-title function_">alert</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>    &#125;;<br>    <span class="hljs-keyword">return</span> o;<br>&#125;<br><span class="hljs-keyword">var</span> o1 = <span class="hljs-title function_">createObject</span>(<span class="hljs-string">&#x27;zhang&#x27;</span>);<br></code></pre></td></tr></table></figure></li>
<li><strong>构造函数</strong>：js 中每一个函数都可以作为构造函数，只要一个函数是通过 new 来调用的，那么就可以把它称为构造函数。执行构造函数首先会创建一个对象，然后将对象的原型指向构造函数的prototype属性，然后将执行上下文中的this指向这个对象，最后再执行整个函数，如果返回值不是对象，则返回新建的对象。因为this的值指向了新建的对象，因此可以使用 this 给对象赋值。构造函数模式相对于工厂模式的优点是，所创建的对象和构造函数建立起了联系，因此可以通过原型来识别对象的类型。构造函数缺点就是，造成了不必要的函数对象的创建，因为在js中函数也是一个对象，因此如果对象属性中包含函数的话，那么每次都会新建一个函数对象，浪费了不必要的内存空间，因为函数是所有的实例都可以通用的。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><span class="hljs-keyword">var</span> p1  = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;zhang&#x27;</span>);<br></code></pre></td></tr></table></figure></li>
<li><strong>原型模型</strong>：每个方法都有一个原型prototype，每个原型都有一个构造器constructor，构造器指向这个方法。prototype属性，是一个对象，它包含了通过构造函数创建的所有实例都能共享的属性和方法。因此可以使用原型对象来添加公用属性和方法，从而实现代码的复用。这种方式相对于构造函数模式来说，解决了函数对象的复用问题。但是也存在一些问题，一是没有办法通过传入参数来初始化值，另一个是如果存在一个引用类型如Array这样的值，那么所有的实例将共享一个对象，一个实例对引用类型值的改变会影响所有的实例。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Animal</span>(<span class="hljs-params"></span>) &#123; &#125;<br><span class="hljs-title class_">Animal</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;animal&#x27;</span>;<br><span class="hljs-title class_">Animal</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayName</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123; <span class="hljs-title function_">alert</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>); &#125;;<br><span class="hljs-keyword">var</span> a1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>();<br></code></pre></td></tr></table></figure></li>
<li><strong>原型模式+构造函数模式</strong>：因为构造函数模式和原型模式分开使用都存在一些问题，因此可以组合使用这两种模式，通过构造函数来初始化对象的属性，通过原型对象来实现函数方法的复用。这种方法很好的解决了两种模式单独使用时的缺点，但是有一点不足的就是，因为使用了两种不同的模式，所以对于代码的封装性不够好。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Animal</span>(<span class="hljs-params">name</span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">friends</span> = [<span class="hljs-string">&#x27;cat&#x27;</span>, <span class="hljs-string">&#x27;dog&#x27;</span>];<br>&#125;<br><span class="hljs-title class_">Animal</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>&#125;;<br><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>(<span class="hljs-string">&#x27;d&#x27;</span>);<br></code></pre></td></tr></table></figure></li>
<li><strong>动态原型模式</strong>：仅在第一次调用构造函数时将方法赋给原型对象的相应属性，其它示例的处理方式同构造函数模式。</li>
<li><strong>寄生构造函数模式</strong>：仅仅封装创建对象的代码，然后再返回新创建的对象，仍使用new操作符调用。</li>
<li>**new Object()**：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> o = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>o.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;zhang&#x27;</span>;<br>o.<span class="hljs-property">sayName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><strong>使用字面量创建对象</strong>：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> person = &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;zhang&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">20</span>&#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="八、对象继承的方式"><a href="#八、对象继承的方式" class="headerlink" title="八、对象继承的方式"></a>八、对象继承的方式</h2><ul>
<li><strong>原型链继承</strong>：通过b函数的原型b.prototype指向a的实例来实现。存在引用值共享问题，当a中某个属性是引用数据类型的时候b实例如果修改了这个属性的内容则其他b实例中这个属性也会一起改变。创建子类型时不能向超类型传递参数。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">parent</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> = <span class="hljs-string">&#x27;111&#x27;</span>;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">child</span>(<span class="hljs-params"></span>)&#123;&#125;<br>child.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title function_">parent</span>();<br><span class="hljs-keyword">var</span> c = <span class="hljs-keyword">new</span> <span class="hljs-title function_">child</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(c.<span class="hljs-property">a</span>) <span class="hljs-comment">// 111</span><br></code></pre></td></tr></table></figure></li>
<li><strong>构造函数继承</strong>：通过在b函数中独立执行a，在子类型的函数中调用超类型的构造函数，此时a的this指向window，通过call方法改变a的指向指向b实例。这样解决了不能向超类型传递参数的缺点，但是存在问题是无法实现函数方法的复用，同时子类型的实例没有办法拿到超类型原型上的属性和方法。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">parent</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> = <span class="hljs-string">&#x27;111&#x27;</span>;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">child</span>(<span class="hljs-params"></span>)&#123;<br>    parent.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>);<br>&#125;<br>parent.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">say</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;222&#x27;</span>)<br>&#125;<br><span class="hljs-keyword">var</span> c = <span class="hljs-keyword">new</span> <span class="hljs-title function_">child</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(c.<span class="hljs-property">a</span>) <span class="hljs-comment">//111</span><br>c.<span class="hljs-title function_">say</span>() <span class="hljs-comment">// 报错</span><br></code></pre></td></tr></table></figure></li>
<li><strong>组合继承</strong>：结合上面两种方法，用构造函数继承中的子类型的原型指向超类型。这样解决了前面两种模式单独使用了问题，但是由于是用超类型的实例作为子类型的原型，调用了两次超类型的构造函数，会产生属性与方法重叠的问题。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">parent</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> = <span class="hljs-string">&#x27;111&#x27;</span>;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">child</span>(<span class="hljs-params"></span>)&#123;<br>    parent.<span class="hljs-title function_">call</span>()(<span class="hljs-variable language_">this</span>);<br>&#125;<br>child.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title function_">parent</span>();<br>parent.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">say</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;222&#x27;</span>);<br>&#125;<br>child.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title function_">parent</span>();<br><span class="hljs-keyword">var</span> c = <span class="hljs-keyword">new</span> <span class="hljs-title function_">child</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(c.<span class="hljs-property">a</span>); <span class="hljs-comment">// 111</span><br>c.<span class="hljs-title function_">say</span>() <span class="hljs-comment">// 222</span><br></code></pre></td></tr></table></figure></li>
<li><strong>原型式继承</strong>：用构造函数在一个函数中传入了一个临时的构造函数，将传入对象作为构造函数的原型，最后返回这个临时类型的新的实例。也可以用Object.create()实现。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">child</span>(<span class="hljs-params">obj</span>)&#123;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">parent</span>(<span class="hljs-params"></span>)&#123;&#125;<br>    parent.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = obj;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">parent</span>();<br>&#125;<br><span class="hljs-keyword">let</span> person = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;a&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">18</span><br>&#125;<br><span class="hljs-keyword">var</span> c1 = <span class="hljs-title function_">child</span>(person);<br><span class="hljs-keyword">var</span> c2 = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(person);<br></code></pre></td></tr></table></figure></li>
<li><strong>寄生式继承</strong>：创建一个用于封装继承过程的函数，通过传入一个对象，复制一个对象的副本，对对象进行扩展最后返回一个对象。缺点是不能做单函数复用。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">object</span>(<span class="hljs-params">person</span>)&#123;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">F</span>(<span class="hljs-params"></span>)&#123;&#125;;<br>    F.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = person;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">F</span>();<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createChild</span>(<span class="hljs-params">obj</span>)&#123;<br>    <span class="hljs-keyword">let</span> clone = <span class="hljs-title function_">object</span>(obj); <span class="hljs-comment">//创建一个新对象</span><br>    clone.<span class="hljs-property">sayHi</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;hi&#x27;</span>);<br>    &#125;; <span class="hljs-comment">// 对象扩展</span><br>    <span class="hljs-keyword">return</span> clone;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><strong>寄生式组合继承</strong>：使用超类型的原型的副本作为子类型的原型，使用Object.create()将子类型的原型直接指向超类型的原型。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">parent</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> = <span class="hljs-string">&#x27;111&#x27;</span>;<br>&#125;<br>parent.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">say</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;222&quot;</span>);<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">child</span>(<span class="hljs-params"></span>)&#123;<br>    parent.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>);<br>&#125;<br><span class="hljs-comment">//es5之前就重写Object.create方法</span><br><span class="hljs-keyword">if</span>(!<span class="hljs-title class_">Object</span>.<span class="hljs-property">create</span>)&#123; <br>    <span class="hljs-title class_">Object</span>.<span class="hljs-property">create</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">proto</span>)&#123;<br>        <span class="hljs-keyword">function</span> <span class="hljs-title function_">F</span>(<span class="hljs-params"></span>)&#123;&#125;;<br>        F.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = proto;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">F</span>();<br>    &#125;<br>&#125;<br>child.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(parent.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>)<br><span class="hljs-keyword">var</span> c = <span class="hljs-keyword">new</span> <span class="hljs-title function_">child</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(c.<span class="hljs-property">a</span>)<br>c.<span class="hljs-title function_">say</span>()<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="★九、对象的深拷贝和浅拷贝"><a href="#★九、对象的深拷贝和浅拷贝" class="headerlink" title="★九、对象的深拷贝和浅拷贝"></a>★九、对象的深拷贝和浅拷贝</h2><p>不同类型的复制方式：</p>
<ul>
<li>基本类型：从一个变量向另外一个新变量复制基本类型的值，会创建这个值的一个副本，并将该副本复制给新变量</li>
<li>引用类型：从一个变量向另一个新变量复制引用类型的值，其实复制的是指针，最终两个变量最终都指向同一个对象<br><strong>深拷贝和浅拷贝</strong>：</li>
<li>浅拷贝：仅仅是复制了引用，彼此之间的操作会互相影响。</li>
<li>深拷贝：在堆中重新分配内存，不同的地址，相同的值，互不影响。相当于重新建立了变量。</li>
</ul>
<p><strong>实现深拷贝</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">deepCopy</span>(<span class="hljs-params">object</span>) &#123;<br>  <span class="hljs-keyword">if</span> (!object || <span class="hljs-keyword">typeof</span> object !== <span class="hljs-string">&quot;object&quot;</span>) <span class="hljs-keyword">return</span> object;<br><br>  <span class="hljs-keyword">let</span> newObject = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(object) ? [] : &#123;&#125;;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> object) &#123;<br>    <span class="hljs-keyword">if</span> (object.<span class="hljs-title function_">hasOwnProperty</span>(key)) &#123;<br>      newObject[key] = <span class="hljs-title function_">deepCopy</span>(object[key]);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> newObject;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>解决循环引用的深拷贝</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">deepClone</span>(<span class="hljs-params">obj, hash = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakMap</span>()</span>) &#123;<br>  <span class="hljs-keyword">if</span> (!object || <span class="hljs-keyword">typeof</span> object !== <span class="hljs-string">&quot;object&quot;</span>) <span class="hljs-keyword">return</span> object;<br><br>  <span class="hljs-comment">// 是对象的话就要进行深拷贝,遇到循环引用，将引用存储起来，如果存在就不再拷贝</span><br>  <span class="hljs-keyword">if</span> (hash.<span class="hljs-title function_">get</span>(obj)) <span class="hljs-keyword">return</span> hash.<span class="hljs-title function_">get</span>(obj);<br>  <span class="hljs-keyword">let</span> cloneObj = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(object) ? [] : &#123;&#125;;<br>  hash.<span class="hljs-title function_">set</span>(obj, cloneObj);<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> obj) &#123;<br>    <span class="hljs-keyword">if</span> (obj.<span class="hljs-title function_">hasOwnProperty</span>(key)) &#123;<br>      <span class="hljs-comment">// 实现一个递归拷贝</span><br>      cloneObj[key] = <span class="hljs-title function_">deepClone</span>(obj[key], hash);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> cloneObj;<br></code></pre></td></tr></table></figure>
<h2 id="十、实现new操作符"><a href="#十、实现new操作符" class="headerlink" title="十、实现new操作符"></a>十、实现new操作符</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myNew</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-comment">//1.创建一个新的对象</span><br>    <span class="hljs-keyword">let</span> obj=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-comment">//获得构造函数</span><br>    <span class="hljs-keyword">let</span> con = [].<span class="hljs-property">shift</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>); <span class="hljs-comment">//[]为Array构造函数的实例  将类数组转化为真正的数组</span><br>    <span class="hljs-comment">//2.新对象的隐式原型__proto__链接到构造函数的显式原型prototype</span><br>    obj.<span class="hljs-property">__proto__</span> = con.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>;<br>    <span class="hljs-comment">//3.构造函数内部的 this 绑定到这个新创建的对象 执行构造函数</span><br>    <span class="hljs-keyword">let</span> result = con.<span class="hljs-title function_">apply</span>(obj, <span class="hljs-variable language_">arguments</span>)<br>    <span class="hljs-comment">//4.如果构造函数没有返回非空对象，则返回创建的新对象</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> result == <span class="hljs-string">&#x27;object&#x27;</span> ? <span class="hljs-attr">result</span>:obj;<br>&#125;<br><span class="hljs-keyword">var</span> test_create = <span class="hljs-title function_">myNew</span>(<span class="hljs-title class_">Car</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(test_create)<br></code></pre></td></tr></table></figure>

<h2 id="十一、闭包"><a href="#十一、闭包" class="headerlink" title="十一、闭包"></a>十一、闭包</h2><p><strong>闭包是指有权访问另一个函数作用域中变量的函数</strong>，创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以访问到当前函数的局部变量。<br>闭包有两个常用的用途；</p>
<ul>
<li>闭包的第一个用途是使我们在函数外部能够访问到函数内部的变量。通过使用闭包，可以通过在外部调用闭包函数，从而在外部访问到函数内部的变量，可以使用这种方法来创建私有变量。</li>
<li>闭包的另一个用途是使已经运行结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象的引用，所以这个变量对象不会被回收。<br>比如，函数 A 内部有一个函数 B，函数 B 可以访问到函数 A 中的变量，那么函数 B 就是闭包。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">A</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span><br>  <span class="hljs-variable language_">window</span>.<span class="hljs-property">B</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)<br>  &#125;<br>&#125;<br><span class="hljs-title function_">A</span>()<br><span class="hljs-title function_">B</span>() <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure>
<p>在 JS 中，闭包存在的意义就是让我们可以间接访问函数内部的变量。经典面试题：循环中使用闭包解决 var 定义函数的问题</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">timer</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i)<br>  &#125;, i * <span class="hljs-number">1000</span>)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>首先因为 setTimeout是个异步函数，所以会先把循环全部执行完毕，这时候 i就是 6 了，所以会输出一堆 6。<br>解决办法有三种：<br>①<strong>使用闭包</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) &#123;  <br>    (<span class="hljs-keyword">function</span>(<span class="hljs-params">j</span>) &#123;    <br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">timer</span>(<span class="hljs-params"></span>) &#123;      <br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(j)    <br>        &#125;, j * <span class="hljs-number">1000</span>)  <br>    &#125;)(i)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在上述代码中，首先使用了立即执行函数将i传入函数内部，这个时候值就被固定在了参数 j上面不会改变，当下次执行 timer这个闭包的时候，就可以使用外部函数的变量j，从而达到目的。<br>②第二种就是使用 setTimeout的第三个参数，这个参数会被当成 timer函数的参数传入。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">timer</span>(<span class="hljs-params">j</span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(j)<br>    &#125;,<br>    i * <span class="hljs-number">1000</span>,<br>    i<br>  )<br>&#125;<br></code></pre></td></tr></table></figure>
<p>③第三种就是使用 let定义 i了来解决问题了，这个也是最为推荐的方式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">timer</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i)<br>  &#125;, i * <span class="hljs-number">1000</span>)<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="十二、作用域"><a href="#十二、作用域" class="headerlink" title="十二、作用域"></a>十二、作用域</h2><h3 id="12-1-全局作用域和函数作用域"><a href="#12-1-全局作用域和函数作用域" class="headerlink" title="12.1 全局作用域和函数作用域"></a>12.1 全局作用域和函数作用域</h3><p>（1）全局作用域</p>
<ul>
<li>最外层函数和最外层函数外面定义的变量拥有全局作用域</li>
<li>所有未定义直接赋值的变量自动声明为全局作用域</li>
<li>所有window对象的属性拥有全局作用域</li>
<li>全局作用域有很大的弊端，过多的全局作用域变量会污染全局命名空间，容易引起命名冲突。<br>（2）函数作用域</li>
<li>函数作用域声明在函数内部的变零，一般只有固定的代码片段可以访问到</li>
<li>作用域是分层的，内层作用域可以访问外层作用域，反之不行</li>
</ul>
<h3 id="12-2-块级作用域"><a href="#12-2-块级作用域" class="headerlink" title="12.2 块级作用域"></a>12.2 块级作用域</h3><ul>
<li>使用ES6中新增的let和const指令可以声明块级作用域，块级作用域可以在函数中创建也可以在一个代码块中的创建（由<code>&#123; &#125;</code>包裹的代码片段）</li>
<li>let和const声明的变量不会有变量提升，也不可以重复声明</li>
<li>在循环中比较适合绑定块级作用域，这样就可以把声明的计数器变量限制在循环内部。<br><strong>作用域链：</strong> 在当前作用域中查找所需变量，但是该作用域没有这个变量，那这个变量就是自由变量。如果在自己作用域找不到该变量就去父级作用域查找，依次向上级作用域查找，直到访问到window对象就被终止，这一层层的关系就是作用域链。<br>作用域链的作用是<strong>保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，可以访问到外层环境的变量和函数。</strong><br>作用域链的本质上是一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象。作用域链的前端始终都是当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象。<br>当查找一个变量时，如果当前执行环境中没有找到，可以沿着作用域链向后查找。</li>
</ul>
<h2 id="十三、执行上下文"><a href="#十三、执行上下文" class="headerlink" title="十三、执行上下文"></a>十三、执行上下文</h2><h3 id="13-1-执行上下文类型"><a href="#13-1-执行上下文类型" class="headerlink" title="13.1 执行上下文类型"></a>13.1 执行上下文类型</h3><p><strong>（1）全局执行上下文</strong><br>任何不在函数内部的都是全局执行上下文，它首先会创建一个全局的window对象，并且设置this的值等于这个全局对象，一个程序中只有一个全局执行上下文。<br><strong>（2）函数执行上下文</strong><br>当一个函数被调用时，就会为该函数创建一个新的执行上下文，函数的上下文可以有任意多个。<br><strong>（3）</strong>eval<strong>函数执行上下文</strong><br>执行在eval函数中的代码会有属于他自己的执行上下文，不过eval函数不常使用，不做介绍。</p>
<h3 id="13-2-执行上下文栈"><a href="#13-2-执行上下文栈" class="headerlink" title="13.2 执行上下文栈"></a>13.2 执行上下文栈</h3><ul>
<li>JavaScript引擎使用执行上下文栈来管理执行上下文</li>
<li>当JavaScript执行代码时，首先遇到全局代码，会创建一个全局执行上下文并且压入执行栈中，每当遇到一个函数调用，就会为该函数创建一个新的执行上下文并压入栈顶，引擎会执行位于执行上下文栈顶的函数，当函数执行完成之后，执行上下文从栈中弹出，继续执行下一个上下文。当所有的代码都执行完毕之后，从栈中弹出全局执行上下文。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> a = <span class="hljs-string">&#x27;Hello World!&#x27;</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">first</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Inside first function&#x27;</span>);<br>  <span class="hljs-title function_">second</span>();<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Again inside first function&#x27;</span>);<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">second</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Inside second function&#x27;</span>);<br>&#125;<br><span class="hljs-title function_">first</span>();<br><span class="hljs-comment">//执行顺序</span><br><span class="hljs-comment">//先执行second(),在执行first()</span><br></code></pre></td></tr></table></figure>
<h3 id="13-3-创建执行上下文"><a href="#13-3-创建执行上下文" class="headerlink" title="13.3 创建执行上下文"></a>13.3 创建执行上下文</h3><p>创建执行上下文有两个阶段：<strong>创建阶段</strong>和<strong>执行阶段</strong><br><strong>1）创建阶段</strong><br>（1）this绑定</p>
<ul>
<li>在全局执行上下文中，this指向全局对象（window对象）</li>
<li>在函数执行上下文中，this指向取决于函数如何调用。如果它被一个引用对象调用，那么 this 会被设置成那个对象，否则 this 的值被设置为全局对象或者 undefined</li>
</ul>
<p>（2）创建词法环境组件</p>
<ul>
<li>词法环境是一种有<strong>标识符——变量映射</strong>的数据结构，标识符是指变量&#x2F;函数名，变量是对实际对象或原始数据的引用。</li>
<li>词法环境的内部有两个组件：<strong>加粗样式</strong>：环境记录器:用来储存变量个函数声明的实际位置<strong>外部环境的引用</strong>：可以访问父级作用域</li>
</ul>
<p>（3）创建变量环境组件</p>
<p>变量环境也是一个词法环境，其环境记录器持有变量声明语句在执行上下文中创建的绑定关系。<br><strong>2）执行阶段</strong> 此阶段会完成对变量的分配，最后执行完代码。<br><strong>简单来说执行上下文就是指：</strong><br>在执行一点JS代码之前，需要先解析代码。解析的时候会先创建一个全局执行上下文环境，先把代码中即将执行的变量、函数声明都拿出来，变量先赋值为undefined，函数先声明好可使用。这一步执行完了，才开始正式的执行程序。<br>在一个函数执行之前，也会创建一个函数执行上下文环境，跟全局执行上下文类似，不过函数执行上下文会多出this、arguments和函数的参数。</p>
<ul>
<li>全局上下文：变量定义，函数声明</li>
<li>函数上下文：变量定义，函数声明，this，arguments</li>
</ul>
<h1 id="五、异步编程"><a href="#五、异步编程" class="headerlink" title="五、异步编程"></a>五、异步编程</h1><h2 id="一、异步编程实现方式"><a href="#一、异步编程实现方式" class="headerlink" title="一、异步编程实现方式"></a>一、异步编程实现方式</h2><ul>
<li><strong>回调函数</strong>：其它函数在满足某个条件或发生某个（异步）事件时调用（回调）这个函数。缺点是多个回调函数嵌套时会造成回调函数地狱，上下两层回调函数之间代码耦合度太高，不利于代码的维护。</li>
<li><strong>Promise</strong>：将嵌套的回调函数作为链式调用，使用这个方法有时会造成多个then的链式调用，可能会造成代码语义不够明确。</li>
<li><strong>generator</strong>：可以在函数的执行过程中，将函数的执行权转移出去，在函数外部还可以将执行权转移回来。当遇到异步函数执行的时候，将函数执行权转移出去，当异步函数执行完毕时再将执行权给转移回来。因此在generator内部对于异步操作的方式，可以以同步的顺序来书写。使用这种方式需要考虑的问题是何时将函数的控制权转移回来，因此需要有一个自动执行generator的机制，比如说 co 模块等方式来实现 generator 的自动执行。</li>
<li><strong>async&#x2F;await</strong>：async函数是generator和promise实现的一个自动执行的语法糖，它内部自带执行器，当函数内部执行到一个await语句的时候，如果语句返回一个promise对象，那么函数将会等待promise对象的状态变为resolve后再继续向下执行。因此可以将异步逻辑，转化为同步的顺序来书写，并且这个函数可以自动执行。</li>
</ul>
<h2 id="二、定时器setTimeout、setInterval、requestAnimationFrame"><a href="#二、定时器setTimeout、setInterval、requestAnimationFrame" class="headerlink" title="二、定时器setTimeout、setInterval、requestAnimationFrame"></a>二、定时器setTimeout、setInterval、requestAnimationFrame</h2><p><strong>setTimeout</strong>只在指定时间后执行一次。如果前面代码影响了性能，会导致setTimeout不能按期执行，因为定时器属于宏任务，宏任务必须等待同步任务执行完成，再等微任务执行完成才会执行其中回调函数。时间单位为毫秒。其返回值通过clearTimeout()来关闭定时器。<br>下面为计算每次执行setTimeout的间隔</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> period = <span class="hljs-number">60</span> * <span class="hljs-number">1000</span> * <span class="hljs-number">60</span> * <span class="hljs-number">2</span>  <span class="hljs-comment">// 一个周期为两个小时</span><br><span class="hljs-keyword">let</span> startTime = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getTime</span>() <span class="hljs-comment">//开始时间</span><br><span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span> <span class="hljs-comment">// 循环次数</span><br><span class="hljs-keyword">let</span> end = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getTime</span>() + period <span class="hljs-comment">// 期待结束时间</span><br><span class="hljs-keyword">let</span> interval = <span class="hljs-number">1000</span><br><span class="hljs-keyword">let</span> currentInterval = interval<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">loop</span>(<span class="hljs-params"></span>) &#123;<br>  count++ <span class="hljs-comment">// 循环增加一次</span><br>  <span class="hljs-comment">// 代码执行所消耗的时间</span><br>  <span class="hljs-keyword">let</span> offset = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getTime</span>() - (startTime + count * interval);<br>  <span class="hljs-keyword">let</span> diff = end - <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getTime</span>() <span class="hljs-comment">//距离结束时间</span><br>  <span class="hljs-keyword">let</span> h = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(diff / (<span class="hljs-number">60</span> * <span class="hljs-number">1000</span> * <span class="hljs-number">60</span>)) <span class="hljs-comment">//离结束还有多少小时</span><br>  <span class="hljs-keyword">let</span> hdiff = diff % (<span class="hljs-number">60</span> * <span class="hljs-number">1000</span> * <span class="hljs-number">60</span>) <span class="hljs-comment">//离结束剩余一个小时内多长时间</span><br>  <span class="hljs-keyword">let</span> m = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(hdiff / (<span class="hljs-number">60</span> * <span class="hljs-number">1000</span>)) <span class="hljs-comment">//离结束剩余一个小时内多少分钟</span><br>  <span class="hljs-keyword">let</span> mdiff = hdiff % (<span class="hljs-number">60</span> * <span class="hljs-number">1000</span>) <span class="hljs-comment">//离结束剩余一分钟内多少时间</span><br>  <span class="hljs-keyword">let</span> s = mdiff / (<span class="hljs-number">1000</span>) <span class="hljs-comment">// 离结束剩余一分钟内多少秒</span><br>  <span class="hljs-keyword">let</span> sCeil = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">ceil</span>(s)<br>  <span class="hljs-keyword">let</span> sFloor = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(s)<br>  <span class="hljs-comment">// 得到下一次循环所消耗的时间</span><br>  currentInterval = interval - offset<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;时：&#x27;</span>+h, <span class="hljs-string">&#x27;分：&#x27;</span>+m, <span class="hljs-string">&#x27;毫秒：&#x27;</span>+s, <span class="hljs-string">&#x27;秒向上取整：&#x27;</span>+sCeil, <span class="hljs-string">&#x27;代码执行时间：&#x27;</span>+offset, <span class="hljs-string">&#x27;下次循环间隔&#x27;</span>+currentInterval)<br>  <span class="hljs-built_in">setTimeout</span>(loop, currentInterval)<br>&#125;<br><span class="hljs-built_in">setTimeout</span>(loop, currentInterval)<br></code></pre></td></tr></table></figure>
<p><strong>setInterval</strong>以指定时间为周期循环执行。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">demo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-built_in">setInterval</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>)<br>  &#125;,<span class="hljs-number">1000</span>)<br>  <span class="hljs-title function_">sleep</span>(<span class="hljs-number">2000</span>)<br>&#125;<br><span class="hljs-title function_">demo</span>()<br></code></pre></td></tr></table></figure>
<p>一般情况下setTimeout用于延迟执行某种方法或功能，setInerval一般用于刷新表单，对一些表单的假实时指定时间刷新同步。<br><strong>requestAnimationFrame</strong>自带函数节流功能，基本可以保证在16.6毫秒（60Hz刷新频率）内只执行一次（不掉帧的情况下），且该函数的延迟效果是精确的。优势是由系统决定回调函数的执行时机，每次刷新的间隔中会执行一次回调函数，不会引起丢帧和卡顿。可以用来实现循环定时器。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">setInterval</span>(<span class="hljs-params">callback, interval</span>) &#123;<br>  <span class="hljs-keyword">let</span> timer<br>  <span class="hljs-keyword">const</span> now = <span class="hljs-title class_">Date</span>.<span class="hljs-property">now</span><br>  <span class="hljs-keyword">let</span> startTime = <span class="hljs-title function_">now</span>()<br>  <span class="hljs-keyword">let</span> endTime = startTime<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">loop</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    timer = <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">requestAnimationFrame</span>(loop)<br>    endTime = <span class="hljs-title function_">now</span>()<br>    <span class="hljs-keyword">if</span> (endTime - startTime &gt;= interval) &#123;<br>      startTime = endTime = <span class="hljs-title function_">now</span>()<br>      <span class="hljs-title function_">callback</span>(timer)<br>    &#125;<br>  &#125;<br>  timer = <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">requestAnimationFrame</span>(loop)<br>  <span class="hljs-keyword">return</span> timer<br>&#125;<br><span class="hljs-keyword">let</span> a = <span class="hljs-number">0</span><br><span class="hljs-built_in">setInterval</span>(<span class="hljs-function"><span class="hljs-params">timer</span> =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>)<br>  a++<br>  <span class="hljs-keyword">if</span> (a === <span class="hljs-number">3</span>) <span class="hljs-title function_">cancelAnimationFrame</span>(timer)<br>&#125;, <span class="hljs-number">1000</span>)<br></code></pre></td></tr></table></figure>
<p><strong>setInterval和setTimeout互相实现</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myInterval</span>(<span class="hljs-params">fn, delay,isPause</span>) &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">interval</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>        <span class="hljs-built_in">setTimeout</span>(interval ,delay)<br>        <span class="hljs-title function_">fn</span>()<br>    &#125;<br>    <span class="hljs-built_in">setTimeout</span>(interval, delay)<br>&#125;<br><span class="hljs-comment">//setInterval实现 setTimeout</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">mySetTimeOut</span>(<span class="hljs-params">fn,delay</span>)=&gt;&#123;<br>    <span class="hljs-keyword">let</span> timer = <span class="hljs-title function_">setInterVal</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-built_in">clearInterval</span>(timer)<br>        <span class="hljs-title function_">fn</span>()<br>    &#125;,delay)<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="★三、宏任务与微任务"><a href="#★三、宏任务与微任务" class="headerlink" title="★三、宏任务与微任务"></a>★三、宏任务与微任务</h2><p><strong>宏任务</strong>：js执行的任务，是由宿主（Node、浏览器）发起的，后运行，会触发新一轮的Tick，主要包括：</p>
<ul>
<li>script里代码（全局代码）</li>
<li>setTimeout、setInterval</li>
<li>UI事件</li>
<li>postMessage、MessageChannel（主要用于不同浏览器上下文通信、worker跨线程通信、对象深拷贝，利用消息在发送和接收的过程中进行序列化和反序列化）</li>
<li>setImmediate（异步执行某些代码但要尽快执行），I&#x2F;O (Node.js）</li>
</ul>
<p><strong>微任务</strong>：是由JS引擎发起的，先运行，不会触发新一轮的Tick。主要包括：</p>
<ul>
<li>Promise</li>
<li>process.nextTick(Node.js定义一个动作，让其在下一个事件轮询的时间点上执行）</li>
<li>Object.observe</li>
<li>MutaionObserver</li>
</ul>
<h3 id="事件轮询执行顺序（宏任务和微任务怎样执行）"><a href="#事件轮询执行顺序（宏任务和微任务怎样执行）" class="headerlink" title="事件轮询执行顺序（宏任务和微任务怎样执行）"></a>事件轮询执行顺序（宏任务和微任务怎样执行）</h3><ol>
<li>先执行同步代码（取出一个宏任务），遇到异步宏任务就将其放入宏任务队列中，遇到异步微任务就将其放入微任务队列中。</li>
<li>当所有同步代码执行完毕后，再将异步微任务从队列中调入主线程执行，然后进行UI渲染。</li>
<li>执行下一个宏任务，执行下一个所有微任务，进行UI渲染，循环这个过程。<br>即<strong>先执行宏任务，执行完后看微任务队列是否有微任务，没有微任务浏览器渲染后执行下一个宏任务，有微任务则将所有微任务执行，执行完浏览器渲染后再执行下一个宏任务</strong>。</li>
</ol>
<h2 id="四、setTimeout、Promise、Async-x2F-await的区别"><a href="#四、setTimeout、Promise、Async-x2F-await的区别" class="headerlink" title="四、setTimeout、Promise、Async&#x2F;await的区别"></a>四、setTimeout、Promise、Async&#x2F;await的区别</h2><h3 id="4-1-setTimeout"><a href="#4-1-setTimeout" class="headerlink" title="4.1 setTimeout"></a>4.1 setTimeout</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;script start&#x27;</span>) <span class="hljs-comment">//1. 打印 script start</span><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;settimeout&#x27;</span>) <span class="hljs-comment">// 4. 打印 settimeout</span><br>&#125;)  <span class="hljs-comment">// 2. 调用 setTimeout 函数，并定义其完成后执行的回调函数</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;script end&#x27;</span>) <span class="hljs-comment">//3. 打印 script start</span><br><span class="hljs-comment">// 输出顺序：script start-&gt;script end-&gt;settimeout</span><br>&#125;)<br></code></pre></td></tr></table></figure>
<h3 id="4-2-Promise"><a href="#4-2-Promise" class="headerlink" title="4.2 Promise"></a>4.2 Promise</h3><p>Promise本身是<strong>同步的立即执行函数</strong>，有Pending（进行中）、Resolved（已完成）、Rejected（已拒绝）三种状态。 当把一件事情交给promise时，它的状态就是Pending，任务完成了状态就变成了Resolved、没有完成失败了就变成了Rejected。<br>Promise的实例有两个过程：<br>pending &#x3D;&gt; fulfilled : Resolved(已完成)<br>pending &#x3D;&gt; rejected: Rejected (已拒绝)<br>注意: 一旦从进行状态变成为其他状态就永远不能更改状态了。<br>当在executor中执行resolve或者reject的时候, 此时是异步操作，会先执行then&#x2F;catch等，当主栈完成后，才会去调用resolve&#x2F;reject中存放的方法执行，打印p的时候，是打印的返回结果，一个Promise实例。</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li>对象的状态不受外界影响，promise对象代表一个异步操作，只有异步操作的结果可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。</li>
<li>一旦状态改变就不会再变，任何时候都可以得到这个结果。如果改变已经发生了，再对promise对象添加回调函数也会立即得到这个结果。这与事件完全不同，事件的特点是如果错过了它再去监听得不到结果。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;script start&#x27;</span>)<br><span class="hljs-keyword">let</span> promise1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;promise1&#x27;</span>)<br>    <span class="hljs-title function_">resolve</span>()<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;promise1 end&#x27;</span>)<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;promise2&#x27;</span>)<br>&#125;)<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;settimeout&#x27;</span>)<br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;script end&#x27;</span>)<br><span class="hljs-comment">// 输出顺序: script start-&gt;promise1-&gt;promise1 end-&gt;script end-&gt;promise2-&gt;settimeout</span><br></code></pre></td></tr></table></figure>
当JS主线程执行到Promise对象时：</li>
<li>promise1.then() 的回调就是一个 task</li>
<li>promise1 是 resolved或rejected: 那这个 task 就会放入当前事件循环回合的 microtask queue</li>
<li>promise1 是 pending: 这个 task 就会放入 事件循环的未来的某个(可能下一个)回合的 microtask queue 中</li>
<li>setTimeout 的回调也是个 task ，它会被放入 macrotask queue 即使是 0ms 的情况</li>
</ul>
<h3 id="4-3-async-x2F-await"><a href="#4-3-async-x2F-await" class="headerlink" title="4.3 async&#x2F;await"></a>4.3 async&#x2F;await</h3><p>async的函数返回值是一个Promise对象，await接收一个Promise并将其转换为一个返回值或一个抛出的异常。当函数执行的时候一旦遇上await就会先返回，等到触发的异步操作完成，再执行函数体内后面的语句。<br>可以理解为，是让出了线程，跳出了 async 函数体。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">async1</span>(<span class="hljs-params"></span>)&#123;<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;async1 start&#x27;</span>);<br>    <span class="hljs-keyword">await</span> <span class="hljs-title function_">async2</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;async1 end&#x27;</span>)<br>&#125;<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">async2</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;async2&#x27;</span>)<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;script start&#x27;</span>);<br><span class="hljs-title function_">async1</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;script end&#x27;</span>)<br><span class="hljs-comment">// 输出顺序：script start-&gt;async1 start-&gt;async2-&gt;script end-&gt;async1 end</span><br></code></pre></td></tr></table></figure>
<p>await的含义为等待，也就是 async 函数需要等待await后的函数执行完成并且有了返回结果（Promise对象）之后，才能继续执行下面的代码。await通过返回一个Promise对象来实现同步的效果。</p>
<h2 id="五、Promise的理解及实现"><a href="#五、Promise的理解及实现" class="headerlink" title="五、Promise的理解及实现"></a>五、Promise的理解及实现</h2><p>Promise是异步编程的一种解决方案，它是一个对象，可以获取异步操作的消息，他的出现大大改善了异步编程的困境，避免了<strong>地狱回调</strong>，它比传统的解决方案回调函数和事件更合理和更强大。<br>所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。<br><strong>executor是Promise对象的参数，是一段将输出与promise联系起来的自定义代码，函数签名为function(resolutionFunc, rejectionFunc){}</strong><br>（1）Promise的实例有<strong>三个状态</strong>:</p>
<ul>
<li>Pending（进行中）</li>
<li>Resolved（已完成）</li>
<li>Rejected（已拒绝）<br>当把一件事情交给promise时，它的状态就是Pending，任务完成了状态就变成了Resolved、没有完成失败了就变成了Rejected。</li>
</ul>
<p>（2）Promise的实例有<strong>两个过程</strong>：</p>
<ul>
<li>pending -&gt; fulfilled : Resolved（已完成）</li>
<li>pending -&gt; rejected：Rejected（已拒绝）<br>注意：一旦从进行状态变成为其他状态就永远不能更改状态了。<br><strong>Promise的特点：</strong></li>
<li>对象的状态不受外界影响。promise对象代表一个异步操作，有三种状态，pending（进行中）、fulfilled（已成功）、rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。</li>
<li>一旦状态改变就不会再变，任何时候都可以得到这个结果。promise对象的状态改变，只有两种可能：从pending变为fulfilled，从pending变为rejected。这时就称为resolved（已定型）。如果改变已经发生了，你再对promise对象添加回调函数，也会立即得到这个结果。这与事件（event）完全不同，事件的特点是：如果你错过了它，再去监听是得不到结果的。<br><strong>Promise的缺点：</strong></li>
<li>无法取消Promise，一旦新建它就会立即执行，无法中途取消。</li>
<li>如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。</li>
<li>当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。<br><strong>总结：</strong> Promise 对象是异步编程的一种解决方案。Promise 是一个构造函数，接收一个函数作为参数，返回一个 Promise 实例。一个 Promise 实例有三种状态，分别是pending、resolved 和 rejected，分别代表了进行中、已成功和已失败。实例的状态只能由 pending 转变 resolved 或者rejected 状态，并且状态一经改变，就凝固了，无法再被改变了。<br>状态的改变是通过 resolve() 和 reject() 函数来实现的，可以在异步操作结束后调用这两个函数改变 Promise 实例的状态，它的原型上定义了一个 then 方法，使用这个 then 方法可以为两个状态的改变注册回调函数。这个回调函数属于微任务，会在本轮事件循环的末尾执行。<br><strong>注意：</strong> 在构造Promise的时候，构造函数内部的代码是立即执行的。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) &#123;<span class="hljs-comment">//参数是两个函数</span><br> <span class="hljs-comment">// ... some code</span><br> <span class="hljs-keyword">if</span> (<span class="hljs-comment">/* 异步操作成功*/</span>)&#123;<br>  <span class="hljs-title function_">resolve</span>(value); <span class="hljs-comment">//将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；</span><br> &#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-title function_">reject</span>(error);<br> &#125;<br>&#125;); <span class="hljs-comment">//resolv和reject是同步执行的，改变状态返回值就确定了</span><br></code></pre></td></tr></table></figure>
Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">promise.<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) &#123;<br> <span class="hljs-comment">// success,Promise对象的状态变为resolved时调用</span><br>&#125;, <span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) &#123;<br> <span class="hljs-comment">// failure,Promise对象的状态变为rejected时调用</span><br>&#125;);<br></code></pre></td></tr></table></figure>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//excutor 执行构造器 Promise：构造promise函数对象</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Promise</span>(<span class="hljs-params">excutor</span>)&#123;<br>    <span class="hljs-keyword">const</span> _that = <span class="hljs-variable language_">this</span>;<br>    _that.<span class="hljs-property">status</span> = <span class="hljs-string">&#x27;pending&#x27;</span>; <span class="hljs-comment">//promise绑定status属性，初始值pending</span><br>    _that.<span class="hljs-property">data</span> = <span class="hljs-literal">undefined</span>;  <span class="hljs-comment">//promise绑定data指定一个存储结果的属性</span><br>    _that.<span class="hljs-property">callbacks</span> = [];    <span class="hljs-comment">//每个元素的结构：&#123; onFulfilled()&#123;&#125;, onRejected()&#123;&#125;&#125;</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-params">value</span>)&#123;<br>        <span class="hljs-keyword">if</span>(_that.<span class="hljs-property">status</span> !== <span class="hljs-string">&#x27;pending&#x27;</span>) <span class="hljs-keyword">return</span>    <span class="hljs-comment">//如果当前状态不是pending直接结束</span><br>        _that.<span class="hljs-property">status</span> = <span class="hljs-string">&#x27;resolved&#x27;</span> <span class="hljs-comment">//改状态</span><br>        _that.<span class="hljs-property">data</span> = value;    <span class="hljs-comment">//保存数据</span><br>        <span class="hljs-keyword">if</span>(value <span class="hljs-keyword">instanceof</span> promise)&#123;<br>          <span class="hljs-keyword">return</span> value.<span class="hljs-title function_">then</span>(resolve,reject)<br>    &#125;<br>         <span class="hljs-comment">// 为什么resolve 加setTimeout?</span><br>        <span class="hljs-comment">// 2.2.4规范 onFulfilled 和 onRejected 只允许在 execution context 栈仅包含平台代码时运行.</span><br>        <span class="hljs-comment">// 注1 这里的平台代码指的是引擎、环境以及 promise 的实施代码。实践中要确保 onFulfilled 和 onRejected 方法异步执行，且应该在 then 方法被调用的那一轮事件循环之后的新执行栈中执行。</span><br>        <span class="hljs-keyword">if</span>(_that.<span class="hljs-property">callbacks</span>.<span class="hljs-property">length</span> &gt;<span class="hljs-number">0</span>)&#123; <span class="hljs-comment">// 如果有待执行callback 函数，立刻异步执行回调函数</span><br>            <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>                _that.<span class="hljs-property">callbacks</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">callbackobj</span> =&gt;</span>&#123;<br>                    callbackobj.<span class="hljs-title function_">onFulfilled</span>(value)<br>                &#125;)<br>            &#125;)<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">reject</span>(<span class="hljs-params">reason</span>)&#123;<br>        <span class="hljs-keyword">if</span>(_that.<span class="hljs-property">status</span> !== <span class="hljs-string">&#x27;pending&#x27;</span>) <span class="hljs-keyword">return</span>    <span class="hljs-comment">//如果当前状态不是pending直接结束</span><br>        _that.<span class="hljs-property">status</span> = <span class="hljs-string">&#x27;rejected&#x27;</span> <span class="hljs-comment">//改状态</span><br>        _that.<span class="hljs-property">data</span> = reason;    <span class="hljs-comment">//保存数据</span><br>        <span class="hljs-keyword">if</span>(_that.<span class="hljs-property">callbacks</span>.<span class="hljs-property">length</span> &gt;<span class="hljs-number">0</span>)&#123; <span class="hljs-comment">// 如果有待执行callback 函数，立刻异步执行回调函数</span><br>            <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>                _that.<span class="hljs-property">callbacks</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">callbackobj</span> =&gt;</span>&#123;<br>                    callbackobj.<span class="hljs-title function_">onRejected</span>(reason)<br>                &#125;)<br>            &#125;)<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//立刻同步执行 excutor</span><br>    <span class="hljs-keyword">try</span>&#123;<br>        <span class="hljs-title function_">excutor</span>(resolve,reject)<br>    &#125;.<span class="hljs-title function_">catch</span>(<span class="hljs-params">error</span>)&#123;  <span class="hljs-comment">//如果执行器抛出异常，promise对象变为 rejected 状态</span><br>        <span class="hljs-title function_">reject</span>(error)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="六、Promise的基本用法"><a href="#六、Promise的基本用法" class="headerlink" title="六、Promise的基本用法"></a>六、Promise的基本用法</h2><h3 id="6-1-创建Promise对象"><a href="#6-1-创建Promise对象" class="headerlink" title="6.1 创建Promise对象"></a>6.1 创建Promise对象</h3><p>Promise对象代表一个异步操作，包括pending进行中、fulfilled兑现、rejected拒绝。Promise构造函数接收一个函数作为参数，该函数的两个参数分别为resolve和reject。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) &#123;<br>  <span class="hljs-comment">// ... some code</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-comment">/* 异步操作成功*/</span>)&#123;<br>    <span class="hljs-title function_">resolve</span>(value);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-title function_">reject</span>(error);<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>
<p><strong>一般情况下都会使用new Promise()来创建Promise对象，但也可以使用promise.resolve和promise.reject这两个方法</strong></p>
<h3 id="6-2-Promise-resolve-value"><a href="#6-2-Promise-resolve-value" class="headerlink" title="6.2 Promise.resolve(value)"></a>6.2 Promise.resolve(value)</h3><p>该方法的返回值是一个以value值兑现的Promise对象。如果这个值带有then方法，返回的Promise对象以then的回调返回的值<strong>解决</strong>。如果传入的值value本身就是Promise对象，则该对象作为Promise.resolve方法的返回值返回，其它情况以该值为成功状态返回一个Promise对象。</p>
<ul>
<li>例如：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//如果传入的 value 本身就是 Promise 对象，则该对象作为 Promise.resolve 方法的返回值返回。</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">resolve</span>)&#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-number">123</span>);<br>  &#125;,<span class="hljs-number">3000</span>);<br>&#125;<br><span class="hljs-keyword">let</span> p0 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(fn);<br><span class="hljs-keyword">let</span> p1 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(p0);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p0 === p1); <span class="hljs-comment">// 返回为true，返回的 Promise 即是 入参的 Promise 对象。</span><br></code></pre></td></tr></table></figure></li>
<li>例如：传入thenable对象，返回Promise对象跟随thenable对象的最终状态。ES6 Promises里提到了Thenable这个概念，简单来说它就是一个非常类似Promise的东西。最简单的例子就是jQuery.ajax，它的返回值就是thenable对象。但是并不是只要实现了then方法就一定能作为Promise对象来使用。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//如果传入的 value 本身就是 thenable 对象，返回的 promise 对象会跟随 thenable 对象的状态。</span><br><span class="hljs-keyword">let</span> promise = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>($.<span class="hljs-title function_">ajax</span>(<span class="hljs-string">&#x27;/test/test.json&#x27;</span>));<span class="hljs-comment">// =&gt; promise对象</span><br>promise.<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>)&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<br>&#125;);<br><span class="hljs-comment">//返回一个状态已变成 resolved 的 Promise 对象。</span><br><span class="hljs-keyword">let</span> p1 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">123</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1)<span class="hljs-comment">//打印p1 可以看到p1是一个状态置为resolved的Promise对象</span><br></code></pre></td></tr></table></figure></li>
<li>例如：对返回值进行then调用<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">11</span>).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>)&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value); <span class="hljs-comment">// 打印出11</span><br>&#125;);<br></code></pre></td></tr></table></figure>
resolve(11)代码中，会让promise对象进入确定(resolve状态)，并将参数11传递给后面的then所指定的onFulfilled函数；<br><strong>创建promise对象可以使用new Promise的形式创建对象，也可以使用Promise.resolve(value)的形式创建promise对象；</strong></li>
</ul>
<h3 id="6-3-Promise-reject-value"><a href="#6-3-Promise-reject-value" class="headerlink" title="6.3 Promise.reject(value)"></a>6.3 Promise.reject(value)</h3><p>与Promise.resolve唯一不同的是，返回的值是一个以该参数为理由拒绝的Promise对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">resolve</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">reason</span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>        <span class="hljs-title function_">reject</span>(reason)<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>使用方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;我错了&quot;</span>));<br></code></pre></td></tr></table></figure>
<p>下面是使用resolve方法和reject方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">testPromise</span>(<span class="hljs-params">ready</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve,reject</span>)&#123;<br>    <span class="hljs-keyword">if</span>(ready) &#123;<br>      <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;hello world&quot;</span>);<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-title function_">reject</span>(<span class="hljs-string">&quot;No thanks&quot;</span>);<br>    &#125;<br>  &#125;);<br>&#125;;<br><span class="hljs-comment">// 方法调用</span><br><span class="hljs-title function_">testPromise</span>(<span class="hljs-literal">true</span>).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">msg</span>)&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(msg);<br>&#125;,<span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>)&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error);<br>&#125;);<br></code></pre></td></tr></table></figure>
<p>上面的代码的含义是给testPromise方法传递一个参数，返回一个promise对象，如果为true的话，那么调用promise对象中的resolve()方法，并且把其中的参数传递给后面的then第一个函数内，因此打印出“hello world”,如果为false的话，会调用promise对象中的reject()方法，则会进入then的第二个函数内，会打印No thanks</p>
<h3 id="6-4-Promise-then"><a href="#6-4-Promise-then" class="headerlink" title="6.4 Promise.then()"></a>6.4 Promise.then()</h3><p>作用是为Promise实例添加状态改变时的回调函数，<strong>then里面可以传入两个回调函数，第一个回调函数在期约被兑现时调用，第二个回调函数在期约被拒绝时调用</strong>，第二个参数可以省略。<br>then方法的返回值是一个新的Promise对象，可以使用链式写法，即一个then方法后面再调用另一个then方法。<strong>返回的Promise对象p</strong>的状态由then指定的<strong>回调函数</strong>执行的结果决定：</p>
<ol>
<li>如果抛出异常，新的Promise对象为rejected拒绝状态，resaon为抛出的异常。</li>
<li>如果返回的值是非期约值，那么新Promise为resolved兑现，对象，返回值为对象成功的值value，默认的返回undefined，也是成功。</li>
<li>如果返回的是一个新的期约Promise为v，那么p以v解决，这个新的Promise的返回值就是then返回的Promise的值。<br>then中的回调函数一定要return一个结果或一个新的Promise对象，才能让之后的then回调接收。<br>实现思路：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    Promise原型对象的then()思路：注册fulfilled状态/rejected状态对应的回调函数</span><br><span class="hljs-comment">      1、指定成功和失败的回调函数</span><br><span class="hljs-comment">      2、返回一个新的 promise 对象</span><br><span class="hljs-comment">      3、返回promise的结果由 onFulfilled/onRejected执行结果决定</span><br><span class="hljs-comment">      4、指定 onFulfilled/onRejected的默认值</span><br><span class="hljs-comment">     注意的点： then里面的FULFILLED/REJECTED状态时为什么要加setTimeout?</span><br><span class="hljs-comment">     原因:</span><br><span class="hljs-comment">     其一 要确保 onFulfilled 和 onRejected 方法异步执行(且应该在 then 方法被调用的那一轮事件循环之后的新执行栈中执行) 所以要在resolve里加上setTimeout</span><br><span class="hljs-comment">     其二 对于一个promise，它的then方法可以调用多次.（当在其他程序中多次调用同一个promise的then时 由于之前状态已经为FULFILLED/REJECTED状态，则会走的下面逻辑),所以要确保为FULFILLED/REJECTED状态后 也要异步执行onFulfilled/onRejected。也是resolve函数里加setTimeout的原因</span><br><span class="hljs-comment">    // 总之都是 让then方法异步执行 也就是确保onFulfilled/onRejected异步执行</span><br><span class="hljs-comment">*/</span><br><span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">then</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">onFulfilled,onRejected</span>)&#123;<br>   <span class="hljs-comment">// 处理参数默认值 保证参数后续能够继续执行</span><br>    onFulfilled = <span class="hljs-keyword">typeof</span> onFulfilled === <span class="hljs-string">&#x27;function&#x27;</span> ?<br>        onFulfilled : <span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> reason <span class="hljs-comment">//向后传递成功的value</span><br>   <br>    <span class="hljs-comment">//指定默认的失败的回调（实现错误/异常穿透的关键点）</span><br>    onRejected = <span class="hljs-keyword">typeof</span> onRejected === <span class="hljs-string">&#x27;function&#x27;</span> ? onRejected : <span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123;<br>        <span class="hljs-comment">//向后传递失败的reason</span><br>        <span class="hljs-keyword">throw</span> reason<br>    &#125;<br>   <br>    <span class="hljs-keyword">const</span> _that = <span class="hljs-variable language_">this</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>        <span class="hljs-comment">//调用指定的回调函数处理，根据执行结果，改变return的promise的状态</span><br>        <span class="hljs-keyword">function</span> <span class="hljs-title function_">handle</span>(<span class="hljs-params">callback</span>)&#123;<br>            <span class="hljs-comment">//1. 如果抛出异常，return 的promise就会失败，reason 就是 error</span><br>            <span class="hljs-comment">//2. 如果回调函数返回的不是promise，return的promise就会成功，value就是返回的值</span><br>            <span class="hljs-comment">//3.如果回调函数返回的是promise，return的promise的结果就是这个promise的结果</span><br>            <span class="hljs-keyword">try</span>&#123;<br>                <span class="hljs-keyword">const</span> result = <span class="hljs-title function_">callback</span>(_that.<span class="hljs-property">data</span>)<br>                <span class="hljs-keyword">if</span>(result <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Promise</span>)&#123;<br>                    result.<span class="hljs-title function_">then</span>(resolve,reject)<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-title function_">resolve</span>(result)<br>                &#125;<br>            &#125;<span class="hljs-keyword">catch</span>(error)&#123;<br>                <span class="hljs-title function_">reject</span>(error)<br>            &#125;<br>        &#125;<br>     <br>        <span class="hljs-keyword">if</span>(_that.<span class="hljs-property">status</span> === <span class="hljs-string">&#x27;pending&#x27;</span>)&#123;<span class="hljs-comment">//假设当前状态还是 pending 状态，将回调函数 保存起来</span><br>          <span class="hljs-comment">// 当异步调用resolve/rejected时 将onFulfilled/onRejected收集暂存到集合中</span><br>            _that.<span class="hljs-property">callbacks</span>.<span class="hljs-title function_">push</span>(&#123;<br>                <span class="hljs-title function_">onFulfilled</span>(<span class="hljs-params">value</span>)&#123;<br>                    <span class="hljs-title function_">handle</span>(onFulfilled)<span class="hljs-comment">//改promise的状态为 onFulfilled状态</span><br>                &#125;,<br>                <span class="hljs-title function_">onRejected</span>(<span class="hljs-params">reason</span>) &#123;<br>                    <span class="hljs-title function_">handle</span>(onRejected)  <span class="hljs-comment">//改promise的状态为 onRejected状态</span><br>                &#125;<br>            &#125;)<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(_that.<span class="hljs-property">status</span> === <span class="hljs-string">&#x27;resolved&#x27;</span>)&#123;<span class="hljs-comment">//如果当前是resolved状态，异步执行onresolved并改变return的promise状态</span><br>            <span class="hljs-title function_">setTimeOut</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>                <span class="hljs-title function_">handle</span>(onFulfilled)<br>            &#125;)<br>        &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//如果当前是rejected状态，异步执行onRejected并改变return的promise状态</span><br>            <span class="hljs-title function_">setTimeOut</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>                <span class="hljs-title function_">handle</span>(onRejected)<br>            &#125;)<br>        &#125;<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure>
当要写有顺序的异步事件，需要串行时：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>    <span class="hljs-title function_">ajax</span>(<span class="hljs-string">&#x27;first&#x27;</span>).<span class="hljs-title function_">success</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">res</span>)&#123;<br>        <span class="hljs-title function_">resolve</span>(res);<br>    &#125;)<br>&#125;)<br>promise.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resovle,reject</span>)=&gt;</span>&#123;<br>        <span class="hljs-title function_">ajax</span>(<span class="hljs-string">&#x27;second&#x27;</span>).<span class="hljs-title function_">success</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">res</span>)&#123;<br>            <span class="hljs-title function_">resolve</span>(res)<br>        &#125;)<br>    &#125;)<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resovle,reject</span>)=&gt;</span>&#123;<br>        <span class="hljs-title function_">ajax</span>(<span class="hljs-string">&#x27;second&#x27;</span>).<span class="hljs-title function_">success</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">res</span>)&#123;<br>            <span class="hljs-title function_">resolve</span>(res)<br>        &#125;)<br>    &#125;)<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;<br>   <br>&#125;)<br></code></pre></td></tr></table></figure></li>
</ol>
<h3 id="6-5-Promise-catch"><a href="#6-5-Promise-catch" class="headerlink" title="6.5 Promise.catch()"></a>6.5 Promise.catch()</h3><p>该方法相当于then的第二个参数，指向reject的回调函数。另一个作用是在执行resolve回调函数前，如果出现错误，抛出异常，不会停止运行，而是进入到catch方法中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    Promise原型对象的 catch()</span><br><span class="hljs-comment">    指定失败的回调函数</span><br><span class="hljs-comment">    返回一个新的 promise 对象</span><br><span class="hljs-comment">*/</span><br><span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">catch</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">onRejected</span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">then</span>(<span class="hljs-literal">undefined</span>,onRejected)<br>&#125;<br><span class="hljs-comment">// 使用方法</span><br><br>p.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;resolved&#x27;</span>,data);<br>&#125;,<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;rejected&#x27;</span>,err);<br>     &#125;<br>);<br>p.<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;resolved&#x27;</span>,data);<br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;rejected&#x27;</span>,err);<br>&#125;);<br></code></pre></td></tr></table></figure>
<h3 id="6-6-Promise-all"><a href="#6-6-Promise-all" class="headerlink" title="6.6 Promise.all()"></a>6.6 Promise.all()</h3><p>该方法用于完成并行任务，让多个Promise任务同时执行，它接收一个数组，数组的每一项都是一个Promise对象。当数组中所有Promise状态都达到resolved成功执行，all方法的状态就是resolved，如果有一个状态变成了rejected，那么all方法的状态就是rejected。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 实现</span><br><span class="hljs-title class_">Promise</span>.<span class="hljs-property">all</span>=<span class="hljs-function">(<span class="hljs-params">promises</span>)=&gt;</span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>    <span class="hljs-keyword">const</span> len = promises.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">const</span> res =[];<br>    <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>      <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(promises[i]).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span>=&gt;</span>&#123;<br>        res[i] = data;<br>        index ++;<br>        <span class="hljs-keyword">if</span>(index ===len)&#123;<br>          <span class="hljs-title function_">resolve</span>(res)<br>        &#125;<br>      &#125;,<span class="hljs-function"><span class="hljs-params">error</span>=&gt;</span>&#123;<br>        <span class="hljs-title function_">reject</span>(error)<br>      &#125;)<br>  &#125;<br>  &#125;)<br>&#125;<br><span class="hljs-comment">// 使用</span><br><span class="hljs-keyword">let</span> promise1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>       <span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>);<br>  &#125;,<span class="hljs-number">2000</span>)<br>&#125;);<br><span class="hljs-keyword">let</span> promise2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>       <span class="hljs-title function_">resolve</span>(<span class="hljs-number">2</span>);<br>  &#125;,<span class="hljs-number">1000</span>)<br>&#125;);<br><span class="hljs-keyword">let</span> promise3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>       <span class="hljs-title function_">resolve</span>(<span class="hljs-number">3</span>);<br>  &#125;,<span class="hljs-number">3000</span>)<br>&#125;);<br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([promise1,promise2,promise3]).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);<br>    <span class="hljs-comment">//结果为：[1,2,3]</span><br>&#125;)<br></code></pre></td></tr></table></figure>
<p>调用all方法时的结果成功的时候是回调函数的参数也是一个数组，这个数组按顺序保存着每一个promise对象resolve执行时的值。</p>
<h3 id="6-7-Promise-race"><a href="#6-7-Promise-race" class="headerlink" title="6.7 Promise.race()"></a>6.7 Promise.race()</h3><p>接收的参数是一个每项都是promise的数组，当最先执行完的事件执行完后，直接返回该Promise对象的值。如果第一个返回的Promise对象状态是resolved，那么自身状态是resolved，反之自身状态为rejected。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 实现</span><br><span class="hljs-title class_">Promise</span>.<span class="hljs-property">race</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">promises</span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>        promises.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">promise</span>=&gt;</span>&#123;<br>            <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(promise).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span>=&gt;</span>&#123;<br>                <span class="hljs-title function_">resolve</span>(date)<br>            &#125;,<span class="hljs-function"><span class="hljs-params">error</span>=&gt;</span>&#123;<br>                <span class="hljs-title function_">reject</span>(error)<br>            &#125;)<br>        &#125;)<br>    &#125;)<br>&#125;<br><span class="hljs-comment">// 使用</span><br><span class="hljs-keyword">let</span> promise1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>       <span class="hljs-title function_">reject</span>(<span class="hljs-number">1</span>);<br>  &#125;,<span class="hljs-number">2000</span>)<br>&#125;);<br><span class="hljs-keyword">let</span> promise2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>       <span class="hljs-title function_">resolve</span>(<span class="hljs-number">2</span>);<br>  &#125;,<span class="hljs-number">1000</span>)<br>&#125;);<br><span class="hljs-keyword">let</span> promise3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>       <span class="hljs-title function_">resolve</span>(<span class="hljs-number">3</span>);<br>  &#125;,<span class="hljs-number">3000</span>)<br>&#125;);<br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>([promise1,promise2,promise3]).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);<br>  <span class="hljs-comment">//结果：2</span><br>&#125;,<span class="hljs-function"><span class="hljs-params">rej</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(rej)&#125;;<br>)<br></code></pre></td></tr></table></figure>
<p>实际中当遇到做一件事，超过多长时间就不做了时，用这个方法来解决：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">Promise<span class="hljs-selector-class">.race</span>(<span class="hljs-selector-attr">[promise1,timeOutPromise(5000)]</span>)<span class="hljs-selector-class">.then</span>(res=&gt;&#123;&#125;)<br></code></pre></td></tr></table></figure>
<h3 id="6-8-Promise-finally"><a href="#6-8-Promise-finally" class="headerlink" title="6.8 Promise.finally()"></a>6.8 Promise.finally()</h3><p>该方法用于指定不管Promise对象最后状态如何，都会执行的操作，在期约落定的时候调用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;···&#125;)<br>.<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;···&#125;)<br>.<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =&gt;</span> &#123;···&#125;);<br></code></pre></td></tr></table></figure>
<p>在上面代码中，不管Promise最后的状态，执行完then或catch指定的回调函数后，会执行finally方法指定的回调函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 实现</span><br><span class="hljs-title class_">Promise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">finally</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">callback</span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>&#123;<br>        <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-title function_">callback</span>(value))<br>    &#125;,<span class="hljs-function"><span class="hljs-params">reason</span>=&gt;</span>&#123;<br>        <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-title function_">callback</span>(reason))<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>finally方法不接收任何参数， 无法知道前面Promise状态是fulfilled还是rejected，这表明finally方法里面的操作与状态无关，不依赖于Promise执行的结果，其本质上是then方法的特例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js">promise.<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">// 语句</span><br>&#125;);<br><span class="hljs-comment">// 等同于</span><br>promise.<span class="hljs-title function_">then</span>(<br>  <span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// 语句</span><br>    <span class="hljs-keyword">return</span> result;<br>  &#125;,<br>  <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// 语句</span><br>    <span class="hljs-keyword">throw</span> error;<br>  &#125;<br>);<br><span class="hljs-comment">// 例：服务器使用Promise处理请求，然后用finally方法关掉服务器</span><br>server.<span class="hljs-title function_">listen</span>(port).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;).<span class="hljs-title function_">finally</span>(server.<span class="hljs-property">stop</span>);<br></code></pre></td></tr></table></figure>

<h2 id="七、Promise解决的问题"><a href="#七、Promise解决的问题" class="headerlink" title="七、Promise解决的问题"></a>七、Promise解决的问题</h2><ol>
<li>回调地狱问题</li>
<li>代码的可读性问题</li>
<li>信任问题<br><strong>回调地狱问题</strong>：指把函数作为参数层层嵌套请求，使得代码阅读性非常差。有时候前端为了能够拿到异步的数据，使用了大量的回调函数，来获取将来异步执行成功之后的数据。例如在使用ajax发送A请求后，成功拿到数据，需要把数据传给B请求：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)<br>fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;./a.txt&#x27;</span>,<span class="hljs-string">&#x27;utf8&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">err,data</span>)&#123;<br>  fs.<span class="hljs-title function_">readFile</span>(data,<span class="hljs-string">&#x27;utf8&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">err,data</span>)&#123;<br>    fs.<span class="hljs-title function_">readFile</span>(data,<span class="hljs-string">&#x27;utf8&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">err,data</span>)&#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data)<br>    &#125;)<br>  &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure>
该代码有几个缺点：一是后一个请求依赖于前一个请求成功后，把数据向下传递，会导致多个ajax请求嵌套，代码不够直观，二是如果前后两个请求不需要传递参数的情况下，后一个请求也需要前一个请求成功后再执行下一步操作，这种情况下也需要这样编写代码，导致代码不够直观。若采用Promise：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">read</span>(<span class="hljs-params">url</span>)&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>    fs.<span class="hljs-title function_">readFile</span>(url,<span class="hljs-string">&#x27;utf8&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">error,data</span>)&#123;<br>      error &amp;&amp; <span class="hljs-title function_">reject</span>(error);<br>      <span class="hljs-title function_">resolve</span>(data);<br>    &#125;)<br>  &#125;)<br>&#125;<br><span class="hljs-title function_">read</span>(<span class="hljs-string">&#x27;./a.txt&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span>=&gt;</span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">read</span>(data)<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span>=&gt;</span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">read</span>(data)  <br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span>=&gt;</span>&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data)<br>&#125;)<br></code></pre></td></tr></table></figure></li>
</ol>
<h2 id="★八、Promise-all和Promise-race的区别和使用场景"><a href="#★八、Promise-all和Promise-race的区别和使用场景" class="headerlink" title="★八、Promise.all和Promise.race的区别和使用场景"></a>★八、Promise.all和Promise.race的区别和使用场景</h2><h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h3><p>可以将多个Promise对象包装成一个新的Promise对象，成功时返回的值是一个结果数组，失败的时候返回的是最先被reject失败状态的值。<br>Promise.all中传入的是数组，返回的也是数组，并且会进行映射，传入的Promise对象返回的值是按照顺序在数组中排列的，但是执行的顺序并不是按照顺序执行，除非可迭代对象为空。<br>Promise.all获得的成功结果的数据里面的数据顺序和Promise.all接收到的数组顺序是一致的，当遇到发送多个请求并根据请求顺序获取和使用数据的场景，就可以使用Promise.all来解决。</p>
<h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h3><p>看哪个结果获得的快就返回哪个结果，不管结果本身是兑现状态还是拒绝状态。<br>当需要做一件事，超过多长时间就不做了，可以使用这个方法来解决：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>([promise1,<span class="hljs-title function_">timeOutPromise</span>(<span class="hljs-number">5000</span>)]).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;&#125;)<br></code></pre></td></tr></table></figure>
<h2 id="九、async-x2F-await"><a href="#九、async-x2F-await" class="headerlink" title="九、async&#x2F;await"></a>九、async&#x2F;await</h2><h3 id="9-1-async-x2F-await的概念和理解"><a href="#9-1-async-x2F-await的概念和理解" class="headerlink" title="9.1 async&#x2F;await的概念和理解"></a>9.1 async&#x2F;await的概念和理解</h3><p>async&#x2F;await是生成器Generator的语法糖，它能实现的效果都能用then链来实现，是为了优化then链而开发出来的。<br>async&#x2F;await是基于Promise实现的，不能用于普通的回调函数，与Promise一样是异步的、非阻塞的，它使得异步代码看起来像是同步代码。<br>一个函数如果加上async，那么该函数就会返回一个Promise，async就是将函数返回值用Promise.resolve()进行了包裹，和then中处理返回值一样，并且<strong>await只能在async声明的函数内使用</strong>。<br><strong>async作用</strong>：以async声明的函数返回的是一个Promise对象，如果函数有返回值，async会把这个返回值通过Promise.resolve()封装成Promise对象，可以使用then链来继续处理这个Promise对象。如果函数没有返回值，返回Promise.resolve(undefined).<br><strong>await作用</strong>：await命令后跟的是一个Promise对象，它接收一个期约并将其转换为一个返回值或一个抛出的异常，等待Promise对象状态发生改变，得到返回值，也可以是任意表达式返回的结果。<br>await后面不管接的是什么表达式，都能等待到结果的返回，当等到的不是Promise对象时，就将等到的结果返回；否则会阻塞后面的代码，等待Promise对象状态的变化，得到对应的值作为await等待的结果，这里阻塞指的是async内部的阻塞，async函数的调用并不会阻塞。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">testAsy</span>(<span class="hljs-params"></span>)&#123;<br>   <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;hello world&#x27;</span><br>&#125;<br><span class="hljs-keyword">let</span> result = <span class="hljs-title function_">testAsy</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result)<br>result.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">v</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(v)   <span class="hljs-comment">// hello world</span><br>&#125;)<br></code></pre></td></tr></table></figure>
<h3 id="9-2-async-x2F-await带来和解决了什么问题"><a href="#9-2-async-x2F-await带来和解决了什么问题" class="headerlink" title="9.2 async&#x2F;await带来和解决了什么问题"></a>9.2 async&#x2F;await带来和解决了什么问题</h3><p><strong>解决了</strong>：每个Promise相当于一个异步的网络请求，通常一个业务流程需要多个网络请求，而且网络请求都依赖一个请求结果。相比于Promise的then链调用相比，async&#x2F;await调用个更加清晰简单。<br><strong>带来了</strong>：使用它会导致同步执行带来的时间累加，使得程序变慢，有时会让并发执行的代码变成了继发执行。</p>
<h3 id="9-3-await在等待什么"><a href="#9-3-await在等待什么" class="headerlink" title="9.3 await在等待什么"></a>9.3 await在等待什么</h3><p>await等待后面表达式的计算，其计算结果为Promise对象或其它值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getSomething</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;something&quot;</span>;<br>&#125;<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">testAsync</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;hello async&quot;</span>);<br>&#125;<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> v1 = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getSomething</span>();<br>    <span class="hljs-keyword">const</span> v2 = <span class="hljs-keyword">await</span> <span class="hljs-title function_">testAsync</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(v1, v2); <br>&#125;<br><span class="hljs-title function_">test</span>();<br></code></pre></td></tr></table></figure>
<p>await 表达式的运算结果取决于它等的是什么，如果等到的不是一个Promise对象，那await表达式的运算结果就是它等到的东西；如果它等到的是一个Promise对象，await会阻塞后面代码直到Promise对象resolve，然后得到resolve的值作为await表达式的运算结果。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">testAsy</span>(<span class="hljs-params">x</span>)&#123;<br>   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span>=&gt;</span>&#123;<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>       <span class="hljs-title function_">resolve</span>(x);<br>     &#125;, <span class="hljs-number">3000</span>)<br>    &#125;<br>   )<br>&#125;<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">testAwt</span>(<span class="hljs-params"></span>)&#123;    <br>  <span class="hljs-keyword">let</span> result =  <span class="hljs-keyword">await</span> <span class="hljs-title function_">testAsy</span>(<span class="hljs-string">&#x27;hello world&#x27;</span>);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);    <span class="hljs-comment">// 3秒钟之后出现hello world</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;cuger&#x27;</span>)   <span class="hljs-comment">// 因为前面导致阻塞，3秒钟之后出现cug</span><br>&#125;<br><span class="hljs-title function_">testAwt</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;cug&#x27;</span>)  <span class="hljs-comment">//立即输出cug</span><br></code></pre></td></tr></table></figure>
<p><strong>await必须在async函数中使用</strong>：是因为async函数调用不会导致阻塞，其内部所有阻塞都被封装在一个Promise对象中异步执行，await暂停当前async的执行，所以先输出cug，3s后再出现hello world和cuger。</p>
<h3 id="9-4-async-x2F-await优势"><a href="#9-4-async-x2F-await优势" class="headerlink" title="9.4 async&#x2F;await优势"></a>9.4 async&#x2F;await优势</h3><ul>
<li>代码读起来更加清晰，Promise虽然解决了回调地狱，但then的链式调用也会带来阅读负担。</li>
<li>Promise传递中间值非常麻烦，而async&#x2F;await几乎是同步写法。</li>
<li>错误处理友好，async&#x2F;await使用成熟的try&#x2F;catch，Promise的错误捕获非常冗余。</li>
<li>调试友好，Promise调试很差，由于没有代码块，不能在返回表达式的箭头函数中设置断点，如果在一个then代码块中使用调试器的步进功能，调试器不会进入后续的then代码块，因为调试器只能跟踪同步代码的每一步。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 用Promise写</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">doIt</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">time</span>(<span class="hljs-string">&quot;doIt&quot;</span>);<br>    <span class="hljs-keyword">const</span> time1 = <span class="hljs-number">300</span>;<br>    <span class="hljs-title function_">step1</span>(time1)<br>        .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">time2</span> =&gt;</span> <span class="hljs-title function_">step2</span>(time2))<br>        .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">time3</span> =&gt;</span> <span class="hljs-title function_">step3</span>(time3))<br>        .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`result is <span class="hljs-subst">$&#123;result&#125;</span>`</span>);<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">timeEnd</span>(<span class="hljs-string">&quot;doIt&quot;</span>);<br>        &#125;);<br>&#125;<br><span class="hljs-title function_">doIt</span>();<br><span class="hljs-comment">// 用async/await</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">doIt</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">time</span>(<span class="hljs-string">&quot;doIt&quot;</span>);<br>    <span class="hljs-keyword">const</span> time1 = <span class="hljs-number">300</span>;<br>    <span class="hljs-keyword">const</span> time2 = <span class="hljs-keyword">await</span> <span class="hljs-title function_">step1</span>(time1);<br>    <span class="hljs-keyword">const</span> time3 = <span class="hljs-keyword">await</span> <span class="hljs-title function_">step2</span>(time2);<br>    <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> <span class="hljs-title function_">step3</span>(time3);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`result is <span class="hljs-subst">$&#123;result&#125;</span>`</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">timeEnd</span>(<span class="hljs-string">&quot;doIt&quot;</span>);<br>&#125;<br><span class="hljs-title function_">doIt</span>();<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="9-5-async-x2F-await如何捕获异常"><a href="#9-5-async-x2F-await如何捕获异常" class="headerlink" title="9.5 async&#x2F;await如何捕获异常"></a>9.5 async&#x2F;await如何捕获异常</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">try</span>&#123;<br>        <span class="hljs-keyword">let</span> a = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;error&#x27;</span>)<br>    &#125;<span class="hljs-keyword">catch</span>(error)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="★十、js为什么是单线程的"><a href="#★十、js为什么是单线程的" class="headerlink" title="★十、js为什么是单线程的"></a>★十、js为什么是单线程的</h2><p>主要和js用途有关。js作为浏览器脚本语言，主要是实现用户与浏览器的交互，以及操作dom，这决定了它只能是单线程，否则会带来很复杂的同步问题。例如：若js是多线程，如果有一个线程要修改一个dom元素，另一个元素要删除这个dom元素，此时会发生冲突。</p>
<h2 id="★十一、同步任务和异步任务、消息队列和事件循环"><a href="#★十一、同步任务和异步任务、消息队列和事件循环" class="headerlink" title="★十一、同步任务和异步任务、消息队列和事件循环"></a>★十一、同步任务和异步任务、消息队列和事件循环</h2><p><strong>同步任务</strong>：等待上一个事件执行完毕才执行下文，会阻塞，等待时间长，这种同步执行的操作容易使页面呈卡死状态，异步可以解决阻塞。<br><strong>异步任务</strong>：不等前一个任务结束就执行。不进入主线程、而进入”任务队列”的任务，只有等主线程任务执行完毕，”任务队列”开始通知主线程，请求执行任务，该任务才会进入主线程执行。<br><strong>消息队列（任务队列）</strong>：先进先出队列，里面存放着异步操作的回调函数，异步操作会把相关的回调函数添加到任务队列中，不同的异步操作添加到任务队列的时机不同。如：onclick事件触发时回调函数会立即加入到消息队列、setTimeout会进行延时处理直到到达指定时间时才将回调函数放入消息队列、ajax会在网络请求完成返回后将回调添加到任务队列。<br><strong>事件循环</strong>：js会创建一个类似while（true）的循环，每执行一次循环体的过程称为Tick，每次Tick就是看是否有待处理时间，有就取出相关事件及回调函数放入执行栈由主线程执行，待处理的事件会放到任务队列中。</p>
<h2 id="十二、手写Ajax请求"><a href="#十二、手写Ajax请求" class="headerlink" title="十二、手写Ajax请求"></a>十二、手写Ajax请求</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">ajax</span>(<span class="hljs-params">url</span>) &#123;<br>    <span class="hljs-comment">// 创建一个 XHR 对象</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>()<br>        <span class="hljs-comment">// 指定请求类型，请求URL，和是否异步</span><br>        xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;GET&#x27;</span>, url, <span class="hljs-literal">true</span>)<br>        xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-title function_">funtion</span>(<span class="hljs-params"></span>) &#123;<br>          <span class="hljs-comment">// 表明数据已就绪</span><br>            <span class="hljs-keyword">if</span>(xhr.<span class="hljs-property">readyState</span> === <span class="hljs-number">4</span>) &#123;<br>                <span class="hljs-keyword">if</span>(xhr.<span class="hljs-property">status</span> === <span class="hljs-number">200</span>)&#123;<br>                    <span class="hljs-comment">// 回调</span><br>                    <span class="hljs-title function_">resolve</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(xhr.<span class="hljs-property">responseText</span>))<br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;error&#x27;</span>)<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 发送定义好的请求</span><br>        xhr.<span class="hljs-title function_">send</span>(<span class="hljs-literal">null</span>)<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure>
            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E5%8E%9F%E5%88%9B/">原创</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/08/10/Vue%E4%B8%8B/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Vue下</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/07/13/JavaScript%E4%B8%8A/">
                        <span class="hidden-mobile">JavaScript上</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/valine@1/dist/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"sOHs1UX9yhu45mOPqVuIjOkh-gzGzoHsz","appKey":"JlU9ppAdc6X2IEPeXLgdlFGc","path":"window.location.pathname","placeholder":null,"avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          Fluid.plugins.initFancyBox('#valine .vcontent img:not(.vemoji)');
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- LeanCloud 统计PV -->
        <span id="leancloud-site-pv-container" style="display: none">
            总访问量 
            <span id="leancloud-site-pv"></span>
             次
          </span>
      
      
        <!-- LeanCloud 统计UV -->
        <span id="leancloud-site-uv-container" style="display: none">
            总访客数 
            <span id="leancloud-site-uv"></span>
             人
          </span>
      

    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  




  <script defer src="/js/leancloud.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>












  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
