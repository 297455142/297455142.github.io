

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="WBY">
  <meta name="keywords" content="">
  
    <meta name="description" content="一、HTTP请求方法 GET：使用url从指定的资源请求数据，只是检索数据，不会对数据产生其他影响。请求的数据量有限，请求的数据放在url里，例如&#x2F;test&#x2F;demo.php?name1&#x3D;value1&amp;name2&#x3D;value2。处理敏感数据时不可以用GET，请求可以被缓存。 POST：向指定的资源提交要被处理的数据，用以创建或更新资源，对数据长度没有">
<meta property="og:type" content="article">
<meta property="og:title" content="应用层(HTTP+DNS)">
<meta property="og:url" content="http://example.com/2022/07/06/%E5%BA%94%E7%94%A8%E5%B1%82-HTTP/index.html">
<meta property="og:site_name" content="前端面试总结">
<meta property="og:description" content="一、HTTP请求方法 GET：使用url从指定的资源请求数据，只是检索数据，不会对数据产生其他影响。请求的数据量有限，请求的数据放在url里，例如&#x2F;test&#x2F;demo.php?name1&#x3D;value1&amp;name2&#x3D;value2。处理敏感数据时不可以用GET，请求可以被缓存。 POST：向指定的资源提交要被处理的数据，用以创建或更新资源，对数据长度没有">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2022/07/06/%E5%BA%94%E7%94%A8%E5%B1%82-HTTP/%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87.png">
<meta property="og:image" content="http://example.com/2022/07/06/%E5%BA%94%E7%94%A8%E5%B1%82-HTTP/DHCP.png">
<meta property="article:published_time" content="2022-07-06T06:57:24.000Z">
<meta property="article:modified_time" content="2022-09-23T17:10:04.084Z">
<meta property="article:author" content="WBY">
<meta property="article:tag" content="原创">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/2022/07/06/%E5%BA%94%E7%94%A8%E5%B1%82-HTTP/%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87.png">
  
  
  <title>应用层(HTTP+DNS) - 前端面试总结</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"sOHs1UX9yhu45mOPqVuIjOkh-gzGzoHsz","app_key":"JlU9ppAdc6X2IEPeXLgdlFGc","server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.1.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>前端面试总结</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="应用层(HTTP+DNS)">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-07-06 14:57" pubdate>
        2022年7月6日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      19k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      155 分钟
    </span>
  

  
  
    
      <!-- LeanCloud 统计文章PV -->
      <span id="leancloud-page-views-container" class="post-meta" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="leancloud-page-views"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">应用层(HTTP+DNS)</h1>
            
            <div class="markdown-body">
              <h2 id="一、HTTP请求方法"><a href="#一、HTTP请求方法" class="headerlink" title="一、HTTP请求方法"></a>一、HTTP请求方法</h2><ul>
<li>GET：使用url从指定的资源请求数据，只是检索数据，不会对数据产生其他影响。请求的数据量有限，请求的数据放在url里，例如&#x2F;test&#x2F;demo.php?name1&#x3D;value1&amp;name2&#x3D;value2。处理敏感数据时不可以用GET，<strong>请求可以被缓存</strong>。</li>
<li>POST：向指定的资源提交要被处理的数据，用以创建或更新资源，对数据长度没有限制，无法被缓存。</li>
<li>HEAD：获取报文首部，与GET相同，没有响应体，只传输状态行和标题部分，只返回HTTP报头。</li>
<li>PUT：用于将数据发送到服务器以创建或更新资源，用上传的内容替换目标资源中所有当前内容。会将包含的元素放在所提供的url下，如果url指示的是当前资源，则会发生改变。如果url未指示当前资源，则服务器可以使用该url创建资源。</li>
<li>DELETE：用来删除指定资源，删除url给出的目标资源的所有当前内容。</li>
<li>CONNECT：建立到给定url表示的服务器隧道，把请求连接转换到透明的TCP&#x2F;IP通道。</li>
<li>OPTIONS：返回服务器支持的HTTP方法，用来跨域请求。</li>
<li>TRACE：沿到目标资源的路径执行消息环回测试（从通信设备发出的信号又返回原处）。</li>
<li>PATCH：对PUT的补充，对已知资源进行<strong>局部</strong>更新。</li>
</ul>
<h2 id="二、HTTP请求报文和响应报文的格式"><a href="#二、HTTP请求报文和响应报文的格式" class="headerlink" title="二、HTTP请求报文和响应报文的格式"></a>二、HTTP请求报文和响应报文的格式</h2> <img src="/2022/07/06/%E5%BA%94%E7%94%A8%E5%B1%82-HTTP/%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87.png" srcset="/img/loading.gif" lazyload class="" title="请求报文的格式"> 

<h3 id="请求报文：请求行-首部行-空行-请求体"><a href="#请求报文：请求行-首部行-空行-请求体" class="headerlink" title="请求报文：请求行+首部行+空行+请求体"></a>请求报文：请求行+首部行+空行+请求体</h3><ul>
<li>请求行：方法、URL、HTTP版本（所用的协议）。</li>
<li>首部行（请求头信息）：多组键值对，首部3字段名+值，包括请求体的长度等等。</li>
<li>请求体：GET时为空，POST时不空。</li>
</ul>
<h3 id="响应报文：响应行-响应头信息-空行-主体信息"><a href="#响应报文：响应行-响应头信息-空行-主体信息" class="headerlink" title="响应报文：响应行+响应头信息+空行+主体信息"></a>响应报文：响应行+响应头信息+空行+主体信息</h3><ul>
<li>响应行：协议、状态码、状态文字，如HTTP&#x2F;1.1 200 OK</li>
<li>响应头信息：键值对</li>
<li>主体信息：可能为空，服务器相应的数据</li>
</ul>
<h2 id="三、HTTP和HTTPS的区别"><a href="#三、HTTP和HTTPS的区别" class="headerlink" title="三、HTTP和HTTPS的区别"></a>三、HTTP和HTTPS的区别</h2><ul>
<li>HTTP是一种超文本传输协议，基于TCP协议。</li>
<li>HTTP明文传输，数据都是未加密的，可以直接获取其中消息，安全性较差，HTTPS数据传输过程是ssl加密的，安全性较好。</li>
<li>HTTPS协议需要到CA证书，费用较高，HTTP不需要。</li>
<li>HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li>
<li>HTTP的连接很简单，是无状态的331，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比HTTP协议安全。</li>
<li>HTTP页面相应速度比HTTPS快，主要是因为HTTP使用TCP三次握手建立连接，客户端和服务器需要交换三个包。而HTTPS除了TCP的三个包，还要加上SSL握手需要的9个包，一共是12个包。</li>
<li>HTTPS就是构建在SSL&#x2F;TLS之上的HTTP协议，所以HTTPS比HTTP更耗费服务器资源。</li>
</ul>
<h2 id="★四、HTTP的状态码"><a href="#★四、HTTP的状态码" class="headerlink" title="★四、HTTP的状态码"></a>★四、HTTP的状态码</h2><p>1xx：提示信息，是协议处理的中间状态，还需要后续的操作</p>
<p>2xx：表示服务器成功处理了客户端的请求，报文已经收到并被正确处理</p>
<p>3xx：重定向，表示客户端请求的资源发生了变动，需要客户端用新的url重亲发送请求获取资源</p>
<p>4xx：表示客户端发送的报文有误</p>
<p>5xx：表示客户端请求报文正确，但是服务器处理时内部发生了错误</p>
<h3 id="1xx：提示信息，是协议处理的中间状态，还需要后续的操作"><a href="#1xx：提示信息，是协议处理的中间状态，还需要后续的操作" class="headerlink" title="1xx：提示信息，是协议处理的中间状态，还需要后续的操作"></a>1xx：提示信息，是协议处理的中间状态，还需要后续的操作</h3><ul>
<li>100 Continue：继续，客户端应继续其请求。</li>
<li>101 Switching Protocols：服务器根据客户端请求切换协议，只能切换到更高级的协议，例如切换到HTTP新版本的协议。</li>
</ul>
<h3 id="2xx：表示服务器成功处理了客户端的请求，报文已经收到并被正确处理"><a href="#2xx：表示服务器成功处理了客户端的请求，报文已经收到并被正确处理" class="headerlink" title="2xx：表示服务器成功处理了客户端的请求，报文已经收到并被正确处理"></a>2xx：表示服务器成功处理了客户端的请求，报文已经收到并被正确处理</h3><ul>
<li>200 OK：成功状态码，表示一切正常。非HEAD请求时服务器返回的响应头会有body数据。</li>
<li>201 Created：已创建，成功请求并创建了新的资源。</li>
<li>202 Accepted：已接收，已经接收请求，但未处理完成。</li>
<li>203 Non-Authoritative Information：非授权信息，请求成功但返回的meta信息不在原始的服务器，而是一个副本。</li>
<li>204 No Content：成功状态码，响应头没有body数据。</li>
<li>205 Reset Content：请求成功，但响应报文不含实体的主体部分，但与204不同的是要求请求方重置内容。</li>
<li>206 Partial Content：应用于HTTP分块下载或断点续传，表示响应返回的body数据并不是资源的全部，只是其中一部分。</li>
</ul>
<h3 id="3xx：重定向，表示客户端请求的资源发生了变动，需要客户端用新的url重亲发送请求获取资源"><a href="#3xx：重定向，表示客户端请求的资源发生了变动，需要客户端用新的url重亲发送请求获取资源" class="headerlink" title="3xx：重定向，表示客户端请求的资源发生了变动，需要客户端用新的url重亲发送请求获取资源"></a>3xx：重定向，表示客户端请求的资源发生了变动，需要客户端用新的url重亲发送请求获取资源</h3><ul>
<li>301 Moved Permanently：永久重定向，说明请求资源已经不存在了，需改用新的URL再次访问。</li>
<li>302 Found：临时重定向，说明请求的资源还在，但暂时需要用另一个URL访问。</li>
<li>303 see other：表示资源存在另一个url，应使用GET方法获取资源。</li>
<li>304 Not Modified：未修改，自从上次请求后，请求的网页未修改过。</li>
<li>305 Use Proxy：使用代理，请求者只能使用代理访问请求的网页。</li>
<li>306 Unused：已经被废弃的HTTP状态码。</li>
<li>307 Temporary Redirect：临时重定向，类似302，但是期望客户端保持请求方法不变向新地址发出请求。</li>
</ul>
<h3 id="4xx：表示客户端发送的报文有误"><a href="#4xx：表示客户端发送的报文有误" class="headerlink" title="4xx：表示客户端发送的报文有误"></a>4xx：表示客户端发送的报文有误</h3><ul>
<li>400 Bad Request：表示客户端请求的报文有误。</li>
<li>401 Unauthorized：表示发送的请求需要有通过HTTP认证的认证信息。</li>
<li>402 Payment Required：保留，将来使用。</li>
<li>403 Forbidden：表示服务器禁止访问资源。</li>
<li>404 Not Found：表示请求的资源在服务器上不存在或未找到。</li>
<li>405 Method Not Allowed：客户端请求中的方法被禁止。</li>
<li>406 Not Acceptable：服务器无法根据客户端请求的内容特性完成请求。</li>
<li>407: Proxy Authentication Required：请求要求代理的身份认证，类似401，但请求者应当使用代理进行授权。</li>
<li>408 Request Time-out：服务器等待客户端发送的请求时间过长，超时。</li>
<li>409 Confilct：服务器完成客户端的PUT请求时可能返回此代码，服务器处理请求时发生了冲突。</li>
<li>410 Gone：客户端请求的资源已经不存在。资源以前有现在被永久删除了。</li>
<li>411 Length Required：服务器无法处理客户端发送的不带Content-Length的请求信息。</li>
<li>412 Precondition Failed：客户端请求信息的先决条件错误。</li>
<li>413 Request Entity Too Large：由于请求实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息。</li>
<li>414 Request-URI Too Large：请求的URI过长，服务器无法处理。</li>
<li>415 Unsupported Media Type：服务器无法处理请求附带的媒体格式。</li>
<li>416 Requested Range Not Satisfiable：客户端请求的范围无效。</li>
<li>417 Expectation Failed：服务器无法满足Expect的请求头消息。</li>
</ul>
<h3 id="5xx：表示客户端请求报文正确，但是服务器处理时内部发生了错误"><a href="#5xx：表示客户端请求报文正确，但是服务器处理时内部发生了错误" class="headerlink" title="5xx：表示客户端请求报文正确，但是服务器处理时内部发生了错误"></a>5xx：表示客户端请求报文正确，但是服务器处理时内部发生了错误</h3><ul>
<li>500 Internal Server Error：服务器发生错误。</li>
<li>501 Not Implemented：表示客户端请求的功能还不支持。</li>
<li>502 Bad Gateway：通常是在服务器作为网关或代理时，服务器自身工作正常，访问后端服务器发生错误。</li>
<li>503 Service Unavailable：表示服务器当前忙，暂时无法相应服务器。</li>
<li>504 Gateway Time-out：充当网关或代理的服务器未及时从远端服务器获取请求。</li>
<li>505 HTTP Version not supported：服务器不支持请求的HTTP协议的版本，无法完成处理。</li>
</ul>
<h2 id="五、HTTP原理和优缺点"><a href="#五、HTTP原理和优缺点" class="headerlink" title="五、HTTP原理和优缺点"></a>五、HTTP原理和优缺点</h2><h3 id="5-1-HTTP原理"><a href="#5-1-HTTP原理" class="headerlink" title="5.1 HTTP原理"></a>5.1 HTTP原理</h3><p>1、客户端浏览器首先通过网络与服务器建立连接，该连接通过TCP完成，端口号一般为80。建立连接环后客户端发送一个请求给服务器，请求方式的格式为：URL、协议版本号、MIME信息（包括请求修饰符、客户机信息和许可内容）。<br>2、服务器接收到请求后，返回对应的相应信息，格式为状态行（协议版本号、状态码）、MIME信息（服务器信息和可能的内容）</p>
<h3 id="5-2-HTTP的优点和缺点"><a href="#5-2-HTTP的优点和缺点" class="headerlink" title="5.2 HTTP的优点和缺点"></a>5.2 HTTP的优点和缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>支持客户端&#x2F;服务器模式</li>
<li><strong>简单快捷</strong>：客户端向服务器请求服务时，只需传送请求方法和路径。由于HTTP协议简单，使得HTTP服务器程序规模小，因此通信速度很快。</li>
<li><strong>无连接</strong>：限制每次连接只处理一个请求，服务器处理完客户的请求，并收到客户的应答后，即断开连接，采用这种方式可以节省传输时间。</li>
<li><strong>无状态</strong>：状态是指通信过程的上下文信息。缺少状态意味着如果后续处理需要前面的信息，它必须重传，这样可能会导致每次连接传送的数据量增大。但服务器不需要前面信息时它应答的就比较快。</li>
<li><strong>灵活</strong>：HTTP允许传输任意类型的数据对象，正在传输的类型由 Content-Type 加以标记。<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4></li>
<li><strong>无状态</strong>：HTTP是无状态的协议，HTTP服务器不会保存关于客户的任何消息。</li>
<li><strong>明文传输</strong>：协议中的报文使用的是文本形式，直接暴露给外界。</li>
<li><strong>不安全</strong>：通信使用明文，内容可能会被窃听；不验证通信方的身份，因此可能遭遇伪装；无法证明报文完整性，报文可能被篡改。</li>
</ul>
<h2 id="六、不同版本的HTTP"><a href="#六、不同版本的HTTP" class="headerlink" title="六、不同版本的HTTP"></a>六、不同版本的HTTP</h2><h3 id="6-1-HTTP-1-0和HTTP-1-1-区别"><a href="#6-1-HTTP-1-0和HTTP-1-1-区别" class="headerlink" title="6.1 HTTP 1.0和HTTP 1.1 区别"></a>6.1 HTTP 1.0和HTTP 1.1 区别</h3><ul>
<li><strong>连接</strong>：HTTP 1.0使用非持久连接，每次发送数据都会经过TCP的三次握手和四次挥手，效率较低。HTTP 1.1使用持久连接，一次建立可以传输多次数据，避免使用持久连接时每次需要建立连接的时延。</li>
<li><strong>资源请求方面</strong>：HTTP 1.0 不支持断点续传，每次都会传送全部的页面和数据；HTTP 1.1支持断点续传，在请求头引入了range，方便开发者自由选择以便充分利用带宽和连接。</li>
<li><strong>缓存方面</strong>：HTTP 1.0中只使用了header里的If-Modifed-Since和Expries作为缓存失效的标准；HTTP 1.1中增加了更多的缓存控制策略，例如E-tag、If-Unmodified-Since、If-Match、If-None-Match等缓存头来控制缓存策略。</li>
<li><strong>身份验证</strong>：HTTP 1.0仅仅提供了最基本的认证，这时候用户名和密码还未加密，很容易被窥探；HTTP 1.1使用摘要算法来进行身份验证。 </li>
<li><strong>IP地址</strong>：HTTP 1.0认为每台计算机都绑定唯一的一个IP，所以请求消息中的URL并没有传递主机名；HTTP 1.1使用了虚拟网络，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个IP地址，增加了host字段，可以将请求发往同一台服务器的不同网站。</li>
<li><strong>请求方法</strong>：HTTP 1.1比HTTP 1.0新增了很多请求方法，如PUT、HEAD、OPTIONS。<h3 id="6-2-HTTP-2-0与HTTP-1-1"><a href="#6-2-HTTP-2-0与HTTP-1-1" class="headerlink" title="6.2 HTTP 2.0与HTTP 1.1"></a>6.2 HTTP 2.0与HTTP 1.1</h3></li>
<li><strong>头部压缩</strong>：HTTP 1.1协议不带状态，每次请求必须附上所有信息，浪费带宽，影响速度。HTTP 2.0使用了HPACK算法进行了压缩，同时客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不用发送同样字段只用发索引号。</li>
<li><strong>多路复用</strong>：HTTP 2.0中每一个请求都是用作连接共享，一个请求对应一个id，一个连接上可以有多个请求，一个连接里客户端和服务器都可以同时发送多个请求或回应，避免了队头堵塞问题。</li>
<li><strong>二进制协议</strong>：在HTTP 1.1中报文的头信息必须是ASCII码，数据体可以是文本，也可以是二进制。HTTP 2.0中头信息和数据体都是二进制，提升了解析效率。</li>
<li><strong>数据流</strong>：HTTP 2.0使用了数据流，因为HTTP 2.0的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的请求。HTTP2.0将每个请求或回应的所有数据包称为一个数据流，每个数据流都有唯一的编号，数据包发送时必须标记数据流ID来区分数据哪个数据流。</li>
<li><strong>服务器推送</strong>：HTTP2.0允许服务器未经请求，主动向客户端发送资源。使用服务器推送提前给客户端推送必要的资源，减少延迟时间。这里推送的是静态资源。</li>
</ul>
<h3 id="6-3-HTTP-3-0"><a href="#6-3-HTTP-3-0" class="headerlink" title="6.3 HTTP 3.0"></a>6.3 HTTP 3.0</h3><p>HTTP3.0基于UDP协议实现了类似于TCP的多路复用数据流、传输可靠性等功能，使用了QUIC协议。</p>
<ul>
<li><strong>多路复用</strong>：TCP协议没有多路复用功能，QUIC实现了这个功能，并且传输单个数据流可以保证有序交付且不会影响其它的数据流，解决了TCP存在的问题。</li>
<li><strong>0~1RTT</strong>：使用类似TCP快速打开的技术，缓存当前会话的上下文，下次恢复会话时只需将之前缓存传递给服务器端验证通过就可以进行传输了。使用TLS1.3减少握手花费的RTT数。</li>
<li><strong>流量控制、传输可靠性功能</strong>：QUIC在UDP的基础上增加了一层来保证数据传输的可靠性，它提供了数据包重传、拥塞控制等TCP中的特性。</li>
</ul>
<h2 id="七、即时通讯中短轮询、长轮询、SSE和websocket的区别"><a href="#七、即时通讯中短轮询、长轮询、SSE和websocket的区别" class="headerlink" title="七、即时通讯中短轮询、长轮询、SSE和websocket的区别"></a>七、即时通讯中短轮询、长轮询、SSE和websocket的区别</h2><ul>
<li><strong>短轮询</strong>：浏览器每隔一段时间向服务器发送http请求，服务器收到请求后，不论是否有数据更新，都直接进行响应。这种方式实现的即时通信，本质上还是浏览器发送请求，服务器接受请求的一个过程，通过让客户端不断的进行请求，使得客户端能够模拟实时地收到服务器端的数据的变化。这种方式的优点是比较简单，易于理解。缺点是这种方式由于需要不断的建立 http 连接，严重浪费了服务器端和客户端的资源。当用户增加时，服务器端的压力就会变大。</li>
<li><strong>长轮询</strong>：首先由客户端向服务器发起请求，当服务器收到客户端发来的请求后，服务器端不会直接进行响应，而是先将这个请求挂起，然后判断服务器端数据是否有更新。如果有更新，则进行响应，如果一直没有数据，则到达一定的时间限制才返回。客户端 JavaScript 响应处理函数会在处理完服务器返回的信息后，再次发出请求，重新建立连接。长轮询和短轮询比起来，它的优点是明显减少了很多不必要的 http 请求次数，相比之下节约了资源。长轮询的缺点在于，连接挂起也会导致资源的浪费。</li>
<li><strong>SSE</strong>：服务器使用流信息向服务器推送信息。严格地说，http 协议无法做到服务器主动推送信息。办法是服务器向客户端声明，接下来要发送的是流信息。发送的不是一次性的数据包，而是一个数据流，会连续不断地发送过来。这时，客户端不会关闭连接，会一直等着服务器发过来的新的数据流，视频播放就是这样的例子。SSE 就是利用这种机制，使用流信息向浏览器推送信息。它基于 http 协议，目前除了 IE&#x2F;Edge，其他浏览器都支持。它相对于前面两种方式来说，不需要建立过多的 http 请求，相比之下节约了资源。</li>
<li><strong>websocket</strong>：HTTP5新定义的协议，允许服务器主动向客户端推送信息，缺点是服务器端的配置比较复杂。websocket是一个全双工的协议，通信双方是平等的，可以互相发送消息，SSE是单向的，只能从服务器向客户端推送信息，客户端需要发送信息就属于下一个HTTP请求了。</li>
<li>短轮询、长轮询、SSE是基于HTTP协议，性能上来看后比前好，兼容性前比后好。</li>
</ul>
<h2 id="八、常见请求头和响应头"><a href="#八、常见请求头和响应头" class="headerlink" title="八、常见请求头和响应头"></a>八、常见请求头和响应头</h2><p>请求和响应的首部分为请求首部和响应首部，部分首部两者通用。</p>
<h3 id="8-1-通用首部"><a href="#8-1-通用首部" class="headerlink" title="8.1 通用首部"></a>8.1 通用首部</h3><table>
<thead>
<tr>
<th>通用字段</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>Cache-Control</td>
<td>控制缓存的行为。Cache-Control 是一个通用标头，他可以出现在请求标头和响应标头中，Cache-Control 的种类比较多，虽然说这是一个通用标头，但是又一些特性是请求标头具有的，有一些是响应标头才有的。主要大类有 可缓存性、阈值性、 重新验证并重新加载 和其他特性</td>
</tr>
<tr>
<td>Connection</td>
<td>浏览器想要优先使用的连接类型，比如 keep-alive。  Connection 决定当前事务（一次三次握手和四次挥手）完成后，是否会关闭网络连接。Connection 有两种，一种是持久性连接，即一次事务完成后不关闭网络连接  Connection: keep-alive   另一种是非持久性连接，即一次事务完成后关闭网络连接  Connection: close</td>
</tr>
<tr>
<td>Date</td>
<td>创建报文时间。表示的是格林威治标准时间，这个时间要比北京时间慢八个小时</td>
</tr>
<tr>
<td>Pragma</td>
<td>报文指令</td>
</tr>
<tr>
<td>Via</td>
<td>代理服务器相关信息</td>
</tr>
<tr>
<td>Transfer-Encoding</td>
<td>传输编码方式</td>
</tr>
<tr>
<td>Upgrade</td>
<td>要求客户端升级协议</td>
</tr>
<tr>
<td>Warning</td>
<td>在内容中可能存在错误</td>
</tr>
</tbody></table>
<h3 id="8-2-请求首部"><a href="#8-2-请求首部" class="headerlink" title="8.2 请求首部"></a>8.2 请求首部</h3><ul>
<li>Accept:浏览器能够处理的内容类型</li>
<li>Accept-Charset:浏览器能够显示的字符集</li>
<li>Accept-Encoding：浏览器能够处理的压缩编码</li>
<li>Accept-Language：浏览器当前设置的语言</li>
<li>Connection：浏览器与服务器之间连接的类型</li>
<li>Cookie：当前页面设置的任何Cookie</li>
<li>Host：发出请求的页面所在的域</li>
<li>Referer：发出请求的页面的URL</li>
<li>User-Agent：浏览器的用户代理字符串<h3 id="8-3-响应首部"><a href="#8-3-响应首部" class="headerlink" title="8.3 响应首部"></a>8.3 响应首部</h3></li>
<li>Date：表示消息发送的时间，时间的描述格式由rfc822定义</li>
<li>server:服务器名称</li>
<li>Connection：浏览器与服务器之间连接的类型</li>
<li>Cache-Control：控制HTTP缓存</li>
<li>content-type:表示后面的文档属于什么MIME类型<br>常见的 Content-Type 属性值有以下四种：<br>（1）application&#x2F;x-www-form-urlencoded：浏览器的原生 form 表单，如果不设置 enctype 属性，那么最终就会以 application&#x2F;x-www-form-urlencoded 方式提交数据。该种方式提交的数据放在 body 里面，数据按照 key1&#x3D;val1&amp;key2&#x3D;val2 的方式进行编码，key 和 val 都进行了 URL转码。<br>（2）multipart&#x2F;form-data：该种方式也是一个常见的 POST 提交方式，通常表单上传文件时使用该种方式。<br>（3）application&#x2F;json：服务器消息主体是序列化后的 JSON 字符串。<br>（4）text&#x2F;xml：该种方式主要用来提交 XML 格式的数据。<h3 id="8-4-实体首部"><a href="#8-4-实体首部" class="headerlink" title="8.4 实体首部"></a>8.4 实体首部</h3><table>
<thead>
<tr>
<th>实体首部</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>Allow</td>
<td>资源的正确请求方式</td>
</tr>
<tr>
<td>Content-Encoding</td>
<td>内容的编码格式。  这个实体报头用来压缩媒体类型。Content-Encoding 指示对实体应用了何种编码。  常见的内容编码有这几种： gzip、compress、deflate、identity ，这个属性可以应用在请求报文和响应报文中</td>
</tr>
<tr>
<td>Content-Language</td>
<td>内容使用的语言</td>
</tr>
<tr>
<td>Content-Length</td>
<td>request body 长度</td>
</tr>
<tr>
<td>Content-Location</td>
<td>返回数据的备用地址</td>
</tr>
<tr>
<td>Content-MD5</td>
<td>Base64加密格式的内容 MD5检验值</td>
</tr>
<tr>
<td>Content-Range</td>
<td>内容的位置范围</td>
</tr>
<tr>
<td>Content-Type</td>
<td>内容的媒体类型</td>
</tr>
<tr>
<td>Expires</td>
<td>内容的过期时间</td>
</tr>
<tr>
<td>Last_modified</td>
<td>内容的最后修改时间</td>
</tr>
</tbody></table>
</li>
</ul>
<h2 id="九、HTTP协议的性能"><a href="#九、HTTP协议的性能" class="headerlink" title="九、HTTP协议的性能"></a>九、HTTP协议的性能</h2><p>HTTP基于TCP&#x2F;IP，并且使用了请求-应答的通信模式。</p>
<ul>
<li><strong>持久连接</strong>：HTTP有两种连接模式，持久和非持久连接。非持久连接是指服务器必须为每一个请求的对象建立和维护一个全新的链接。持久连接默认不关闭，可以被多个请求复用。采用持久连接可以避免每次建立TCP三次握手所花费的时间。<br>在HTTP 1.0时采用非持久连接，HTTP 1.1采用持久连接。</li>
<li><strong>管道网络传输</strong>：HTTP 1.1采用了长链接的方式，这使得管道网络传输成为可能。管道（pipeline）网络传输是指：可以在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。但是服务器还是按照顺序回应请求。如果前面的回应特别慢，后面就会有许多请求排队等着。这称为队头堵塞。</li>
<li><strong>队头堵塞</strong>：HTTP 传输的报文必须是一发一收，但是，里面的任务被放在一个任务队列中串行执行，一旦队首的请求处理太慢，就会阻塞后面请求的处理。这就是HTTP队头阻塞问题。<br><strong>队头阻塞的解决方案：</strong> （1）并发连接：对于一个域名允许分配多个长连接，那么相当于增加了任务队列，不至于一个队伍的任务阻塞其它所有任务。 （2）域名分片：将域名分出很多二级域名，它们都指向同样的一台服务器，能够并发的长连接数变多，解决了队头阻塞的问题。</li>
</ul>
<h2 id="十、GET请求和POST请求区别"><a href="#十、GET请求和POST请求区别" class="headerlink" title="十、GET请求和POST请求区别"></a>十、GET请求和POST请求区别</h2><ul>
<li><strong>提交</strong>：GET提交请求的数据会放在URL之后，以？分割URL和传输数据，多个参数用&amp;连接，如login.action?name&#x3D;hybdd&amp;password&#x3D;input。如果数据是英文字母&#x2F;数字，原样发送，如果是空格，转换为+，如果是<strong>中文&#x2F;其他字符，则直接把字符串用BASE64加密</strong>，得出如： %E4%BD%A0%E5%A5 %BD ，其中％XX中的XX为该符号以16进制表示的ASCII。<br>POST请求把提交的数据放置在HTTP报文实体部分，GET提交的数据会在地址栏显示出来，POST提交地址栏不会改变。</li>
<li><strong>传输数据大小</strong>：特定浏览器和服务器对URL长度有限制，GET请求发送数据的长度有限制。POST理论上数据长度不受限制。</li>
<li><strong>安全性</strong>：GET请求将请求参数放在url中，且请求的url会保留在历史记录中，不安全。</li>
<li><strong>参数类型</strong>：post 的参数传递支持更多的数据类型。</li>
<li><strong>发送的报文格式：</strong> Get 请求的报文中实体部分为空，Post 请求的报文中实体部分一般为向服务器发送的数据。</li>
<li><strong>应用场景：</strong> GET 请求是一个幂等的请求，一般 Get 请求用于对服务器资源不会产生影响的场景，比如说请求一个网页的资源。而 Post 不是一个幂等的请求，一般用于对服务器资源会产生影响的情景，比如注册用户这一类的操作。</li>
<li><strong>是否缓存：</strong> 因为两者应用场景不同，浏览器一般会对 Get 请求缓存，但很少对 Post 请求缓存。</li>
</ul>
<h2 id="十一、无状态协议HTTP"><a href="#十一、无状态协议HTTP" class="headerlink" title="十一、无状态协议HTTP"></a>十一、无状态协议HTTP</h2><p>无状态协议就是指浏览器对于事务的处理没有记忆能力。比如客户请求获得网页之后关闭浏览器，然后再次启动浏览器，登录该网站，但是服务器并不知道客户关闭了一次浏览器。<br><strong>HTTP 就是一种无状态的协议</strong>，他对用户的操作没有记忆能力。每次输入用户名和密码登陆一个网站后，下次登陆就不再重新输入用户名和密码了。这其实是一个叫做 小甜饼(Cookie) 的机制。它能够让浏览器具有记忆能力。<br>当向服务端发送请求时，服务端会给你发送一个认证信息，服务器第一次接收到请求时，开辟了一块 Session 空间（创建了Session对象），同时生成一个 sessionId ，并通过响应头的 <strong>Set-Cookie：JSESSIONID&#x3D;XXXXXXX</strong>命令，向客户端发送要求设置 Cookie 的响应； 客户端收到响应后，在本机客户端设置了一个 <strong>JSESSIONID&#x3D;XXXXXXX</strong>的 Cookie 信息，该 Cookie 的过期时间为浏览器会话结束；接下来客户端每次向同一个网站发送请求时，请求头都会带上该 Cookie信息（包含 sessionId ）， 然后，服务器通过读取请求头中的 Cookie 信息，获取名称为 JSESSIONID 的值，得到此次请求的 sessionId。这样，你的浏览器才具有了记忆能力。<br>还有一种方式是使用 JWT 机制，它也是能够让你的浏览器具有记忆能力的一种机制。与 Cookie 不同，JWT 是保存在客户端的信息，它广泛的应用于单点登录的情况。JWT 具有两个特点：<br>JWT 的 Cookie 信息存储在客户端，而不是服务端内存中。也就是说，JWT 直接本地进行验证就可以，验证完毕后，这个 Token 就会在 Session 中随请求一起发送到服务器，通过这种方式，可以节省服务器资源，并且 token 可以进行多次验证。<br>JWT 支持跨域认证，Cookies 只能用在单个节点的域或者它的子域中有效。如果它们尝试通过第三个节点访问，就会被禁止。使用 JWT 可以解决这个问题，使用 JWT 能够通过多个节点进行用户认证，也就是我们常说的跨域认证。</p>
<h2 id="十二、URL组成部分"><a href="#十二、URL组成部分" class="headerlink" title="十二、URL组成部分"></a>十二、URL组成部分</h2><p>如：<a target="_blank" rel="noopener" href="http://www.aspxfans.com:8080/news/index.asp?boardID=5">http://www.aspxfans.com:8080/news/index.asp?boardID=5</a></p>
<ul>
<li><strong>协议部分</strong>：该URL的协议部分为“http：”，这代表网页使用的是HTTP协议。在Internet中可以使用多种协议，如HTTP，FTP等等本例中使用的是HTTP协议。在”HTTP”后面的“&#x2F;&#x2F;”为分隔符；</li>
<li><strong>域名部分</strong>：该URL的域名部分为“<a target="_blank" rel="noopener" href="http://www.aspxfans.com”.一个url中,也可以使用ip地址作为域名使用./">www.aspxfans.com”。一个URL中，也可以使用IP地址作为域名使用。</a></li>
<li><strong>端口部分</strong>：跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口（HTTP协议默认端口是80，HTTPS协议默认端口是443）；</li>
<li><strong>虚拟目录部分</strong>：从域名后的第一个“&#x2F;”开始到最后一个“&#x2F;”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“&#x2F;news&#x2F;”；</li>
<li><strong>文件名部分</strong>：从域名后的最后一个“&#x2F;”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“&#x2F;”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“&#x2F;”开始到结束，都是文件名部分。本例中的文件名是“index.asp”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名；</li>
<li><strong>锚部分</strong>：从“#”开始到最后，都是锚部分。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分；</li>
<li><strong>参数部分</strong>：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。本例中的参数部分为“boardID&#x3D;5&amp;ID&#x3D;24618&amp;page&#x3D;1”。参数可以允许有多个参数，参数与参数之间用“&amp;”作为分隔符。</li>
</ul>
<h2 id="★十三、输入URL发生什么"><a href="#★十三、输入URL发生什么" class="headerlink" title="★十三、输入URL发生什么"></a>★十三、输入URL发生什么</h2><ol>
<li><strong>解析URL</strong>：首先对URL进行解析，分析所需要使用的传输协议和请求资源的路径。如果输入的URL协议或主机名不合法，将会把地址栏中输入的内容传递给搜索引擎。如果没有问题，浏览器会检查URL中是否出现非法字符，若存在则对非法字符进行转义。</li>
<li><strong>缓存判断</strong>：浏览器判断所请求的资源是否在缓存里，如果在缓存里且没有失效就会直接使用，否则向服务器发起新的请求。</li>
<li><strong>DNS解析</strong>：首先判断本地是否有该域名的IP地址的缓存，如果有则使用，没有就向本地DNS服务器发起请求。本地DNS服务器先检查是否存在缓存，如果没有先向根域名服务器发起请求，获得负责的顶级域名服务器的地址后，再向顶级域名服务器请求，然后获得负责权威域名服务器的地址后，再向权威域名服务器发起请求，最终获得域名的IP地址后，本地DNS服务器再将这个IP地址返回给请求的用户。用户向本地 DNS 服务器发起请求属于递归请求，本地 DNS 服务器向各级域名服务器发起请求属于迭代请求。</li>
<li><strong>获取MAC地址</strong>：当浏览器得到 IP 地址后，数据传输还需要知道目的主机 MAC 地址，因为应用层下发数据给传输层，TCP 协议会指定源端口号和目的端口号，然后下发给网络层。网络层会将本机地址作为源地址，获取的 IP 地址作为目的地址。然后将下发给数据链路层，数据链路层的发送需要加入通信双方的 MAC 地址，本机的 MAC 地址作为源 MAC 地址，目的 MAC 地址需要分情况处理。</li>
<li><strong>TCP三次握手</strong>：客户端发送SYN包（SYN &#x3D; 1, seq &#x3D; x）至服务端，并处于SYN_SENT状态，等待服务器确认。服务端解析SYN，并发送SYN + ACK（SYN &#x3D; 1, ACK &#x3D; x + 1, seq &#x3D; y） 包至客户端，并处于SYN_RECV状态，允许建立链接）。客户端获取SYN + ACK 并发送ACK（ACK &#x3D; y + 1， seq &#x3D; z）包至服务端，链接建立成功。</li>
<li><strong>HTTPS握手</strong>：如果使用的是 HTTPS 协议，在通信前还存在 TLS 的一个四次握手的过程。首先由客户端向服务器端发送使用的协议的版本号、一个随机数和可以使用的加密方法。服务器端收到后，确认加密的方法，也向客户端发送一个随机数和自己的数字证书。客户端收到后，首先检查数字证书是否有效，如果有效，则再生成一个随机数，并使用证书中的公钥对随机数加密，然后发送给服务器端，并且还会提供一个前面所有内容的 hash 值供服务器端检验。服务器端接收后，使用自己的私钥对数据解密，同时向客户端发送一个前面所有内容的 hash 值供客户端检验。这个时候双方都有了三个随机数，按照之前所约定的加密方法，使用这三个随机数生成一把秘钥，以后双方通信前，就使用这个秘钥对数据进行加密后再传输。</li>
<li><strong>返回数据</strong>：页面请求发送到服务器端后，服务器端会返回一个html文件作为响应，浏览器接收到响应后，开始对html文件进行解析，开始页面的渲染过程。</li>
<li><strong>页面渲染</strong>：浏览器首先解析HTML，构建DOM树（深度优先），根据解析的CSS文件生成CSS规则树，如果遇到script标签，判断是否有defer或async属性，否则暂停执行。合并DOM树和CSS规则，生成render渲染树。渲染树构建好后，会根据渲染树进行布局，包括回流、重排，负责各元素尺寸、位置计算。布局完成后，绘制渲染树，绘制页面像素信息，最后显示到屏幕上。</li>
<li><strong>TCP四次挥手</strong>：若客户端认为数据发送完成，则需要向服务端发送连接释放请求。经过四次挥手过程，连接断开。</li>
</ol>
<h2 id="十四、页面有多张图片，HTTP怎样加载"><a href="#十四、页面有多张图片，HTTP怎样加载" class="headerlink" title="十四、页面有多张图片，HTTP怎样加载"></a>十四、页面有多张图片，HTTP怎样加载</h2><ul>
<li>在HTTP 1中，浏览器对一个域名下最大TCP连接数为6，会请求多次，可以用多域名部署解决，这样可以提高同时请求的数目，加快页面的获取速度。</li>
<li>在HTTP 2中，可以一瞬间加载很多资源，因为HTTP 2支持多路复用，可以在一个TCP连接中发送多个HTTP请求。<h2 id="十五、keep-alive"><a href="#十五、keep-alive" class="headerlink" title="十五、keep-alive"></a>十五、keep-alive</h2>短连接：每次请求&#x2F;应答时客户端和服务端都要新建一个连接，完成后立即断开。<br>长连接：客户端与服务端的连接持久有效，当出现对服务器的后继请求时，keep-alive功能避免了建立或重新建立连接。</li>
<li>HTTP1.0版本是默认没有Keep-alive的（也就是默认会发送keep-alive），所以要想连接得到保持，必须手动配置发送<code>Connection: keep-alive</code>字段。若想断开keep-alive连接，需发送<code>Connection:close</code>字段；</li>
<li>HTTP1.1规定了默认保持长连接，数据传输完成了保持TCP连接不断开，等待在同域名下继续用这个通道传输数据。如果需要关闭，需要客户端发送<code>Connection：close</code>首部字段。<br><strong>keep-alive的建立过程</strong>：</li>
<li>客户端向服务器在发送请求报文同时在首部添加发送Connection字段</li>
<li>服务器收到请求并处理 Connection字段</li>
<li>服务器回送Connection:Keep-Alive字段给客户端</li>
<li>客户端接收到Connection字段</li>
<li>Keep-Alive连接建立成功<br><strong>服务器自动断开过程（没有keep-alive）</strong>：</li>
<li>客户端向服务器只是发送内容报文（不包含Connection字段）</li>
<li>服务器收到请求并处理</li>
<li>服务器返回客户端请求的资源并关闭连接</li>
<li>客户端接收资源，发现没有Connection字段，断开连接<br><strong>客户端请求断开连接过程</strong>：</li>
<li>客户端向服务器发送Connection:close字段</li>
<li>服务器收到请求并处理connection字段</li>
<li>服务器回送响应资源并断开连接</li>
<li>客户端接收资源并断开连接<br><strong>优点</strong>：</li>
<li>较少的CPU和内存的使⽤（由于同时打开的连接的减少了）；</li>
<li>允许请求和应答的HTTP管线化；</li>
<li>降低拥塞控制 （TCP连接减少了）；</li>
<li>减少了后续请求的延迟（⽆需再进⾏握⼿）；</li>
<li>报告错误⽆需关闭TCP连；<br><strong>缺点</strong>：长时间的TCP连接容易导致系统资源无效占用，浪费系统资源。</li>
</ul>
<h2 id="十六、SSL-TLS"><a href="#十六、SSL-TLS" class="headerlink" title="十六、SSL+TLS"></a>十六、SSL+TLS</h2><p><strong>TLS&#x2F;SSL</strong>全称安全传输层协议，是介于TCP和HTTP之间的一层安全协议，不影响原有的TCP协议和HTTP协议。<br>SSL即安全套接字层，它在OSI七层网络模型中处于第五层，TLS是SSL的后续版本。<br>TLS&#x2F;SSL的功能实现主要依赖三类基本算法：散列函数hash、对称加密、非对称加密，作用是：</p>
<ul>
<li>基于散列函数验证信息的完整性</li>
<li>对称加密算法采用协商的秘钥对数据加密</li>
<li>非对称加密实现身份认证和秘钥协商<h3 id="16-1-散列函数hash"><a href="#16-1-散列函数hash" class="headerlink" title="16.1 散列函数hash"></a>16.1 散列函数hash</h3>常见的散列函数有MD5、SHA1、SHA256。该函数的特点是单向不可逆，对输入数据非常敏感，输出的长度固定，任何数据的修改都会改变散列函数的结果，可以用于防止信息篡改并验证数据的完整性。<br><strong>特点：</strong> 在信息传输过程中，散列函数不能三都实现信息防篡改，由于传输是明文传输，中间人可以修改信息后重新计算信息的摘要，所以需要对传输的信息和信息摘要进行加密。<h3 id="16-2-对称加密"><a href="#16-2-对称加密" class="headerlink" title="16.2 对称加密"></a>16.2 对称加密</h3>双方使用同一个密钥对数据进行加密和解密，常见的对称加密算法有AES-CBC、DES、3DES、AES-GCM等。相同的秘钥可以用于信息的加密和解密。掌握秘钥才能获取信息，防止信息窃听，其通讯方式是一对一。<br>加密方必须对原始数据进行加密，然后再把密钥交给解密方解密，然后才能解密数据，但是密钥传送过程可能被暴露，存在风险。<h3 id="16-3-非对称加密"><a href="#16-3-非对称加密" class="headerlink" title="16.3 非对称加密"></a>16.3 非对称加密</h3>有两个密钥，一个是公钥，一个是私钥。公钥是公开的，私钥是保密的。用私钥加密的数据只有用对应的公钥才能解开。公钥可以公布，使用公钥加密的文本只能使用私钥解密，同时，使用私钥加密的文本也可以使用公钥解密。因此掌握公钥的不同客户端之间不能相互解密信息，只能和服务器进行加密通信，服务器可以实现一对多的的通信，客户端也可以用来验证掌握私钥的服务器的身份。<br><strong>特点：</strong> 非对称加密的特点就是信息一对多，服务器只需要维持一个私钥就可以和多个客户端进行通信，但服务器发出的信息能够被所有的客户端解密，且该算法的计算复杂，加密的速度慢。<h3 id="16-4-混合加密"><a href="#16-4-混合加密" class="headerlink" title="16.4 混合加密"></a>16.4 混合加密</h3>RSA 的运算速度非常慢，而 AES 的加密速度比较快，而 TLS 正是使用了这种混合加密方式。在通信刚开始的时候使用非对称算法，比如 RSA、ECDHE ，首先解决密钥交换的问题。然后用随机数产生对称算法使用的会话密钥（session key），再用公钥加密。对方拿到密文后用私钥解密，取出会话密钥。这样，双方就实现了对称密钥的安全交换。<br>在机密性的基础上还要加上完整性、身份认证的特性，才能实现真正的安全。而实现完整性的主要手段是摘要算法。</li>
</ul>
<h2 id="十七、HTTPS做了什么"><a href="#十七、HTTPS做了什么" class="headerlink" title="十七、HTTPS做了什么"></a>十七、HTTPS做了什么</h2><p>HTTPS协议提供了三个关键指标：</p>
<p><strong>加密</strong>：HTTPS通过对数据进行加密来使其免受窃听者对数据的监听，意味着当用户浏览网站时，没有人能够监听他和网站之间的信息交换，或者跟踪用户的活动、访问记录等，从而窃取用户信息。</p>
<p><strong>数据一致性</strong>：数据在传输的过程中不会被窃听者所修改，用户方发送的数据会完整的传输到服务端，保证服务器接收的和用户发送的一致。</p>
<p><strong>身份认证</strong>：确认对方真实身份，防止中间人攻击并建立用户信任。<br>HTTPS在协议名称、默认端口号、语法和语义上与HTTP一样，关键是通过SSL&#x2F;TLS来保证安全性。</p>
<p><strong>过程</strong>：</p>
<ol>
<li><p>客户端向服务区发起请求，请求中包含使用的协议版本号、生成的一个随机数、以及客户端支持的加密算法。</p>
</li>
<li><p>服务器接收到请求后，确认双方使用的加密方法、给出服务器的证书、服务器生成的随机数。</p>
</li>
<li><p>客户端确认服务器证书有效后，生成一个新的随机数，并使用数字证书中的公钥，加密这个随机数，然后发给服务器，并且会提供一个前面所有内容的hash值，来供服务器检验。</p>
</li>
<li><p>服务器使用自己的私钥，来解密客户端发来的随机数，并提供前面所有内容的hash值来供客户端检验。</p>
</li>
<li><p>客户端和服务器根据约定的加密方法使用前面的三个随机数，生成对话秘钥，以后对话过程都使用这个秘钥来加密信息。<br>为防止中间人攻击，HTTPS使用认证的方式，证明身份，防止被中间人攻击。</p>
</li>
</ol>
<h2 id="十八、HTTPS的优缺点"><a href="#十八、HTTPS的优缺点" class="headerlink" title="十八、HTTPS的优缺点"></a>十八、HTTPS的优缺点</h2><h5 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h5><ul>
<li>使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器。</li>
<li>HTTPS协议是由SSL+HTTP协议构成的可进行加密传输、身份认证的网络协议，比HTTP协议更安全，可防止数据在传输过程中不被窃取、修改，确保数据的完整性。</li>
<li>HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但大幅增加了中间人的攻击成本。</li>
</ul>
<h5 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h5><ul>
<li>HTTPS协议握手阶段比较费事，会使页面加载时间延长。</li>
<li>HTTPS连接缓存不如HTTP高效，会增加数据开销，甚至已有的安全措施也会因此而受到影响。</li>
<li>HTTPS协议的安全是有范围的，在黑客攻击、拒绝服务攻击和服务器劫持等方面几乎起不到什么作用。</li>
<li>SSL证书通常需要绑定IP，不能在同一个IP上绑定多个域名，IPv4资源不可能支撑这个消耗。</li>
<li>成本增加。部署HTTPS后，因为HTTPS协议的工作要增加额外的计算资源消耗。例如SSL协议加密算法和SSL交互次数将占用一定的计算资源和服务器成本。</li>
<li>HTTPS协议的加密范围也比较有限。SSL正式的信用链体系并不安全，中间人攻击一样可行。</li>
</ul>
<h2 id="十九、DHCP（动态主机配置协议）"><a href="#十九、DHCP（动态主机配置协议）" class="headerlink" title="十九、DHCP（动态主机配置协议）"></a>十九、DHCP（动态主机配置协议）</h2><img src="/2022/07/06/%E5%BA%94%E7%94%A8%E5%B1%82-HTTP/DHCP.png" srcset="/img/loading.gif" lazyload class="" title="DHCP"> 

<ul>
<li>作用：为网络内的主机提供动态ip地址分配服务，客户登陆服务器时就可以自动获得服务器分配的IP地址和子网掩码。</li>
<li>先告诉服务器可以分配的ip地址范围 ，  DHCP客户先广播一个请求，发现DHCP服务器。DHCP服务器表示可以提供，客户发送请求表示将其选择，服务器确认并分配地址。</li>
</ul>
<h2 id="二十、HTTPS通信过程"><a href="#二十、HTTPS通信过程" class="headerlink" title="二十、HTTPS通信过程"></a>二十、HTTPS通信过程</h2><ol>
<li>客户端向服务器发起请求，请求中包含使用的协议版本号、生成的一个随机数、以及客户端支持的加密方法。</li>
<li>服务器端接收到请求后，确认双方使用的加密方法、并给出服务器的证书、以及一个服务器生成的随机数。</li>
<li>客户端确认服务器证书有效后，生成一个新的随机数，并使用数字证书中的公钥，加密这个随机数，然后发给服务器。并且还会提供一个前面所有内容的 hash 的值，用来供服务器检验。</li>
<li>服务器使用自己的私钥，来解密客户端发送过来的随机数。并提供前面所有内容的 hash 值来供客户端检验。</li>
<li>客户端和服务器端根据约定的加密方法使用前面的三个随机数，生成对话秘钥，以后的对话过程都使用这个秘钥来加密信息。<h2 id="二十一、什么是DNS协议"><a href="#二十一、什么是DNS协议" class="headerlink" title="二十一、什么是DNS协议"></a>二十一、什么是DNS协议</h2><strong>概念</strong>： DNS 是域名系统 (Domain Name System) 的缩写，提供的是一种主机名到 IP 地址的转换服务，就是我们常说的域名系统。它是一个由分层的 DNS 服务器组成的分布式数据库，是定义了主机如何查询这个分布式数据库的方式的应用层协议。能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。<br><strong>作用</strong>： 将域名解析为IP地址，客户端向DNS服务器（DNS服务器有自己的IP地址）发送域名查询请求，DNS服务器告知客户机Web服务器的 IP 地址。<h2 id="二十二、DNS同时使用TCP和UDP协议？"><a href="#二十二、DNS同时使用TCP和UDP协议？" class="headerlink" title="二十二、DNS同时使用TCP和UDP协议？"></a>二十二、DNS同时使用TCP和UDP协议？</h2><strong>DNS占用53号端口，同时使用TCP和UDP协议。</strong><br>（1）在区域传输的时候使用TCP协议</li>
</ol>
<ul>
<li>辅域名服务器会定时（一般3小时）向主域名服务器进行查询以便了解数据是否有变动。如有变动，会执行一次区域传送，进行数据同步。区域传送使用TCP而不是UDP，因为数据同步传送的数据量比一个请求应答的数据量要多得多。</li>
<li>TCP是一种可靠连接，保证了数据的准确性。<br>（2）在域名解析的时候使用UDP协议</li>
<li>客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。不用经过三次握手，这样DNS服务器负载更低，响应更快。理论上说，客户端也可以指定向DNS服务器查询时用TCP，但事实上，很多DNS服务器进行配置的时候，仅支持UDP查询包。<h2 id="二十三、DNS完整的查询过程"><a href="#二十三、DNS完整的查询过程" class="headerlink" title="二十三、DNS完整的查询过程"></a>二十三、DNS完整的查询过程</h2>DNS服务器解析域名的过程：</li>
<li>首先会在<strong>浏览器的缓存</strong>中查找对应的IP地址，如果查找到直接返回，若找不到继续下一步</li>
<li>将请求发送给<strong>本地DNS服务器</strong>，在本地域名服务器缓存中查询，如果查找到，就直接将查找结果返回，若找不到继续下一步</li>
<li>本地DNS服务器向<strong>根域名服务器</strong>发送请求，根域名服务器会返回一个所查询域的顶级域名服务器地址</li>
<li>本地DNS服务器向<strong>顶级域名服务器</strong>发送请求，接受请求的服务器查询自己的缓存，如果有记录，就返回查询结果，如果没有就返回相关的下一级的权威域名服务器的地址</li>
<li>本地DNS服务器向<strong>权威域名服务器</strong>发送请求，域名服务器返回对应的结果</li>
<li>本地DNS服务器将返回结果保存在缓存中，便于下次使用</li>
<li>本地DNS服务器将返回结果返回给浏览器<h2 id="二十四、迭代查询和递归查询"><a href="#二十四、迭代查询和递归查询" class="headerlink" title="二十四、迭代查询和递归查询"></a>二十四、迭代查询和递归查询</h2>实际上，DNS解析是一个包含迭代查询和递归查询的过程。</li>
<li><strong>递归查询</strong>指的是查询请求发出后，域名服务器代为向下一级域名服务器发出请求，最后向用户返回查询的最终结果。使用递归查询，用户只需要发出一次查询请求。</li>
<li><strong>迭代查询</strong>指的是查询请求后，域名服务器返回单次查询的结果。下一级的查询由用户自己请求。使用迭代查询，用户需要发出 多次的查询请求。<br>一般我们向本地 DNS 服务器发送请求的方式就是递归查询，因为我们只需要发出一次请求，然后本地 DNS 服务器返回给我 们最终的请求结果。而本地 DNS 服务器向其他域名服务器请求的过程是迭代查询的过程，因为每一次域名服务器只返回单次 查询的结果，下一级的查询由本地 DNS 服务器自己进行。<h2 id="二十五、DNS记录和报文"><a href="#二十五、DNS记录和报文" class="headerlink" title="二十五、DNS记录和报文"></a>二十五、DNS记录和报文</h2>DNS 服务器中以资源记录的形式存储信息，每一个 DNS 响应报文一般包含多条资源记录。一条资源记录的具体的格式为<figure class="highlight delphi"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs delphi">（<span class="hljs-keyword">Name</span>，Value，<span class="hljs-keyword">Type</span>，TTL）<br>复制代码<br></code></pre></td></tr></table></figure>
其中 TTL 是资源记录的生存时间，它定义了资源记录能够被其他的 DNS 服务器缓存多长时间。<br>常用的一共有四种 Type 的值，分别是 A、NS、CNAME 和 MX ，不同 Type 的值，对应资源记录代表的意义不同：</li>
<li>如果 Type &#x3D; A，则 Name 是主机名，Value 是主机名对应的 IP 地址。因此一条记录为 A 的资源记录，提供了标 准的主机名到 IP 地址的映射。</li>
<li>如果 Type &#x3D; NS，则 Name 是个域名，Value 是负责该域名的 DNS 服务器的主机名。这个记录主要用于 DNS 链式 查询时，返回下一级需要查询的 DNS 服务器的信息。</li>
<li>如果 Type &#x3D; CNAME，则 Name 为别名，Value 为该主机的规范主机名。该条记录用于向查询的主机返回一个主机名 对应的规范主机名，从而告诉查询主机去查询这个主机名的 IP 地址。主机别名主要是为了通过给一些复杂的主机名提供 一个便于记忆的简单的别名。</li>
<li>如果 Type &#x3D; MX，则 Name 为一个邮件服务器的别名，Value 为邮件服务器的规范主机名。它的作用和 CNAME 是一 样的，都是为了解决规范主机名不利于记忆的缺点。</li>
</ul>
<h2 id="二十六、Websocket"><a href="#二十六、Websocket" class="headerlink" title="二十六、Websocket"></a>二十六、Websocket</h2><h3 id="26-1-什么是websocket"><a href="#26-1-什么是websocket" class="headerlink" title="26.1 什么是websocket"></a>26.1 什么是websocket</h3><p>是HTML5提供的一种浏览器与服务器进行全双工通讯的协议。它基于TCP协议，并复用HTTP的握手通道。浏览器和服务器只需要进行一次握手就可以创建持久性的链接，并进行双向数据传输。<br><strong>特点</strong>：</p>
<ul>
<li>支持双向通信，实时性更强</li>
<li>可以发送文本，也可以发送二进制数据</li>
<li>建立在TCP协议之上，服务端的实现比较容易</li>
<li>数据格式比较轻量，性能开销小，通信高效</li>
<li>没有同源限制，客户端可以与任意服务器通信</li>
<li>协议标识符是ws（如果加密，则为wss），服务器网址就是 URL</li>
<li>与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。</li>
</ul>
<h3 id="26-2-websocket优点"><a href="#26-2-websocket优点" class="headerlink" title="26.2 websocket优点"></a>26.2 websocket优点</h3><ul>
<li>通过第一次HTTP Request建立了连接之后，后续的数据交换都不用再重新发送HTTP Request，节省了带宽资源；</li>
<li>WebSocket的连接是双向通信的连接，在同一个TCP连接上，既可以发送，也可以接收;</li>
<li>具有多路复用的功能，几个不同的URI可以复用同一个WebSocket连接。</li>
</ul>
<h3 id="26-3-心跳机制"><a href="#26-3-心跳机制" class="headerlink" title="26.3 心跳机制"></a>26.3 心跳机制</h3><p>心跳机制是每隔一段时间会向服务器发送一个数据包： 告诉服务器（后台）自己还活着，同时客户端（浏览器）会确认服务器端是否还活着。如果还活着的话，就会回传一个数据包给客户端。服务端断开连接了。客户端需要重连。<strong>默认超时时间1分钟</strong></p>
<h2 id="二十七、即时通讯中短轮询、长轮询、SSE和websocket的区别"><a href="#二十七、即时通讯中短轮询、长轮询、SSE和websocket的区别" class="headerlink" title="二十七、即时通讯中短轮询、长轮询、SSE和websocket的区别"></a>二十七、即时通讯中短轮询、长轮询、SSE和websocket的区别</h2><ul>
<li><strong>短轮询</strong>：浏览器每隔一段时间向服务器发送http请求，服务器收到请求后，不论是否有数据更新，都直接进行响应。这种方式实现的即时通信，本质上还是浏览器发送请求，服务器接受请求的一个过程，通过让客户端不断的进行请求，使得客户端能够模拟实时地收到服务器端的数据的变化。这种方式的优点是比较简单，易于理解。缺点是这种方式由于需要不断的建立 http 连接，严重浪费了服务器端和客户端的资源。当用户增加时，服务器端的压力就会变大。</li>
<li><strong>长轮询</strong>：首先由客户端向服务器发起请求，当服务器收到客户端发来的请求后，服务器端不会直接进行响应，而是先将这个请求挂起，然后判断服务器端数据是否有更新。如果有更新，则进行响应，如果一直没有数据，则到达一定的时间限制才返回。客户端 JavaScript 响应处理函数会在处理完服务器返回的信息后，再次发出请求，重新建立连接。长轮询和短轮询比起来，它的优点是明显减少了很多不必要的 http 请求次数，相比之下节约了资源。长轮询的缺点在于，连接挂起也会导致资源的浪费。</li>
<li><strong>SSE</strong>：服务器使用流信息向服务器推送信息。严格地说，http 协议无法做到服务器主动推送信息。办法是服务器向客户端声明，接下来要发送的是流信息。发送的不是一次性的数据包，而是一个数据流，会连续不断地发送过来。这时，客户端不会关闭连接，会一直等着服务器发过来的新的数据流，视频播放就是这样的例子。SSE 就是利用这种机制，使用流信息向浏览器推送信息。它基于 http 协议，目前除了 IE&#x2F;Edge，其他浏览器都支持。它相对于前面两种方式来说，不需要建立过多的 http 请求，相比之下节约了资源。</li>
<li><strong>websocket</strong>：HTTP5新定义的协议，允许服务器主动向客户端推送信息，缺点是服务器端的配置比较复杂。websocket是一个全双工的协议，通信双方是平等的，可以互相发送消息，SSE是单向的，只能从服务器向客户端推送信息，客户端需要发送信息就属于下一个HTTP请求了。</li>
<li>短轮询、长轮询、SSE是基于HTTP协议，性能上来看后比前好，兼容性前比后好。</li>
</ul>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E5%8E%9F%E5%88%9B/">原创</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/07/11/1109-%E8%88%AA%E7%8F%AD%E9%A2%84%E8%AE%A2%E7%BB%9F%E8%AE%A1/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">1109.航班预订统计</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/06/26/webpack/">
                        <span class="hidden-mobile">webpack</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/valine@1/dist/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"sOHs1UX9yhu45mOPqVuIjOkh-gzGzoHsz","appKey":"JlU9ppAdc6X2IEPeXLgdlFGc","path":"window.location.pathname","placeholder":null,"avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          Fluid.plugins.initFancyBox('#valine .vcontent img:not(.vemoji)');
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- LeanCloud 统计PV -->
        <span id="leancloud-site-pv-container" style="display: none">
            总访问量 
            <span id="leancloud-site-pv"></span>
             次
          </span>
      
      
        <!-- LeanCloud 统计UV -->
        <span id="leancloud-site-uv-container" style="display: none">
            总访客数 
            <span id="leancloud-site-uv"></span>
             人
          </span>
      

    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  




  <script defer src="/js/leancloud.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>












  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
