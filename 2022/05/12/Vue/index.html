

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="WBY">
  <meta name="keywords" content="">
  
    <meta name="description" content="一、为什么要使用Vue 体积小，轻量级框架，只关注视图层，是一个构建数据的视图集合。 双向数据绑定：让开发者不用再去操作DOM对象。 易用：容易上手，学习成本低。 可以直接直接将vue作为现成的服务端应用嵌入。实现组件化，将网页分割成可复用的组件，每个组件用来渲染网页中相应的地方。 高效：基于虚拟DOM，可以预先通过JavaScript进行各种计算，把最终的DMO操作计算出来并优化的技术。由于这种">
<meta property="og:type" content="article">
<meta property="og:title" content="Vue上">
<meta property="og:url" content="http://example.com/2022/05/12/Vue/index.html">
<meta property="og:site_name" content="前端面试总结">
<meta property="og:description" content="一、为什么要使用Vue 体积小，轻量级框架，只关注视图层，是一个构建数据的视图集合。 双向数据绑定：让开发者不用再去操作DOM对象。 易用：容易上手，学习成本低。 可以直接直接将vue作为现成的服务端应用嵌入。实现组件化，将网页分割成可复用的组件，每个组件用来渲染网页中相应的地方。 高效：基于虚拟DOM，可以预先通过JavaScript进行各种计算，把最终的DMO操作计算出来并优化的技术。由于这种">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2022/05/12/Vue/%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A8.png">
<meta property="og:image" content="http://example.com/2022/05/12/Vue/%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A.png">
<meta property="og:image" content="http://example.com/2022/05/12/Vue/%E5%8F%98%E5%8C%96%E4%BE%A6%E6%B5%8B.png">
<meta property="og:image" content="http://example.com/2022/05/12/Vue/Watcher.png">
<meta property="og:image" content="http://example.com/2022/05/12/Vue/%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1.png">
<meta property="og:image" content="http://example.com/2022/05/12/Vue/%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6.png">
<meta property="og:image" content="http://example.com/2022/05/12/Vue/%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E4%BF%AE%E9%A5%B0%E7%AC%A6.png">
<meta property="og:image" content="http://example.com/2022/05/12/Vue/keep-alive%E9%A6%96%E6%AC%A1%E6%B8%B2%E6%9F%93.png">
<meta property="og:image" content="http://example.com/2022/05/12/Vue/%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png">
<meta property="og:image" content="https://vue-js.com/learn-vue/assets/img/8.e4c85c40.png">
<meta property="og:image" content="https://vue-js.com/learn-vue/assets/img/11.2ddb5ee5.png">
<meta property="og:image" content="https://vue-js.com/learn-vue/assets/img/12.bace2f7f.png">
<meta property="og:image" content="https://vue-js.com/learn-vue/assets/img/13.98dbc208.png">
<meta property="og:image" content="https://vue-js.com/learn-vue/assets/img/14.18c1c6dd.png">
<meta property="article:published_time" content="2022-05-12T09:12:16.000Z">
<meta property="article:modified_time" content="2022-09-26T18:22:54.227Z">
<meta property="article:author" content="WBY">
<meta property="article:tag" content="原创">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/2022/05/12/Vue/%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A8.png">
  
  
  <title>Vue上 - 前端面试总结</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"sOHs1UX9yhu45mOPqVuIjOkh-gzGzoHsz","app_key":"JlU9ppAdc6X2IEPeXLgdlFGc","server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.1.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>前端面试总结</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Vue上">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-05-12 17:12" pubdate>
        2022年5月12日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      46k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      380 分钟
    </span>
  

  
  
    
      <!-- LeanCloud 统计文章PV -->
      <span id="leancloud-page-views-container" class="post-meta" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="leancloud-page-views"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Vue上</h1>
            
            <div class="markdown-body">
              <h1 id="一、为什么要使用Vue"><a href="#一、为什么要使用Vue" class="headerlink" title="一、为什么要使用Vue"></a>一、为什么要使用Vue</h1><ul>
<li>体积小，轻量级框架，只关注视图层，是一个构建数据的视图集合。</li>
<li>双向数据绑定：让开发者不用再去操作DOM对象。</li>
<li>易用：容易上手，学习成本低。</li>
<li>可以直接直接将vue作为现成的服务端应用嵌入。实现组件化，将网页分割成可复用的组件，每个组件用来渲染网页中相应的地方。</li>
<li>高效：基于虚拟DOM，可以预先通过JavaScript进行各种计算，把最终的DMO操作计算出来并优化的技术。由于这种DOM操作属于预处理操作，并没有真实的操作DOM，没有浏览器渲染所以叫做虚拟DOM。</li>
<li>性能比react更强</li>
<li>社区和第三方组件库丰富。</li>
</ul>
<h1 id="★二、浏览器的虚拟DOM与真实DOM区别"><a href="#★二、浏览器的虚拟DOM与真实DOM区别" class="headerlink" title="★二、浏览器的虚拟DOM与真实DOM区别"></a>★二、浏览器的虚拟DOM与真实DOM区别</h1><ul>
<li><strong>虚拟DOM不会进行排版与重绘操作</strong>：虚拟DOM进行频繁修改，然后一次性比较并修改真实DOM中需要修改的部分，最后在真实DOM中进行排版与重绘，减少过多DOM节点排版与重绘的损耗。</li>
<li><strong>真实DOM频繁排版重绘的效率相当低</strong>：虚拟DOM有效降低大面积真实dom节点的重绘与排版，因为最终与真实DOM比较差异，可以只渲染局部。</li>
<li>虚拟DOM减少了一些情况下对真实DOM的操作，它对比后再选择更新哪些DOM，而不是全部删除再重建。虚拟DOM是内存中维护的DOM树，是在实体DOM上的一层抽象，查询修改操作都是先操作内存中的虚拟DOM。</li>
</ul>
<h2 id="2-1-虚拟-DOM解析过程"><a href="#2-1-虚拟-DOM解析过程" class="headerlink" title="2.1 虚拟 DOM解析过程"></a>2.1 虚拟 DOM解析过程</h2><ul>
<li>首先对将要插入文档中的DOM树结构进行分析，使用js对象将其表示出来，比如一个元素对象包含TagName、props和Children属性，然后将这些对象树保存下来，最后再将DOM片段插入到文档中。</li>
<li>当页面状态发生改变，需要对页面的DOM结构进行调整的时候，首先根据变更的状态，重新构建一颗对象树，然后将这棵新的对象树与旧的对象树进行比较，记录两棵树的差异。新旧虚拟DOM使用diff算法，得到<strong>patch</strong>（需要修改的部分），然后将这个patch打到浏览器DOM上，减少回流和重绘。</li>
<li>最后将记录的有差异的地方应用到真的DOM树中去，就完成了视图更新。</li>
</ul>
<h2 id="2-2-虚拟DOM最大优势"><a href="#2-2-虚拟DOM最大优势" class="headerlink" title="2.2 虚拟DOM最大优势"></a>2.2 虚拟DOM最大优势</h2><ol>
<li>将虚拟DOM作为一个兼容层，可以对接非Web端的系统，实现跨域开发。</li>
<li>虚拟DOM可以渲染到其它平台，比如实现SSR、同构渲染等等。</li>
<li>实现组件的高度抽象化。</li>
</ol>
<h2 id="2-3-虚拟DOM和真实DOM性能对比"><a href="#2-3-虚拟DOM和真实DOM性能对比" class="headerlink" title="2.3 虚拟DOM和真实DOM性能对比"></a>2.3 虚拟DOM和真实DOM性能对比</h2><p>首次渲染大量DOM时，由于多了一层虚拟DOM的计算，会比innerHTML插入慢。在真实DOM操作的时候进行针对性的优化时更快。</p>
<h2 id="2-4-Vue2和Vue3的diff算法区别"><a href="#2-4-Vue2和Vue3的diff算法区别" class="headerlink" title="2.4 Vue2和Vue3的diff算法区别"></a>2.4 Vue2和Vue3的diff算法区别</h2><p><strong>diff算法过程</strong>：</p>
<ol>
<li>首先，对比节点本身，判断是否为同一节点，如果为不相同节点，则删除该节点重新创建节点进行替换。</li>
<li>如果为相同节点，进行patchVnode，判断如何对该节点的子节点进行处理。<strong>同级比较，再比较子节点</strong>：先判断一方有子节点一方没有子节点的情况，如果新的children没有子节点，将旧的子节点移除。如果都有子节点，则进行updateChilren，判断如何对这些新老节点的子节点进行操作（diff核心）。</li>
<li><strong>递归比较子节点</strong>：匹配时，找到相同的子节点，递归比较子节点。在diff中，只对同层的子节点进行比较，放弃跨级的节点比较，使得时间复杂度从O(n3)变为O(n)。<br><strong>VUE2</strong>的核心diff算法采用了双端比较的算法，同时从新旧的children的两端开始进行比较，借助key值找到可复用的节点，再进行相关操作。相比React可以减少移动节点次数，减少不必要的性能损耗。<br><strong>VUE3</strong>：借鉴了ivi算法和inferno算法，在创建vnode时就确定其类型，以及在mount&#x2F;patch的过程中采用位运算来判断一个vnode的类型，在这个基础上再配合核心diff算法，使得性能得到了提升。该算法中还运用了动态规划的思想求解最长递归子序列。</li>
</ol>
<h1 id="三、VUE特性"><a href="#三、VUE特性" class="headerlink" title="三、VUE特性"></a>三、VUE特性</h1><ul>
<li><strong>数据驱动视图</strong>：在使用了vue的界面中，vue会监听数据的变化，从而自动重新渲染页面的结构，当页面数据发生变化时，页面会自动渲染，数据驱动视图是单向的数据绑定，程序员只用维护数据。</li>
</ul>
<img src="/2022/05/12/Vue/%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A8.png" srcset="/img/loading.gif" lazyload class="">

<ul>
<li><strong>双向数据绑定</strong>：在网页中，form表单用来采集数据，ajax用来提交数据。在填写表单时，双向数据绑定可以辅助开发者在不操作DOM的前提下，自动把用户填写的内容同步到数据源中。开发者不需要再手动操作DOM元素，来获取表单元素的最新值。js数据的变化会自动渲染到页面上，页面上采集的表单数据发生变化时，会被vue自动获取填充到js中。</li>
</ul>
 <img src="/2022/05/12/Vue/%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A.png" srcset="/img/loading.gif" lazyload class="">

<h1 id="四、MVC和MVVM模式"><a href="#四、MVC和MVVM模式" class="headerlink" title="四、MVC和MVVM模式"></a>四、MVC和MVVM模式</h1><ul>
<li><strong>MVC</strong>：MVC允许在不改变视图的情况下改变视图对用户输入的响应模式，用户对View的操作交给了Controller处理，在Controller中响应View的事件调用Model的接口对数据进行操作，一旦Model发生变化便通知相关视图进行更新。</li>
<li><strong>MVVM</strong>：指的是Model（当前页面渲染所需要的数据源）、View（当前页面所渲染的DOM结构）、ViewModel（VUE的实例，MVVM的核心，把当前页面的数据源和页面结构连接在一起）。
当数据源发生变化时，会被ViewModel监听到，VM会根据最新的数据源自动更新页面的结构。<br>当表单元素的值发生变化时，也会被VM监听到，VM会把变化过后最新的值自动同步到Model数据源中。<br>MVVM与MVC最大的区别就是：它实现了View和Model的自动同步，也就是当Model的属性改变时，我们不用再自己手动操作DOM元素来改变View的显示，而是改变属性后该属性对应View层显示会自动改变。<br>VUE实例中的data相当于Model层，而ViewModel层的核心是VUE中的双向数据绑定，即Model变化时View可以实时更新，View变化也能让Model发生变化。<br>在MVVM架构中，引入了ViewModel的概念，ViewModel只关心数据和业务的处理，不关系View如何处理数据。在这种情况下，View和Model都可以独立出来，任何一方改变了也不一定需要改变另一方，并且可以把一些可复用的逻辑放在一个ViewModel中，让多个View复用这个ViewModel。<br>以VUE框架来举例，ViewModel就是组件的实例，View就是模板，Model的话在引入Vuex的情况下是完全可以和组件分离的。<br>MVVM还引入了一个隐式的Binder层，实现了View和ViewModel的绑定。这个隐式的Binder层就是VUE通过解析模板中的插值和指令从而实现View与ViewModel的绑定。<br>对于MVVM来说，最重要的并不是通过双向绑定或其他的方式将View与ViewModel绑定起来，而是通过ViewModel将视图中的状态和用户的行为分离出一个抽象。</li>
</ul>
<h1 id="★五、双向数据绑定与变化侦测"><a href="#★五、双向数据绑定与变化侦测" class="headerlink" title="★五、双向数据绑定与变化侦测"></a>★五、双向数据绑定与变化侦测</h1><p>VUE最大特点之一就是<strong>数据驱动视图</strong>，可以把数据理解为状态，而视图就是用户可以直观看到的页面，其原理是采用<strong>数据劫持结合发布者-订阅者</strong>（publisher-subscriber）默认的方式来实现（realize）。<br><strong>变化侦测就是追踪状态，数据一旦发生变化就要去更新视图</strong>。变化侦测在目前前端三大框架中都有涉及，在<strong>Angular</strong>中是通过脏值检测流程来实现变化侦测，在<strong>React</strong>中是通过对比虚拟DOM来实现变化侦测，在VUE中也有自己的一套变化侦测实现机制，当状态变化后，会通知到组件，组件内部再使用虚拟DOM进行对比。<br> <img src="/2022/05/12/Vue/%E5%8F%98%E5%8C%96%E4%BE%A6%E6%B5%8B.png" srcset="/img/loading.gif" lazyload class=""></p>
<p><strong>数据变化更新视图，视图变化更新数据</strong>：输入框内容变化时，Data中数据同步变化，即视图到数据的变化，Data中的数据变化时，文本节点的内容同步变化，即数据到视图的变化。</p>
<h2 id="5-0-实现数据双向绑定步骤"><a href="#5-0-实现数据双向绑定步骤" class="headerlink" title="5.0 实现数据双向绑定步骤"></a>5.0 实现数据双向绑定步骤</h2><ul>
<li>bidirectional data binding</li>
<li><strong>实现监听器Observer</strong>：对数据对象进行遍历（traverse the data object），包括子属性对象的属性，利用Object.defineProperty()对属性（property）加上setter和getter，对这个对象的某个值赋值（ the assignment to this object）就会触发（tigger）setter，就能监听到数据变化。</li>
<li><strong>实现解析器Compile</strong>：解析（analysis）VUE模板（template）指令（instruction），将模板中的变量（variable）都替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点（node）绑定（binding）更新函数，添加监听（monitor）数据的订阅者（subscriber），一旦数据发生变动，收到通知，调用更新函数进行数据更新。</li>
<li><strong>实现订阅者Watcher</strong>：它是Observer和Complie之间通信的桥梁，主要的任务是订阅Observer中的属性值变化的消息，当收到属性值变化的消息时，触发（trigger）解析器Compile中对应的更新函数。</li>
<li><strong>实现一个订阅器Dep</strong>：订阅器采用发布-订阅设计模式，用来收集订阅者Watcher，对监听器Observer和订阅者Watcher进行统一管理。<br><strong>VUE框架是通过遍历数组和递归遍历对象，达到利用defineProperty对对象和数组的监听</strong>。</li>
</ul>
<h2 id="★5-1Observer数据劫持-观察者-Object-defineProperty"><a href="#★5-1Observer数据劫持-观察者-Object-defineProperty" class="headerlink" title="★5.1Observer数据劫持(观察者)+Object.defineProperty"></a>★5.1Observer数据劫持(观察者)+Object.defineProperty</h2><p>数据的观察者，让数据对象的读写操作都处于自己的监管下。</p>
<figure class="highlight js"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> car = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Observer</span>(&#123;<br>    brand<span class="hljs-string">&#x27;:&#x27;</span><span class="hljs-variable constant_">BMW</span><span class="hljs-string">&#x27;,</span><br><span class="hljs-string">    &#x27;</span>price<span class="hljs-string">&#x27;:3000;</span><br><span class="hljs-string">&#125;)</span><br></code></pre></td></tr></table></figure>
<p>Observer类定义在src&#x2F;core&#x2F;observer&#x2F;index.js中。<br>Observer类会通过递归的方式把一个对象的所有属性都转化成可观测对象，下面是Observer的构造函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Observer</span> &#123;<br>  <span class="hljs-title function_">constructor</span> (value) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = value   <span class="hljs-comment">//value是需要被观察的数据对象</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">dep</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dep</span>()<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">vmCount</span> = <span class="hljs-number">0</span><br>    <br>    <span class="hljs-comment">// 给value新增一个__ob__属性，作为数据已经被Observer观察的标志</span><br>    <span class="hljs-comment">// 相当于为value打上标记，表示它已经被转化成响应式了，避免重复操作</span><br>    <span class="hljs-title function_">def</span>(value,<span class="hljs-string">&#x27;__ob__&#x27;</span>,<span class="hljs-variable language_">this</span>)<br>    <br>    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(value)) &#123;<br>        <span class="hljs-keyword">const</span> augment = hasProto ? protoAugment : copyAugment;<br>    <span class="hljs-comment">//如果value是数组，就使用observerArray遍历value，对value中每一个元素调用observe分别进行观察。</span><br>        <span class="hljs-title function_">augment</span>(value, arrayMethods, arrayKeys);<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">observerArray</span>(value);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">walk</span>(value);<br>      <span class="hljs-comment">//如果value是对象，则使用walk遍历value上的每个key，对每个key调用defineReactive来获得该key的set/get控制权。</span><br>    &#125;<br>  &#125;<br>  walk (<span class="hljs-attr">obj</span>: <span class="hljs-title class_">Object</span>) &#123;<span class="hljs-comment">//定义一个walk方法</span><br>    <span class="hljs-keyword">const</span> keys = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(obj)<br>    <span class="hljs-comment">//因为defineproperty只能劫持属性，所以遍历obj中各属性调用劫持函数</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; keys.<span class="hljs-property">length</span>; i++) &#123;<br>      <span class="hljs-title function_">defineReactive</span>(obj, keys[i])<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>defineReactive函数将一个对象转换为可观测的对象。obj为对象，key是对象的key，val是对象某个key的值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">defineReactive</span> (obj,key,val) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span> === <span class="hljs-number">2</span>) &#123;<br>    val = obj[key]<span class="hljs-comment">//如果没有传val的值，val就等于obj[key]</span><br>  &#125;<br>  <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> val === <span class="hljs-string">&#x27;object&#x27;</span>)&#123;<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Observer</span>(val)<span class="hljs-comment">//如果val是对象，就递归劫持对象将其变成可观测的</span><br>  &#125;<br>  <span class="hljs-keyword">const</span> dep = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dep</span>()  <span class="hljs-comment">//实例化一个依赖管理器，生成一个依赖管理数组dep</span><br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(obj, key, &#123; <span class="hljs-comment">//设置对象的key属性，使得能够捕获到该属性值的set/get动作。</span><br>    <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>)&#123;    <span class="hljs-comment">//get操作，将Watcher的实例对象添加到Dep实例的依赖数组中。</span><br>      dep.<span class="hljs-title function_">depend</span>()    <span class="hljs-comment">// 在getter中收集依赖</span><br>      <span class="hljs-keyword">return</span> val;<br>    &#125;,<br>    <span class="hljs-title function_">set</span>(<span class="hljs-params">newVal</span>)&#123;    <span class="hljs-comment">//外部操作触发set时通过Dep实例的notify通知。</span><br>      <span class="hljs-keyword">if</span>(val === newVal)&#123;<br>          <span class="hljs-keyword">return</span>    <span class="hljs-comment">//如果修改值等于原来的值，就直接return</span><br>      &#125;<br>      val = newVal;  <span class="hljs-comment">//否则赋新值</span><br>      dep.<span class="hljs-title function_">notify</span>()   <span class="hljs-comment">// 在setter中通知各依赖的Watcher进行更新</span><br>    &#125;<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>Object.definePropertyd缺陷：<br>①<strong>无法监听数组下标变化和对象新增属性</strong>，通过数组下标添加元素，无法实时响应。<br>②<strong>只能劫持对象的属性</strong>，因此需要对每个对象的每个属性进行遍历，如果属性值也是对象那么需要深度遍历，能劫持一个完整的对象是更好的选择。<br>Object.keys(value).forEach(key&#x3D;&gt;this.convert(key,value[key]));<br><strong>vue能够监听到对象变化的场景</strong>：通过直接赋值的场景，如：<br>watchObj &#x3D; {name:”zyk”}<br><strong>vue无法监听到对象变化的场景</strong>：对象新增和删除属性。<br><strong>vue解决无法监听对象变化的方法</strong>：<br>①使用this.$se(object,key,value)，vue无法监听this.set修改原有属性。<br>②使用Object.assig()直接赋值。<br><strong>VUE监听数组</strong>：(重写了push)判断要监听的数据是否为数组，是数组的情况就将数组模拟成对象，将数组的方法名绑定到新创建的对象中，将对应数值原型的方法赋给自定义的方法。</p>
<p><strong>对比其他双向绑定的实现方法，数据劫持优势</strong>：<br>①<strong>无需显式调用</strong>：例如Vue使用数据劫持+发布订阅，直接可以通知变化并驱动视图，当数据变更后直接触发视图变更，而Angular的脏检测需要显式调用markForCheck，react需要显式调用setState。<br>②<strong>可精确得知变化数据</strong>：我们劫持了属性的setter，当属性值改变，我们可以精确货值变化的内容newVal，因此在这部分不需要额外的diff操作。否则我们只知道数据发生了变化而不知道具体哪些数据变化了，这个时候需要大量使用diff来找出变化值，这是额外性能损耗。</p>
<h2 id="5-2-Dep依赖收集"><a href="#5-2-Dep依赖收集" class="headerlink" title="5.2 Dep依赖收集"></a>5.2 Dep依赖收集</h2><p>它用来收集依赖、删除依赖和向依赖发送消息等。<br>依赖收集过程：谁用到了这个数据称为“谁依赖了这个数据”，给每个数据都建立一个依赖数组（因为一个数据可能被多处使用），谁依赖了这个数据我们就把谁放入到这个依赖数组中，当这个数据发生变化的时候，我们就去它对应的依赖数组中，把每个依赖都通知一遍，告诉他们应该更新了。<br><strong>在getter中收集依赖</strong>为谁用到了这个数据，就代表谁依赖这个数据。<br><strong>在setter中通知依赖更新</strong>。<br>每个数据都有一个依赖管理器Dep类：在src&#x2F;core&#x2F;observer&#x2F;dep.js中</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Watcher</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./Watcher&quot;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dep</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">subs</span> = [] <span class="hljs-comment">//初始化了一个subs数组，用来存放依赖</span><br>    &#125;<br>    <span class="hljs-title function_">addSub</span>(<span class="hljs-params">sub</span>)&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">subs</span>.<span class="hljs-title function_">push</span>(sub) <span class="hljs-comment">//添加操作</span><br>    &#125;  <br>    <span class="hljs-comment">// 删除一个依赖</span><br>    removeSub (sub) &#123;<br>        <span class="hljs-title function_">remove</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">subs</span>, sub)<br>    &#125;        <br>    <span class="hljs-comment">// 添加一个依赖</span><br>    depend () &#123;<span class="hljs-comment">//在Object.defineProperty的get方法中调用</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">window</span>.<span class="hljs-property">target</span>) &#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">addSub</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">target</span>)<br>        &#125;<br>    &#125; <br>    <span class="hljs-comment">// 通知所有依赖更新</span><br>    notify () &#123;   <span class="hljs-comment">//在Object.defineProperty的set方法中调用</span><br>        <span class="hljs-keyword">const</span> subs = <span class="hljs-variable language_">this</span>.<span class="hljs-property">subs</span>.<span class="hljs-title function_">slice</span>()<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, l = subs.<span class="hljs-property">length</span>; i &lt; l; i++) &#123;<br>            subs[i].<span class="hljs-title function_">update</span>()<br>        &#125;<br>    &#125;<br>&#125;<br> <span class="hljs-comment">// 移除</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">remove</span> (arr, item) &#123;<br>  <span class="hljs-keyword">if</span> (arr.<span class="hljs-property">length</span>) &#123;<br>    <span class="hljs-keyword">const</span> index = arr.<span class="hljs-title function_">indexOf</span>(item)<br>    <span class="hljs-keyword">if</span> (index &gt; -<span class="hljs-number">1</span>) &#123;<br>      <span class="hljs-keyword">return</span> arr.<span class="hljs-title function_">splice</span>(index, <span class="hljs-number">1</span>)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="5-3-Watcher订阅者"><a href="#5-3-Watcher订阅者" class="headerlink" title="5.3 Watcher订阅者"></a>5.3 Watcher订阅者</h2><p>谁用到了数据，谁就是依赖，就为谁创建一个Watcher实例，在之后数据发生变化时，我们不去直接通知依赖更新，而是通知依赖对应的Watcher实例，由Watcher实例去通知真正的视图。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Dep</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./Dep&quot;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Watcher</span> &#123;<br>    <span class="hljs-title function_">constructor</span> (vm,expOrFn,cb) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">vm</span> = vm;  <span class="hljs-comment">//vm指当前的Vue实例</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">cb</span> = cb;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">getter</span> = <span class="hljs-title function_">parsePath</span>(expOrFn)<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">get</span>()  <span class="hljs-comment">//读取vm.$data中的值，同时会触发属性上的getter</span><br>    &#125;<br>    get () &#123;<br>        <span class="hljs-comment">// Watcher把自己设置到全局唯一的指定位置，就是window.target</span><br>        <span class="hljs-variable language_">window</span>.<span class="hljs-property">target</span> = <span class="hljs-variable language_">this</span>;<br>        <span class="hljs-keyword">const</span> vm = <span class="hljs-variable language_">this</span>.<span class="hljs-property">vm</span><br>        <span class="hljs-comment">//读取数据，触发这个数据的getter，因此Observer会收集依赖，将这个Watcher收集到Dep</span><br>        <span class="hljs-keyword">let</span> value = <span class="hljs-variable language_">this</span>.<span class="hljs-property">getter</span>.<span class="hljs-title function_">call</span>(vm, vm)<br>        <span class="hljs-comment">// 收集结束，清除Dep.target的内容</span><br>        <span class="hljs-variable language_">window</span>.<span class="hljs-property">target</span> = <span class="hljs-literal">undefined</span>;<br>        <span class="hljs-comment">// 返回读取到的数据值</span><br>        <span class="hljs-keyword">return</span> value<br>    &#125;<br>    update () &#123;<br>    <span class="hljs-comment">// 数据改变后，Dep会依次循环向依赖发通知，接到通知之后先获取它的旧数据</span><br>        <span class="hljs-keyword">const</span> oldValue = <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span><br>        <span class="hljs-comment">// 然后获取最新的值</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">get</span>()<br>        <span class="hljs-comment">// 将新旧值传给回调函数</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">cb</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">vm</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>, oldValue)<br>    &#125;<br>&#125;<br><span class="hljs-keyword">const</span> bailRE = <span class="hljs-regexp">/[^\w.$]/</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">parsePath</span> (path) &#123;<br>  <span class="hljs-keyword">if</span> (bailRE.<span class="hljs-title function_">test</span>(path)) &#123;<br>    <span class="hljs-keyword">return</span><br>  &#125;<br>  <span class="hljs-keyword">const</span> segments = path.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;.&#x27;</span>)<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">obj</span>) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; segments.<span class="hljs-property">length</span>; i++) &#123;<br>      <span class="hljs-keyword">if</span> (!obj) <span class="hljs-keyword">return</span><br>      obj = obj[segments[i]]<br>    &#125;<br>    <span class="hljs-keyword">return</span> obj<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>watcher类代码实现逻辑：</p>
<ol>
<li>当实例化Watcher类时，会先执行其构造函数。</li>
<li>在构造函数中调用this.get()方法。</li>
<li>在get()方法中，首先通过window.target&#x3D;this把实例自身赋给了全局的一个唯一对象window.target上，然后通过let value&#x3D;this.getter.call(vm, vm)获取一下被依赖的数据，获取被依赖数据的目的是触发该数据上面的getter。在getter里会调用dep.depend()收集依赖，而在dep.depend()中取到挂载window.target上的值并将其存入依赖数组中，在get()方法最后将window.target释放掉。</li>
<li>而当数据变化时，会触发数据的setter，在setter中调用了dep.notify()方法，在dep.notify()方法中，遍历所有依赖(即watcher实例)，执行依赖的update()方法，也就是Watcher类中的update()实例方法，在update()方法中调用数据变化的更新回调函数，从而更新视图。</li>
</ol>
<p>简单总结一下就是：Watcher先把自己设置到全局唯一的指定位置（window.target），然后读取数据。因为读取了数据，所以会触发这个数据的getter。接着，在getter中就会从全局唯一的那个位置读取当前正在读取数据的Watcher，并把这个Watcher收集到Dep中去。收集好之后，当数据发生变化时，会向Dep中的每个Watcher发送通知。通过这样的方式，Watcher可以主动去订阅任意一个数据的变化。<br> <img src="/2022/05/12/Vue/Watcher.png" srcset="/img/loading.gif" lazyload class=""></p>
<p>不足之处<br>虽然我们通过Object.defineProperty方法实现了对object数据的可观测，但是仅能观测到object数据的取值及设置值，当我们向object数据里添加一对新的key&#x2F;value或删除一对已有的key&#x2F;value时，它是无法观测到的，导致当我们对object数据添加或删除值时，无法通知依赖，无法驱动视图进行响应式更新。<br>当然，Vue也注意到了这一点，为了解决这一问题，Vue增加了两个全局API:Vue.set和Vue.delete</p>
<h2 id="5-4-Compiler模板编译器"><a href="#5-4-Compiler模板编译器" class="headerlink" title="5.4 Compiler模板编译器"></a>5.4 Compiler模板编译器</h2><p>Compiler主要的作用是把Vue绑定的DOM节点（也就el标签绑定的id）遍历该节点的所有子节点，找出其中所有的v-指令和  {{ }} 。</p>
<ol>
<li>如果子节点含有v-指令，即是元素节点，则对这个元素添加监听事件。如果是v-on，则node.addEventListener(‘click’)，如果是v-model，则node-addEventListener(‘input’)。接着初始化模板元素，创建一个Watcher绑定这个元素节点。<br>通过hasAttribute去判断某个节点是否存在我们自定义的指令，通过getAttribute去获取这个指令所绑定的data对象具体的属性（也就是频道）。</li>
</ol>
<hr>
<p>v-model的具体作用是绑定input或textarea标签的输入事件，当输入改变时，改变data对象中具体属性的值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (node.<span class="hljs-title function_">hasAttribute</span>(<span class="hljs-string">&quot;v-model&quot;</span>) &amp;&amp;(node.<span class="hljs-property">tagName</span> == <span class="hljs-string">&quot;INPUT&quot;</span> ||node.<span class="hljs-property">tagName</span> == <span class="hljs-string">&quot;TEXTAREA&quot;</span>)) &#123;<br>      <span class="hljs-comment">// 如果元素绑定了 v-model指令 且 元素为输入框</span><br>    node.<span class="hljs-title function_">addEventListener</span>(input<span class="hljs-string">&quot;,</span><br><span class="hljs-string">        (e) =&gt; &#123;</span><br><span class="hljs-string">          // 赋值对应的属性，更新订阅</span><br><span class="hljs-string">            const attr = node.getAttribute(&quot;</span>v-model<span class="hljs-string">&quot;);</span><br><span class="hljs-string">            this.$data[attr] = e.target.value;</span><br><span class="hljs-string">        &#125;,</span><br><span class="hljs-string">        false</span><br><span class="hljs-string">    );</span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure>
<hr>
<p>v-bind就是响应订阅</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (node.<span class="hljs-title function_">hasAttribute</span>(<span class="hljs-string">&quot;v-bind&quot;</span>)) &#123;<br>    <span class="hljs-keyword">const</span> attr = node.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">&quot;v-bind&quot;</span>);<br>    <span class="hljs-comment">// 创建 观众 - 自动订阅频道</span><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Watcher</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">$data</span>, attr, <span class="hljs-function">(<span class="hljs-params">newVal</span>) =&gt;</span> &#123;<br>    node.<span class="hljs-property">innerText</span> = newVal;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>
<ol start="2">
<li>如果子节点是文本节点，即  {{ data }} ，则用正则表达式取出  {{ data }} 中的data，然后var initText &#x3D; this.vm[exp]，用initText去代替其中的data。<br>解析  {{ }} 跟v-bind的思路一样，区别在于双括号语法是存在于文本节点中的，我们无法通过getAttribute去直接获取，所以我们要解析存在双括号语法的文本节点：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (node.<span class="hljs-property">childNodes</span>.<span class="hljs-property">length</span> !== <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">const</span> childList = node.<span class="hljs-property">childNodes</span>;<br>    childList.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">child</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (child.<span class="hljs-property">nodeType</span> === <span class="hljs-number">3</span>) &#123;<br>            <span class="hljs-comment">// 文本节点</span><br>            <span class="hljs-title function_">replaceStr</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">$data</span>, child);<br>        &#125;<br>    &#125;);<br>&#125;<br><span class="hljs-comment">//src/utils/index.js</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Watcher</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../core/Watcher&quot;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> replaceStr = <span class="hljs-keyword">function</span> (<span class="hljs-params">data, node</span>) &#123;<br>    <span class="hljs-keyword">const</span> replaceReg = <span class="hljs-regexp">/\&#123;\&#123;((?:.|\r?\n)+?)\&#125;\&#125;/g</span>;<br>    <span class="hljs-keyword">const</span> attrReg = <span class="hljs-regexp">/\&#123;\&#123;((?:.|\r?\n)+?)\&#125;\&#125;/</span>;<br>    <span class="hljs-keyword">const</span> str = node.<span class="hljs-property">data</span>;<br>    <span class="hljs-keyword">const</span> attr = str.<span class="hljs-title function_">match</span>(attrReg)[<span class="hljs-number">1</span>].<span class="hljs-title function_">trim</span>();<br>    <span class="hljs-comment">// 初始化赋值</span><br>    <span class="hljs-keyword">const</span> initRes = str.<span class="hljs-title function_">replace</span>(replaceReg, <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) &#123;<br>        <span class="hljs-keyword">return</span> data[attr];<br>    &#125;);<br>    node.<span class="hljs-property">data</span> = initRes;<br>    <span class="hljs-comment">// 创建 观众 - 自动订阅频道</span><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Watcher</span>(data, attr, <span class="hljs-function">(<span class="hljs-params">newVal</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">const</span> res = str.<span class="hljs-title function_">replace</span>(replaceReg, <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) &#123;<br>            <span class="hljs-keyword">return</span> newVal;<br>        &#125;);<br>        node.<span class="hljs-property">data</span> = res;<br>    &#125;);<br>&#125;;<br></code></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Compile</span>&#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">el, vm</span>)&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">$el</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">isElementNode</span>(el) ? <span class="hljs-attr">el</span>: <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(el);<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">$vm</span> = vm;<br>        <span class="hljs-comment">// 在内存中创建一个和 $el相同的元素节点</span><br>        <span class="hljs-keyword">let</span> fragment = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">node2fragment</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">$el</span>);<br>        <span class="hljs-comment">// 解析模板($el节点)</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">compile</span>(fragment);<br>        <span class="hljs-comment">// 将解析后的节点重新挂载到DOM树上</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">$el</span>.<span class="hljs-title function_">appendChild</span>(fragment);<br>    &#125;<br>    <span class="hljs-comment">// 判断node是否为元素节点</span><br>    <span class="hljs-title function_">isElementNode</span>(<span class="hljs-params">node</span>) &#123;<br>        <span class="hljs-keyword">return</span> node.<span class="hljs-property">nodeType</span> === <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 判断是否为v-开头的Vue指令</span><br>    <span class="hljs-title function_">isDirective</span>(<span class="hljs-params">attr</span>) &#123;<br>        <span class="hljs-keyword">return</span> attr.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&#x27;v-&#x27;</span>);<br>    &#125;<br>    <span class="hljs-title function_">isSpecialisDirective</span>(<span class="hljs-params">attr</span>)&#123;<br>        <span class="hljs-keyword">return</span> attr.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&#x27;@&#x27;</span>);<br>    &#125;<br>    <span class="hljs-title function_">compile</span>(<span class="hljs-params">fragment</span>)&#123;<br>        <span class="hljs-comment">// 获取根节点的子节点</span><br>        <span class="hljs-keyword">let</span> childNodes  = fragment.<span class="hljs-property">childNodes</span>;<br>        [...childNodes].<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">child</span> =&gt;</span>&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">isElementNode</span>(child))&#123;<br>                <span class="hljs-comment">// 解析元素节点的属性,查看是否存在Vue指令</span><br>                <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">compileElement</span>(child);<br>                <span class="hljs-comment">// 如果子节点也是元素节点,则递归执行该函数</span><br>                <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">compile</span>(child);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">// 解析文本节点,查看是否存在&quot;&#123;&#123;&#125;&#125;&quot;</span><br>                <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">compileText</span>(child);<br>            &#125;<br>        &#125;)<br>    &#125;<br>    <span class="hljs-comment">// 编译元素</span><br>    <span class="hljs-title function_">compileElement</span>(<span class="hljs-params">node</span>)&#123;<br>        <span class="hljs-comment">// 获取元素节点的所有属性</span><br>        <span class="hljs-keyword">let</span> attrs = node.<span class="hljs-property">attributes</span>;<br>        <span class="hljs-comment">// 遍历所有属性,查找是否存在Vue指令</span><br>        [...attrs].<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">attr</span> =&gt;</span>&#123;<br>            <span class="hljs-comment">// name: 属性名, expr: 属性值</span><br>            <span class="hljs-keyword">let</span> &#123;name, <span class="hljs-attr">value</span>:expr&#125; = attr;<br>            <span class="hljs-comment">// 判断是不是指令</span><br>            <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">isDirective</span>(name))&#123;<br>                <span class="hljs-keyword">let</span> [,directive] = name.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;-&#x27;</span>);<br>                <span class="hljs-comment">// 如果为指令则去设置该节点的响应式函数</span><br>                compileUtil[directive](node, expr, <span class="hljs-variable language_">this</span>.<span class="hljs-property">$vm</span>);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">isSpecialisDirective</span>(name))&#123;<br>                <span class="hljs-keyword">let</span> eventName = name.<span class="hljs-title function_">substr</span>(<span class="hljs-number">1</span>);<br>                compileUtil[<span class="hljs-string">&#x27;on&#x27;</span>](node, eventName, expr, <span class="hljs-variable language_">this</span>.<span class="hljs-property">$vm</span>);<br>            &#125;<br>        &#125;)<br>    &#125;<br>    <span class="hljs-comment">// 编辑文本</span><br>    <span class="hljs-title function_">compileText</span>(<span class="hljs-params">node</span>)&#123;<br>        <span class="hljs-keyword">let</span> content = node.<span class="hljs-property">textContent</span>;<br>        <span class="hljs-comment">// 匹配 &#123;&#123;xxx&#125;&#125;</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-regexp">/\&#123;\&#123;(.+?)\&#125;\&#125;/</span>.<span class="hljs-title function_">test</span>(content))&#123;<br>            compileUtil[<span class="hljs-string">&#x27;contentText&#x27;</span>](node, content, <span class="hljs-variable language_">this</span>.<span class="hljs-property">$vm</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 把节点移动到内存中</span><br>    <span class="hljs-title function_">node2fragment</span>(<span class="hljs-params">node</span>)&#123;<br>        <span class="hljs-comment">// 创建文档碎片</span><br>        <span class="hljs-keyword">let</span> fragment = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createDocumentFragment</span>();<br>        <span class="hljs-keyword">let</span> firstChild;<br>        <span class="hljs-keyword">while</span>(firstChild = node.<span class="hljs-property">firstChild</span>)&#123;<br>            <span class="hljs-comment">// appendChild具有移动性</span><br>            fragment.<span class="hljs-title function_">appendChild</span>(firstChild);<br>        &#125;<br>        <span class="hljs-keyword">return</span> fragment;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">const</span> compileUtil = &#123;<br>    <span class="hljs-title function_">getValue</span>(<span class="hljs-params">expr, vm</span>)&#123;<br>        <span class="hljs-keyword">let</span> valOrFn = expr.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;.&#x27;</span>).<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">totalValue, key</span>) =&gt;</span>&#123;<br>            <span class="hljs-keyword">if</span>(!totalValue[key]) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">return</span> totalValue[key];<br>        &#125;, vm)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> valOrFn === <span class="hljs-string">&#x27;function&#x27;</span> ? valOrFn.<span class="hljs-title function_">call</span>(vm) : valOrFn;<br>    &#125;,<br>    <span class="hljs-title function_">setValue</span>(<span class="hljs-params">expr, vm, value</span>)&#123;<br>        <span class="hljs-keyword">return</span> expr.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;.&#x27;</span>).<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">totalValue, key, index, arr</span>) =&gt;</span>&#123;<br>            <span class="hljs-keyword">if</span>(index === arr.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>) totalValue[key] = value;<br>            <span class="hljs-keyword">return</span> totalValue[key];<br>        &#125;, vm.<span class="hljs-property">$data</span>)<br>    &#125;,<br>    <span class="hljs-title function_">getContentValue</span>(<span class="hljs-params">content, vm</span>)&#123;<br>        <span class="hljs-keyword">return</span> content.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\&#123;\&#123;(.+?)\&#125;\&#125;/g</span>, <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getValue</span>(args[<span class="hljs-number">1</span>], vm);<br>         &#125;)<br>    &#125;,<br>    <span class="hljs-title function_">contentText</span>(<span class="hljs-params">node, content, vm</span>)&#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-title function_">fn</span> = (<span class="hljs-params"></span>) =&gt;&#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">textUpdater</span>(node, <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getContentValue</span>(content, vm));<br>        &#125;<br>        <span class="hljs-keyword">let</span> resText = content.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\&#123;\&#123;(.+?)\&#125;\&#125;/g</span>, <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span>&#123;<br>            <span class="hljs-comment">// args[1] 为&#123;&#123;xxx&#125;&#125;中的xxx</span><br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Watcher</span>(vm, args[<span class="hljs-number">1</span>], fn);<br>            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getValue</span>(args[<span class="hljs-number">1</span>], vm);<br>        &#125;);<br>        <span class="hljs-comment">// 首次解析直接替换文本内容</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">textUpdater</span>(node, resText);<br>    &#125;,<br>    <span class="hljs-title function_">text</span>(<span class="hljs-params">node, expr, vm</span>)&#123;<br>        <span class="hljs-keyword">let</span> value = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getValue</span>(expr, vm);<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">textUpdater</span>(node, value);<br>        <span class="hljs-keyword">let</span> <span class="hljs-title function_">fn</span> = (<span class="hljs-params"></span>) =&gt;<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">textUpdater</span>(node, <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getValue</span>(expr, vm));<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Watcher</span>(vm, expr, fn);<br>    &#125;,<br>    <span class="hljs-title function_">textUpdater</span>(<span class="hljs-params">node, value</span>)&#123;<br>        node.<span class="hljs-property">textContent</span> = value;<br>    &#125;,<br>    <span class="hljs-title function_">html</span>(<span class="hljs-params">node, expr, vm</span>)&#123;<br>        <span class="hljs-keyword">let</span> value = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getValue</span>(expr, vm);<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">htmlUpdater</span>(node, value);<br>        <span class="hljs-keyword">let</span> <span class="hljs-title function_">fn</span> = (<span class="hljs-params"></span>) =&gt;<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">htmlUpdater</span>(node, <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getValue</span>(expr, vm));<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Watcher</span>(vm, expr, fn);<br>    &#125;,<br>    <span class="hljs-title function_">htmlUpdater</span>(<span class="hljs-params">node, value</span>)&#123;<br>        node.<span class="hljs-property">textContent</span> = value;<br>    &#125;,<br>    <span class="hljs-title function_">model</span>(<span class="hljs-params">node, expr, vm</span>)&#123;<br>        <span class="hljs-keyword">let</span> value = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getValue</span>(expr, vm);<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">modelUpdater</span>(node, value);<br>        <span class="hljs-keyword">let</span> <span class="hljs-title function_">fn</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">modelUpdater</span>(node, <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getValue</span>(expr, vm));<br>        node.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;input&#x27;</span>, <span class="hljs-function">()=&gt;</span>&#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setValue</span>(expr, vm, node.<span class="hljs-property">value</span>);<br>        &#125;)<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Watcher</span>(vm, expr, fn)<br>    &#125;,<br>    <span class="hljs-title function_">modelUpdater</span>(<span class="hljs-params">node, value</span>)&#123;<br>        node.<span class="hljs-property">value</span> = value;<br>    &#125;,<br>    <span class="hljs-title function_">on</span>(<span class="hljs-params">node, eventName, expr, vm</span>)&#123;<br>        <span class="hljs-comment">// 改变this为vm实例</span><br>        <span class="hljs-keyword">let</span> fn = vm.<span class="hljs-property">$option</span>.<span class="hljs-property">methods</span>[expr].<span class="hljs-title function_">bind</span>(vm);<br>        <span class="hljs-comment">// 添加事件</span><br>        node.<span class="hljs-title function_">addEventListener</span>(eventName, fn);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<h1 id="六、组件化好处"><a href="#六、组件化好处" class="headerlink" title="六、组件化好处"></a>六、组件化好处</h1><ol>
<li>提高了开发效率</li>
<li>方便重复使用</li>
<li>简化了调试步骤</li>
<li>提升了项目的可维护性</li>
<li>便于协同开发</li>
</ol>
<h1 id="七、★VUE的指令"><a href="#七、★VUE的指令" class="headerlink" title="七、★VUE的指令"></a>七、★VUE的指令</h1><p>VUE的实例对象。<br> <img src="/2022/05/12/Vue/%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1.png" srcset="/img/loading.gif" lazyload class=""></p>
<h2 id="7-1-内容渲染指令（v-text、、v-html）"><a href="#7-1-内容渲染指令（v-text、、v-html）" class="headerlink" title="7.1 内容渲染指令（v-text、、v-html）"></a>7.1 内容渲染指令（v-text、 {{ }} 、v-html）</h2><p>用来辅助开发者渲染DOM元素的文本内容。</p>
<ul>
<li><strong>v-text</strong>：会覆盖标签原有内容。<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-text</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span>用户名<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure>
此时p标签显示的是username而非“用户名”。</li>
<li> {{ }} ：插值表达式，专门解决内容覆盖问题，只是内容的占位符，不会覆盖原有内容。
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>姓名：&#123;&#123;username&#125;&#125;<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure>
此时p标签显示的是”姓名：username对应的值”。</li>
<li>v-html：v-text和插值表达式只能渲染纯文本内容，如果要把包含HTML标签的字符串渲染为页面的HTML元素，则需要使用v-html指令。</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-html</span>=<span class="hljs-string">&quot;discription&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>description: &#x27;<span class="hljs-tag">&lt;<span class="hljs-name">h4</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color:red; font-weight:bold&quot;</span>&gt;</span>欢迎<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span>&#x27;<br></code></pre></td></tr></table></figure>
<p>使用如上方法时，username、discription等值都要写在data里，其中el要指向整个大盒子，调用data里的元素都要放到这个大盒子里才能生效。</p>
<h2 id="7-2-属性绑定指令（v-bind）"><a href="#7-2-属性绑定指令（v-bind）" class="headerlink" title="7.2 属性绑定指令（v-bind）"></a>7.2 属性绑定指令（v-bind）</h2><ul>
<li><strong>v-bind</strong>：为元素的<strong>属性</strong>动态绑定属性值，单向绑定，可以简写为冒号:。<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-bind:placeholder</span>=<span class="hljs-string">&quot;tips&quot;</span>&gt;</span><br>tips: &#x27;请输出用户名&#x27;<br></code></pre></td></tr></table></figure>
输入框中默认显示‘请输入用户名’<br>还支持简单JavaScript表达式的运算，不能一串逻辑语句，如：</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-bind:id</span>=<span class="hljs-string">&quot;&#x27;list-&#x27;+id&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>属性值tips、id写在data里。</p>
<h2 id="7-3-事件绑定指令（v-on）"><a href="#7-3-事件绑定指令（v-on）" class="headerlink" title="7.3 事件绑定指令（v-on）"></a>7.3 事件绑定指令（v-on）</h2><p>用来辅助程序员为DOM元素绑定事件监听。可以简写为@，如@click</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">&quot;addCount(1)&quot;</span>&gt;</span>+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>当点击该按钮时，触发函数addCount。在methods下定义事件处理函数，可以省略function和冒号，调用data里面变量直接用this.变量名。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">methods</span>: &#123;<br>    <span class="hljs-title function_">add</span>(<span class="hljs-params">参数<span class="hljs-number">1</span>, 参数<span class="hljs-number">2.</span>..</span>)&#123;<br>        <span class="hljs-comment">//操作</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>原生DOM对象有onclick、oninput、onkeyup等原生事件，替换为vue的事件绑定形式后分别为v-on:click、v-on:input、v-on:keyup</strong><br><font color=red>若要修改样式，调用时不用传参，在methods传参e（代表事件），vue提供了内置变量，名字叫$event，原生DOM的事件对象e。</font><br>样式修改，如果必须传参，如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;add(1,$event)&quot;</span>&gt;</span>+N<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>methods: &#123;<br>    add(n,e) &#123;<br>        this.count += n;<br>        if(this.count % 2 === 0)&#123;<br>            e.target.style.backgroundColor = &#x27;red&#x27;;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>事件修饰符</strong>：加在绑定事件后面。如</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span> @<span class="hljs-attr">click.prevent</span>=<span class="hljs-string">&quot;show&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>此时点击会执行show，但会阻止原有跳转操作。<br> <img src="/2022/05/12/Vue/%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6.png" srcset="/img/loading.gif" lazyload class=""></p>
<p><strong>事件冒泡</strong>：父元素和子元素有相同的事件，当触发子元素事件时，会向上冒泡，同时触发父元素事件。<br><strong>按键修饰符</strong>：在监听键盘事件时，需要判断详细的按键，此时为键盘相关的事件添加按键修饰符，如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> @<span class="hljs-attr">keyup.enter</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>当按下enter按键时执行vm.submit()</p>
<h2 id="7-4-双向绑定指令（v-model）"><a href="#7-4-双向绑定指令（v-model）" class="headerlink" title="7.4 双向绑定指令（v-model）"></a>7.4 双向绑定指令（v-model）</h2><p>辅助开发者在不操作DOM的前提下，快速获取表单的数据，可以和input、textarea、select使用。<br>真正实现靠的是v-bind绑定响应式数据和触发oninput时间并传递数据。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;searchText&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>相当于：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v:bind:value</span>=<span class="hljs-string">&quot;searchText&quot;</span> <span class="hljs-attr">v-on:input</span>=<span class="hljs-string">&quot;searchText=$event.target.value&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>从html5开始，input每次输入都会触发oninput事件，所以输入input的内容会绑定到searchText中，于是searchText的值就被改变。<br>$event指代当前触发的事件对象，$event.target指代当前触发的事件对象的DOM，$event.target.value就是当前DOM的value值。<br>在@input方法中，value&#x3D;&gt;searchText，在:value，searchText&#x3D;&gt;value。<br>表单绑定v-model</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;message&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript">            <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#app&quot;</span>,</span><br><span class="language-javascript">            <span class="hljs-attr">data</span>: &#123;</span><br><span class="language-javascript">                <span class="hljs-attr">message</span>: <span class="hljs-string">&quot;v-model的使用&quot;</span></span><br><span class="language-javascript">            &#125;</span><br><span class="language-javascript">        &#125;)</span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>当我们在输入框输入内容时，因为input中的v-model绑定了message，此时v-model相当于value属性。输入的内容传给message，message发生改变。<br>当message发生改变时，因为使用Mustache语法，将message的值插入到DOM中，所以DOM会发送相应的改变。<br>复选框：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;agree&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;agree&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;isAgree&quot;</span>&gt;</span>同意协议<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>您选择的是&#123;&#123;isAgree&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">:disabled</span>=<span class="hljs-string">&quot;!isAgree&quot;</span>&gt;</span>下一步<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript">      <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#app&quot;</span>,</span><br><span class="language-javascript">      <span class="hljs-attr">data</span>: &#123;</span><br><span class="language-javascript">        <span class="hljs-attr">isAgree</span>: <span class="hljs-literal">false</span>,</span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript">    &#125;)</span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>此时v-model相当于checked属性。<br>下拉菜单：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;city&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span>请选择城市<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span>北京<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span>上海<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>
 <img src="/2022/05/12/Vue/%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E4%BF%AE%E9%A5%B0%E7%AC%A6.png" srcset="/img/loading.gif" lazyload class="">

<h2 id="7-5-★★★条件渲染指令（v-if、v-show、v-else-if、v-else）"><a href="#7-5-★★★条件渲染指令（v-if、v-show、v-else-if、v-else）" class="headerlink" title="7.5 ★★★条件渲染指令（v-if、v-show、v-else-if、v-else）"></a>7.5 ★★★条件渲染指令（v-if、v-show、v-else-if、v-else）</h2><p>用来按需控制DOM的显示与隐藏，可以设置值等于某个值，该值的真假在js中修改，在data中设置。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;state===200&quot;</span>&gt;</span>被v-if控制<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">&quot;state===200&quot;</span>&gt;</span>被v-show控制<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p><strong>!!!!!!!! v-if与v-show区别</strong>：<br>v-show只是在display:none和display:block之间切换，无论初始条件是什么都会被渲染出来，后面只需要切换CSS，DOM还是一直保留着的。v-show在初始渲染时有更高的开销，但是切换开销很小，更适合频繁切换的场景。<br>v-if当属性初始值为false时，组件就不会渲染，直到条件为true，并且切换条件时会触发销毁&#x2F;挂载组件，所以总的来说在切换时开销更高，更适合于不经常切换的场景。<br>基于v-if的这种惰性渲染机制，可以在必要的时候才去渲染组件，减少整个页面的初始渲染开销。<br><strong>v-else-if</strong>指令，必须与v-if连续使用。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;type===&#x27;A&#x27;&quot;</span>&gt;</span>优秀<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-else-if</span>=<span class="hljs-string">&quot;type===&#x27;B&#x27;&quot;</span>&gt;</span>良好<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-else-if</span>=<span class="hljs-string">&quot;type===&#x27;C&#x27;&quot;</span>&gt;</span>一般<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-else</span>&gt;</span>差<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h2 id="7-6-列表渲染指令（v-for）"><a href="#7-6-列表渲染指令（v-for）" class="headerlink" title="7.6 列表渲染指令（v-for）"></a>7.6 列表渲染指令（v-for）</h2><p>用于辅助开发者基于一个数组来循环渲染一个列表结构。v-for指令需要使用item in items形式的特殊语法，其中items是待循环的数组，item是被循环的每一项，index是当前项的索引，即(item, index) in items</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(item,index) in list&quot;</span>&gt;</span>姓名是：&#123;&#123;item.name&#125;&#125;, 索引是：&#123;&#123;index&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>data: &#123;<br>    list: [<br>        &#123; id: 1, name: &#x27;zs&#x27; &#125;,<br>        &#123; id: 2, name: &#x27;ls&#x27; &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>只要用到v-for指令，一定要绑定一个key属性，而且尽量把id作为key的值（不重复），key的值只能是字符串或数字类型。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(item, index) in list&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;item.id&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>①key的值只能是字符串或数字类型。<br>②key的值必须具有唯一性。<br>③建议把数据项id属性的值作为key的值，因为id属性的值具有唯一性。<br>④使用index的值当做key的值没有任何意义，因为index的值不具有唯一性。<br>⑤建议使用v-for指令时一定要指定key的值，这样既提升性能、又防止列表状态紊乱。</p>
<h1 id="八、过滤器Filters-侦听器watch-计算属性computed"><a href="#八、过滤器Filters-侦听器watch-计算属性computed" class="headerlink" title="八、过滤器Filters|侦听器watch|计算属性computed"></a>八、过滤器Filters|侦听器watch|计算属性computed</h1><h2 id="8-1-过滤器Filters"><a href="#8-1-过滤器Filters" class="headerlink" title="8.1 过滤器Filters"></a>8.1 过滤器Filters</h2><p>常用于文本的格式化，可以用于插值表达式和v-bind属性绑定。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; message | capitalize &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-bind:id</span>=<span class="hljs-string">&quot;rawId | formatId&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>对p标签中的message借助capitalize进行格式化，显示的是返回值。对div标签的id对应的rawId的值用formatId进行格式化。<br>在Vue实例对象中，用filters声明过滤器函数，里面直接放函数，<strong>过滤器一定要有返回值</strong>。过滤器函数的形参值是|前面的值。</p>
<ul>
<li><strong>私有过滤器</strong>：定义到VUE实例中的过滤器都是私有过滤器，只能在当前vm实例所控制的el区域中使用。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>    <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,<br>    <span class="hljs-attr">data</span>: &#123;<br>        <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;hello&#x27;</span><br>    &#125;,<br>    <span class="hljs-attr">filters</span>:&#123;<br>        <span class="hljs-title function_">capitalize</span>(<span class="hljs-params">val</span>)&#123;<br>            <span class="hljs-keyword">const</span> first = val.<span class="hljs-title function_">charAt</span>(<span class="hljs-number">0</span>).<span class="hljs-title function_">toUpperCase</span>();<br>            <span class="hljs-keyword">const</span> other = val.<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">return</span> first + other;<br>        &#125;<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure></li>
<li><strong>全局过滤器</strong>：定义到vm实例之外。<strong>放到main.js之中</strong><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">filter</span>(<span class="hljs-string">&#x27;capitalize&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">str</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> str.<span class="hljs-title function_">charAt</span>(<span class="hljs-number">0</span>).<span class="hljs-title function_">toUpperCase</span>() + str.<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>);<br>&#125;)<br></code></pre></td></tr></table></figure>
可以连续使用过滤器，如data|first|second|third，此时先把data用first处理，结果再用second处理，结果再用third处理。<br>过滤器可以传参：</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; message | filterA(arg1, arg2) &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>Vue.filter(&#x27;filterA&#x27;, (msg, arg1, arg2) =&gt; &#123;<br>&#125;)<br></code></pre></td></tr></table></figure>
<h2 id="8-2-侦听器"><a href="#8-2-侦听器" class="headerlink" title="8.2 侦听器"></a>8.2 侦听器</h2><p>watch侦听器允许开发者监视数据的变化从而针对数据的变化做特定的操作。<strong>要监视哪个数据的变化就把数据名作为方法名</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>    <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,<br>    <span class="hljs-attr">data</span>: &#123; <span class="hljs-attr">username</span>: <span class="hljs-string">&#x27;&#x27;</span> &#125;,<br>    <span class="hljs-attr">watch</span>: &#123;<br>        <span class="hljs-title function_">username</span>(<span class="hljs-params">newVal, oldVal</span>)&#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newVal, oldVal);<br>        &#125;<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>
<p>此时监听username值的变化，当发生变化时，打印旧值和新值。</p>
<ul>
<li><strong>方法格式的侦听器</strong>：无法在刚进入页面的时候自动触发，如果侦听的是一个对象，如果<strong>对象中的属性发生变化，不会触发侦听器</strong>。</li>
<li><strong>对象格式的侦听器</strong>：可以通过immediate选项，让侦听器自动触发，此时用handler属性。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">watch</span>: &#123;<br>    <span class="hljs-attr">username</span>: &#123;<br>        <span class="hljs-title function_">handler</span>(newVal, oldVal)<br>    &#125;,<br>    <span class="hljs-attr">immediate</span>: <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure>
可以通过deep选项，让侦听器深度监听对象中每个属性的变化，对象中任何一个属性发生变化，都会触发对象的侦听器。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">watch</span>: &#123;<br>    <span class="hljs-attr">info</span>: &#123;<br>        <span class="hljs-title function_">handler</span>(<span class="hljs-params">newVal</span>)&#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newVal)<br>        &#125;,<br>        <span class="hljs-attr">deep</span>: <span class="hljs-literal">true</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
如果要侦听的是对象的子属性的变化，则必须包裹一层单引号，如’watch: {‘info.username’(newVal, oldVal){}}<h2 id="8-3-计算属性"><a href="#8-3-计算属性" class="headerlink" title="8.3 计算属性"></a>8.3 计算属性</h2>指的是通过一系列运算之后，最后得到一个属性值，这个动态计算出来的属性值可以被模板结构或methods方法使用。所有计算属性都定义到computed之下，定义时要定义成方法格式，使用时当成属性来用。实现了代码的复用，只要计算属性中依赖的任何一个属性变化了都会重新求值。<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box&quot;</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">&quot;&#123; background-color: rgb &#125;&quot;</span>&gt;</span><br>    &#123;&#123; rgb &#125;&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>var vm = new Vue(&#123;<br>    el: &#x27;#app&#x27;,<br>    data: &#123;<br>        r:0,<br>        g:0,<br>        b:0<br>    &#125;,<br>    computed: &#123;<br>        rgb() &#123; <br>            return &#x27;rgb($&#123;this.r&#125;, $&#123;this.g&#125;, $&#123;this.b&#125;)&#x27; &#125;<br>        &#125;<br>    &#125;,<br>    methods: &#123;<br>        show() &#123; console.log(this.rgb) &#125;<br>    &#125;,<br>&#125;)<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="8-4-computed和watch区别"><a href="#8-4-computed和watch区别" class="headerlink" title="8.4 computed和watch区别"></a>8.4 computed和watch区别</h2><p>computed是计算属性，依赖其它属性值计算，且computed的值有缓存，只有当计算值变化时才会返回内容。<br>watch监听到值的变化就会执行回调，在回调中可以进行一些逻辑操作。<br>所以一般来说需要依赖别的属性来动态获得值的时候可以用computed，对于监听到的变化需要做一些复杂的业务逻辑的情况可以使用watch。<br>computed是多对一或一对一时使用，watch是一对多时使用。</p>
<h1 id="九、私有子组件和全局组件"><a href="#九、私有子组件和全局组件" class="headerlink" title="九、私有子组件和全局组件"></a>九、私有子组件和全局组件</h1><h2 id="9-1-私有子组件"><a href="#9-1-私有子组件" class="headerlink" title="9.1 私有子组件"></a>9.1 私有子组件</h2><p>父组件使用子组件：<br>①在根组件的script中导入需要的组件import Left from ‘@&#x2F;components&#x2F;Left.vue’<br>②在export default中的components节点注册组件，可选的给组件命名：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    <span class="hljs-attr">components</span>: &#123;  <span class="hljs-comment">//这样注册的都是私有子组件</span><br>        <span class="hljs-title class_">Left</span>: <span class="hljs-string">&#x27;Left&#x27;</span>   <span class="hljs-comment">// 可以不用重命名，直接写Left</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>③以标签的形式使用刚才注册的组件：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">Left</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Left</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h2 id="9-2-全局组件"><a href="#9-2-全局组件" class="headerlink" title="9.2 全局组件"></a>9.2 全局组件</h2><p>在vue项目的main.js入口文件中，通过Vue.component()方法注册全局组件。在所有组件中，无需导入直接可以在模板中使用该组件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Count</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/components/Count.vue&#x27;</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;MyCount&#x27;</span>, <span class="hljs-title class_">Count</span>)<br></code></pre></td></tr></table></figure>

<h1 id="★十、组件通信"><a href="#★十、组件通信" class="headerlink" title="★十、组件通信"></a>★十、组件通信</h1><p>组件通信一般分为以下三种情况：<br>①父子组件通信<br>②兄弟组件通信<br>③跨多层级组件通信<br>通信的六种方式：<br>①props&#x2F; $emit（适用父子组件通信）<br>②ref &#x2F; $refs<br>③$emit &#x2F; $on （Eventbus，适用于父子，隔代，兄弟组件通信）<br>④provide &#x2F; inject（适用于隔代组件通信）<br>⑤$parent &#x2F; $children（适用父子组件通信）<br>⑥$attrs &#x2F; $listeners （适用于隔代组件通信）<br>⑦Vuex（适用于父子、隔代、兄弟组件通信）</p>
<h2 id="10-1-props-x2F-emit"><a href="#10-1-props-x2F-emit" class="headerlink" title="10.1 props&#x2F;$emit"></a>10.1 props&#x2F;$emit</h2><ul>
<li><strong>父组件向子组件共享数据用自定义属性props</strong>。<br>在子组件中定义props，父组件把数据定义在data中，使用子组件时直接传给子组件。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span>&#123;<br>    <span class="hljs-attr">props</span>: &#123;<br>        <span class="hljs-attr">init</span>: &#123;<br>            <span class="hljs-attr">default</span>: <span class="hljs-number">0</span>, <span class="hljs-comment">//如果外界使用的时候，没有传递init属性，默认值生效</span><br>            <span class="hljs-attr">type</span>: <span class="hljs-title class_">Number</span>,   <span class="hljs-comment">//定义init数据类型</span><br>            <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span> <span class="hljs-comment">//必填项校验，规定这个属性使用时是否要传值</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
父组件data中定义数据user。<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">MyCount</span> <span class="hljs-attr">v-bind:init</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">MyCount</span>&gt;</span><br></code></pre></td></tr></table></figure>
父组件调用子组件MyCount时将user的值传给子组件的init。<strong>使用v-bind是动态传递，传递的值可以是表达式、对象、布尔值等等，不使用v-bind传递的是静态字符串</strong>。<br>这种父子通信方式就是典型的单向数据流，父组件通过props传递数据，子组件不能直接修改props，而是必须通过发送事件的方式告知父组件修改数据。<br>组件中封装的props的值是只读的，<strong>不要直接修改</strong>，否则会报错。可以将props的值传给data中的值作为初始值，然后修改data中的值。</li>
<li><strong>子组件给父组件传值用自定义事件$emit</strong>。<br>这种方式还可以使用v-model来直接实现，因为v-model默认会解析成名为value的prop和名为input的事件，这种语法糖的方式是典型的双向绑定，常用与UI控件上，但究其根本，还是通过事件的方法让父组件修改数据。<br><strong>子组件</strong>：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> &#125;<br>    &#125;,<br>    <span class="hljs-attr">methods</span>: &#123;<br>        <span class="hljs-title function_">add</span>(<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> += <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">// 修改数据时，通过$emit()触发自定义事件numchange，将this.count传给父组件。</span><br>            <span class="hljs-variable language_">this</span>.$emit(<span class="hljs-string">&#x27;numchange&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<strong>父组件</strong>：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">Son</span> @<span class="hljs-attr">numchange</span>=<span class="hljs-string">&quot;getNewCount&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Son</span>&gt;</span><br>export default &#123;<br>    data() &#123;<br>        return &#123; countFromSon: 0 &#125;<br>    &#125;, <br>    methods: &#123;<br>        getNewCount(val) &#123;<br>            this.countFromSon = val;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="10-2-ref"><a href="#10-2-ref" class="headerlink" title="10.2 $ref"></a>10.2 $ref</h2>用来辅助开发者在不依赖jQuery的情况下，获取DOM元素或组件的引用，每个vue组件实例上，都包含一个针对$refs对象，对象里存储着对应DOM元素或组件的引用，默认情况下组件的$refs指向一个空对象。<br>如果在普通的DOM元素上使用，引用指向的就是DOM元素；如果用在子组件上，引用就指向组件实例，能够获取到在子组件里定义的属性和方法。<br><strong>使用方法</strong>：</li>
</ul>
<ol>
<li>给某个标签加一个ref名称，如<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;myh1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br></code></pre></td></tr></table></figure></li>
<li>修改DOM元素的时候，使用this.$refs.名称，如this.$refs.myh1。</li>
<li>修改DOM元素样式，直接this.$refs.myh1.color&#x3D;’red’。<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">my-counter</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;counterRef&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">my-counter</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;getRef&quot;</span>&gt;</span>获取$refs引用<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br> <br> methods: <br>    getRef() &#123;<br>        this.$refs.counterRef.add()     //直接调用my-counter的add函数。<br>    &#125;<br> &#125;<br></code></pre></td></tr></table></figure>
<strong>父传子</strong>：<br>父组件：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;Child ref=&quot;msg&quot;&gt;&lt;/Child&gt;<br>export default &#123;<br>    components: &#123;<br>        Child<br>    &#125;,<br>    data() &#123;<br>        return &#123;<br>            child: “父组件传的参数&quot;,<br>        &#125;<br>    &#125;,<br>    mounted()&#123;<br>        this.$refs.msg.message = this.child;    // 将child的值传给子组件msg的message。<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
子组件：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>export default &#123;<br>    data() &#123;<br>        return &#123;<br>            message: &quot;&quot;<br>        &#125;<br>    &#125;,<br>&#125;<br></code></pre></td></tr></table></figure>
<strong>子传父</strong>：<br>父组件：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">Child</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;givChild&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Child</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;&#123; data &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>export default&#123;<br>    components: &#123; Child &#125;,<br>    data() &#123;<br>        return &#123;<br>            data: &quot;&quot;,<br>        &#125;<br>    &#125;,<br>    mounted() &#123;<br>        this.$refs.givChild.$on(&quot;xxx&quot;, (e)=&gt;&#123;<br>            this.data = e;<br>        &#125;);<br>    &#125;,<br>&#125;<br></code></pre></td></tr></table></figure>
子组件：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;giveFather&quot;</span>&gt;</span>给父元素传数据<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>export default &#123;<br>    data() &#123;<br>        return &#123;<br>            data: &quot;这是子组件传来的&quot;<br>        &#125;<br>    &#125;,<br>    methods: &#123;<br>        giveFather() &#123;<br>            this.$emit(&#x27;xxx&#x27;, this.data)<br>        &#125;<br>    &#125;,<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="10-3-parent和-children"><a href="#10-3-parent和-children" class="headerlink" title="10.3 $parent和$children"></a>10.3 $parent和$children</h2>这种情况可以通过查找父组件中的子组件实现，也就是this.$parent.$children。在$children中可以通过组件name查询到需要的组件实例，然后进行通信。<br>使用$parent可以让组件访问父组件的实例（访问的是上一级父组件的属性和方法）。<br>使用$children可以让组件访问子组件的实例，但是$children并不能保证顺序，并且访问的数据也不是响应式的。<br>子组件：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>获取父组件的值为:  &#123;&#123;parentVal&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">      <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Vue&#x27;</span></span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  <span class="hljs-attr">computed</span>:&#123;</span><br><span class="language-javascript">    <span class="hljs-title function_">parentVal</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">$parent</span>.<span class="hljs-property">msg</span>;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>
父组件：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;hello_world&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">child</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">child</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;change&quot;</span>&gt;</span>点击改变子组件值<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> child <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./child.vue&#x27;</span></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-attr">components</span>: &#123; child &#125;,</span><br><span class="language-javascript">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">      <span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;Welcome&#x27;</span></span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  <span class="hljs-attr">methods</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-title function_">change</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-comment">// 获取到子组件</span></span><br><span class="language-javascript">      <span class="hljs-variable language_">this</span>.<span class="hljs-property">$children</span>[<span class="hljs-number">0</span>].<span class="hljs-property">message</span> = <span class="hljs-string">&#x27;JavaScript&#x27;</span></span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>
此时，子组件获得了父组件中msg的值，父组件改变了子组件中message的值。<br><strong>注意</strong>:<br>①通过$parent访问到的是上一级父组件的实例，可以使用$root来访问根组件的实例。<br>②在组件中使用$children拿到的是所有的子组件的实例，它是一个数组，并且是无序的。<br>③在根组件 #app 上拿 $parent 得到的是 new Vue()的实例，在这实例上再拿 $parent 得到的是undefined，而在最底层的子组件拿 $children 是个空数组<br>④$children 的值是数组，而 $parent是个对象<h2 id="10-4-eventBus事件总线"><a href="#10-4-eventBus事件总线" class="headerlink" title="10.4 eventBus事件总线"></a>10.4 eventBus事件总线</h2>它适用于父子组件、非父子组件等之间的通信。<br>①创建eventBus.js模块，并向外共享一个VUE的实例对象。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-comment">// 向外共享Vue的实例对象</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>()<br></code></pre></td></tr></table></figure>
②在数据发送方，调用bus.$emit(‘事件名称”, 要发送的数据)方法触发自定义事件。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> bus <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./eventBus.js&#x27;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> &#123;<br>            <span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;hello&#x27;</span><br>        &#125;<br>    &#125;,<br>    <span class="hljs-attr">methods</span>: &#123;<br>        <span class="hljs-title function_">sendMsg</span>(<span class="hljs-params"></span>) &#123;<br>            bus.$emit(<span class="hljs-string">&#x27;share&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">msg</span>)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
③在数据接收方，调用bus.$on(‘事件名称’,事件处理函数)方法注册一个自定义事件。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> bus <span class="hljs-keyword">from</span>  <span class="hljs-string">&#x27;./eventBus.js&#x27;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> &#123;<br>            <span class="hljs-attr">msgFrom</span>: <span class="hljs-string">&#x27;&#x27;</span><br>        &#125;<br>    &#125;,<br>    <span class="hljs-title function_">created</span>(<span class="hljs-params"></span>) &#123;<br>        bus.$on(<span class="hljs-string">&#x27;share&#x27;</span>, <span class="hljs-function"><span class="hljs-params">val</span>=&gt;</span>&#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">msgFrom</span> = val<br>        &#125;)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="10-5-attrs-x2F-listeners"><a href="#10-5-attrs-x2F-listeners" class="headerlink" title="10.5 $attrs&#x2F;$listeners"></a>10.5 $attrs&#x2F;$listeners</h2>适用于隔代组件通信。<br><strong>$attrs</strong>：包含了父作用域中不被 prop 所识别 (且获取) 的特性绑定 ( class 和 style 除外 )。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 ( class 和 style 除外 )，并且可以通过 v-bind&#x3D;”$attrs”传入内部组件。通常配合 inheritAttrs 选项一起使用。<br><strong>$listeners</strong>：包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on&#x3D;”$listeners”传入内部组件<h2 id="10-6-provide-x2F-inject"><a href="#10-6-provide-x2F-inject" class="headerlink" title="10.6 provide&#x2F;inject"></a>10.6 provide&#x2F;inject</h2>适用于隔代组件通信。<br>祖先组件中通过 provider 来提供变量，然后在子孙组件中通过 inject 来注入变量。provide &#x2F; inject API主要解决了跨级组件间的通信问题，不过它的使用场景，主要是子组件获取上级组件的状态，跨级组件间建立了一种主动提供与依赖注入的关系。<h2 id="10-7-Vuex"><a href="#10-7-Vuex" class="headerlink" title="10.7 Vuex"></a>10.7 Vuex</h2>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。<br>Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。<br>改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。</li>
</ol>
<h1 id="十一、scoped解决组件样式冲突"><a href="#十一、scoped解决组件样式冲突" class="headerlink" title="十一、scoped解决组件样式冲突"></a>十一、scoped解决组件样式冲突</h1><p>在VUE组件中，在style标签上添加scoped属性，以表示它的样式作用于当下的模块，很好的实现了样式私有化的目的，是一个非常好的机制。默认情况下，写在vue组件中的样式会全局生效，因此很容易造成多个组件之间的样式冲突问题。<br><strong>导致组件之间样式冲突的根本原因是</strong>：<br>①单页面应用程序中，所有组件的DOM结构，都是基于唯一的index.html页面进行呈现的。<br>②每个组件中的样式，都会影响整个index.html页面中的DOM元素。<br><strong>使用方法</strong>：直接在style标签末尾加scoped。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;less&quot;</span> <span class="hljs-attr">scpoed</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>主要通过使用PostCSS来实现以下转换：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="language-css"></span><br><span class="language-css">  <span class="hljs-selector-class">.example</span> &#123;</span><br><span class="language-css">     <span class="hljs-attribute">color</span>: red;</span><br><span class="language-css">  &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;example&quot;</span>&gt;</span>hi<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>//转换结果：<br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">  <span class="hljs-selector-class">.example</span><span class="hljs-selector-attr">[data-v-7668812d]</span> &#123;</span><br><span class="language-css">      <span class="hljs-attribute">color</span>: red;</span><br><span class="language-css">  &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;example&quot;</span> <span class="hljs-attr">data-v-7668812d</span>&gt;</span>hi<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>通过给DOM增加一个动态属性，然后CSS选择器也额外添加对应的属性来选择该DOM，达到该样式只作用于含有该属性的DOM，实现组件的模板化。</p>
<h4 id="特殊用法"><a href="#特殊用法" class="headerlink" title="特殊用法"></a>特殊用法</h4><p>scoped这个属性就是专门用于实现样式的模块化的，使用这个属性意味着样式不能经过外部或者全局的调整，在使用之初就应该规划好。但有时候我们可能要引入第三方组件，修改它的样式又不想去除scoped造成组件之间的样式污染，所以才有了下面的特殊用法。<br><strong>scoped穿透（深度作用选择器）</strong>：<br>如果希望scoped样式中的一个选择器能够作用的更深，例如影响子组件，可以使用&gt;&gt;&gt;操作符。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    .外层 &gt;&gt;&gt; .第三方组件 &#123; <span class="hljs-comment">/* ... */</span> &#125;&#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>或者要修改子组件中元素的样式，前面加&#x2F;deep&#x2F;。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    /deep/ <span class="hljs-selector-tag">h5</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">color</span>: pink;</span><br><span class="language-css">    &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>上述代码会编译成：.外层[data-v-7668812d] .第三方组件 {  &#x2F;* … * &#x2F;  }<br>通过’&gt;&gt;&gt;’ 可以使得在使用scoped属性的情况下，穿透scoped，修改其他组件的值。<br>实现原理其实就是加权重。<br>‘&gt;&gt;&gt;’ 功能由 vue-loader 提供。 vue-loader 专门用于解析 vue 文件，提取每个语言块（html、script、style），如有必要会通过其它 loader 处理，最后将他们组装成一个 CommonJS 模块，module.exports 出一个 Vue.js 组件对象。<br><strong>scoped实质</strong>就是添加了属性选择器增加了10的权重。</p>
<h1 id="★十二、生命周期钩子函数"><a href="#★十二、生命周期钩子函数" class="headerlink" title="★十二、生命周期钩子函数"></a>★十二、生命周期钩子函数</h1><p><strong>生命周期</strong>：指一个组件从创建-&gt;运行-&gt;销毁的整个阶段，强调的是一个时间段。<br><strong>生命周期函数</strong>：是由vue框架提供的内置函数，会伴随着组件的生命周期，自动按次序执行，强调的是时间点。这些函数直接写在export default里面，与methods平级。<br><strong>组件生命周期四个阶段</strong>：组件创建阶段、组件载入阶段、组件运行阶段、组件销毁阶段。</p>
<p><strong>钩子</strong>：hook，一种事件劫持机制，可以比事件更早进行执行处理。钩子可以理解为vue的内置事件，但是这个内置事件需要主动去配置，可以用来处理被拦截的函数调用、事件和消息。</p>
<h4 id="12-1-组件创建阶段："><a href="#12-1-组件创建阶段：" class="headerlink" title="12.1 组件创建阶段："></a>12.1 组件创建阶段：</h4><p>此时的函数都只会运行一次。<br>①new Vue()创建组件的实例对象<br>②初始化时间和生命周期函数，此时组件的props、data、methods都尚未被创建，都处于不可用状态。<br>③<strong>beforeCreate()</strong> ，此时vue实例挂载元素$el和数据对象data都为undefined，还未初始化。<br>④初始化props、data、methods。<br>⑤<strong>created</strong> ，组件的props、data、methods已经创建好，都处于可用的状态，但是$el还没有，组件的模板结构尚未生成，此时通常用来借助ajax拿数据，并将拿来的数据放到data中使用。</p>
<h4 id="12-2-组件载入阶段"><a href="#12-2-组件载入阶段" class="headerlink" title="12.2 组件载入阶段"></a>12.2 组件载入阶段</h4><p>此时的函数都只会运行一次。<br>①判断是否有el选项，没有看是否有vm.#mount(el)。<br>②基于数据和模板，在内存中编译生成HTML结构。<br>③<strong>beforeMount()</strong> ，此时vue实例的$el和data都初始化了，但还是挂载之前为虚拟的DOM节点，data.message还未替换。将要把内存中编译好的HTML结构渲染到浏览器中，此时浏览器中还没有当前组件的DOM结构。<br>④用内存中编译生成的HTML结构替换到el属性指定的DOM元素。<br>⑤<strong>mounted()</strong> ，此时vue实例挂载完成，data.message成功渲染，已经把内存中的HTML结构，成功的渲染到了浏览器之中，此时浏览器中已经包含了当前组件的DOM结构。</p>
<h4 id="12-3-组件运行阶段（更新）"><a href="#12-3-组件运行阶段（更新）" class="headerlink" title="12.3 组件运行阶段（更新）"></a>12.3 组件运行阶段（更新）</h4><p>函数会运行多次。<br>①数据发生变化<br>②<strong>beforeUpdate()</strong> ：数据更新时调用，将要根据变化过后、最新的数据，重新渲染组件的模板结构。<br>③根据最新的数据，重新渲染组建的DOM结构。<br>④<strong>update()</strong> ：已经根据最新的数据，完成了组件DOM结构的重新渲染。</p>
<h4 id="12-4-组件销毁阶段"><a href="#12-4-组件销毁阶段" class="headerlink" title="12.4 组件销毁阶段"></a>12.4 组件销毁阶段</h4><p>①<strong>beforeDestroy()</strong> ：实例销毁之前调用，此时实例仍然完全可用，将要销毁此组件，组件还处于正常工作的状态。<br>②销毁当前组件的数据侦听器、子组件、事件监听。<br>③<strong>destroyed()</strong> ：实例销毁后调用，此时组件已经被销毁，实例的所有东西都被解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁，此组件在浏览器中对应的DOM结构已经完全被移除。</p>
<h1 id="十三、data中对象添加新属性"><a href="#十三、data中对象添加新属性" class="headerlink" title="十三、data中对象添加新属性"></a>十三、data中对象添加新属性</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>    &lt;div&gt;<br>        &lt;ul&gt;    <br>            &lt;li v-for=&quot;value in obj&quot; :key=&quot;value&quot;&gt;&#123;&#123;value&#125;&#125;&lt;/li&gt;<br>        &lt;/ul&gt;<br>        &lt;button @click=&quot;addObjB&quot;&gt;添加obj.b&lt;/button&gt;<br>    &lt;/div&gt;<br>&lt;/template&gt;<br>&lt;script&gt;<br>export default&#123;<br>  data () &#123;<br>      return &#123;<br>        obj: &#123;<br>        a: &#x27;obj.a&#x27;<br>      &#125;<br>    &#125;<br>  &#125;,<br>  methods: &#123;<br>    addObjB () &#123;<br>        this.obj.b = &#x27;obj.b&#x27;<br>      console.log(this.obj)<br>    &#125;<br>  &#125;<br>&#125;<br>&lt;/script&gt;<br>&lt;style&gt;&lt;/style&gt;<br></code></pre></td></tr></table></figure>
<p>此时，点击button按钮会发现，obj.b已经成功添加，但视图未刷新。<br>在Vue实例创建时，obj.b并未声明，因此就没有被Vue转换为响应式的属性，自然不会触发视图的更新，此时需要使用Vue的全局api：$set()</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">addObjB () &#123;    <br><span class="hljs-comment">// this.obj.b = &#x27;obj.b&#x27;      </span><br><span class="hljs-variable language_">this</span>.$set(<span class="hljs-variable language_">this</span>.<span class="hljs-property">obj</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;obj.b&#x27;</span>)<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">obj</span>)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>$set() 方法相当于手动的去把 obj.b 处理成一个响应式的属性，此时视图也会跟着改变了。<br><strong>只要请求回来的数据，在页面渲染期间要用到，则必须要转存到data中</strong>。</p>
<h1 id="十四、动态组件与keep-alive"><a href="#十四、动态组件与keep-alive" class="headerlink" title="十四、动态组件与keep-alive"></a>十四、动态组件与keep-alive</h1><p>动态切换组件的显示与隐藏，例如设置多个按钮，控制在同一个区域内要显示哪个组件。<br>VUE提供了内置的<component>组件，专门用来实现动态组件的切换。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs vue">data() &#123;<br>    return &#123; comName: &#x27;Left&#x27; &#125;<br>&#125;<br>// 通过is属性，动态指定要渲染的组件<br>&lt;component :is=&quot;comName&quot;&gt;&lt;/component&gt;<br>// 点击按钮，动态切换组件的名称<br>&lt;button @click=&quot;comName=&#x27;Left&#x27; &quot;&gt;展示Left组件&lt;/button&gt;<br>&lt;button @click=&quot;comName=&#x27;Right&#x27; &quot;&gt;展示Right组件&lt;/button&gt;<br></code></pre></td></tr></table></figure>
<p><strong>动态组件切换的时候原来的组件会被销毁，创建新的组件。</strong><br><strong>使用keep-alive使得组件被切换时不会被销毁，仍然保持</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vue">// include指定哪些组件会被缓存，可选<br>&lt;keep-alive include=&quot;Left,Right&quot;&gt;<br>    &lt;component :is=&quot;comName&quot;&gt;&lt;/component&gt;<br>&lt;/keep-alive&gt;<br></code></pre></td></tr></table></figure>
<p>如果在声明组件的时候，没有为组件指定name名称，则组件的名称默认就是注册时候的名称。如果指定了名称，调用的时候就要用指定的名称。<br><strong>声明name</strong>：在组件的export default中，添加name:’name’。<br>组件的注册名称主要应用场景是以标签的形式把注册好的组件渲染和使用到页面结构中。<br>组件声明时候的name名称的主要应用场景：结合keep-alive标签实现组件缓存功能，以及在调试工具中看到组件的name名称。</p>
<h2 id="14-1-keep-alive"><a href="#14-1-keep-alive" class="headerlink" title="14.1 keep-alive"></a>14.1 keep-alive</h2><ul>
<li><p><strong>用法</strong>：<br>三个属性值：<strong>使用include指定哪些组件会被缓存，exclude指定哪些组件不会被缓存，二者只能同时用一个，max指定最多缓存多少个组件</strong>。<br><strong>keep-alive对应生命周期函数</strong>：<br>当组件被缓存时，会自动触发组件的deactivated生命周期函数（组件被停用时调用）。<br>当组件被激活时，会自动触发组件的activated生命周期函数（组件第一次渲染）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;keep-alive&gt;<br>  &lt;coma v-if=&quot;visible&quot;&gt;&lt;/coma&gt;<br>  &lt;comb v-else&gt;&lt;/comb&gt;<br>&lt;/keep-alive&gt;<br>&lt;button @click=&quot;visible = !visible&quot;&gt;更改&lt;/button&gt;<br></code></pre></td></tr></table></figure>
<p><strong>例如在coma和comb都有一个input都有对应的value，如果我们不用keep-alive，当更改visible的时候，这两个组件都会重新渲染，先前输入的内容就会丢失，会执行一遍完整的生命周期流程:beforeCreate &#x3D;&gt; created…。</strong><br>但是如果我们用了keep-alive，那么在次切换visible的时候，input对应的value为上次更改时候的值。 所以keep-alive主要是用于保持组件的状态，避免组件反复创建。</p>
</li>
<li><p><strong>原理</strong>：keep-alive的文件位置在src&#x2F;core&#x2F;components&#x2F;keep-alive.js中。<br>①keep-alive是一个组件，包括三个属性include、exclude和max。<br>②在created中创建缓存容器cache和缓存组件的key属性，cache用于保存vnode节点。<br>③在destroyed组件销毁时循环销毁清空所有的cache缓存和key，清空缓存中的所有组件实例。<br>④mounted监听include和exclude属性，进行组件的缓存处理。如果这两个属性发生了变化，即表示定义需要缓存的组件的规则或不要缓存的组件的规则发生了变化，就执行pruneCache函数，更新cache缓存。<br>⑤<strong>render</strong>：<br>  先获取插槽中的内容，然后用getFirstComponentChild方法获取第一个子组件，获取该组件的name。<br>  用获取到的name和传入的include和exclude属性进行匹配，如果匹配不成功，则表示不缓存这个组件，直接返回这个组件的vnode，否则，进行下一步缓存。<br>  用name去缓存cache中找是否有该值，如果命中缓存则直接从缓存中拿node的组件实例，并重新调整该组件key（节点的标识）的顺序，将其从原位置删除并放在keys的最后一个。（LRU）<br>  如果没有命中缓存，即该组件还没被缓存过，则以该组件key为键，组件vnode为值存入缓存cache中，key存入keys中。然后再判断缓存组件数量是否超过最大缓存数量值，超过了就把第一个缓存组件删掉。（删除原因：LRU最近最少使用策略）<br>  设置第一个子组件对象的keep-alive为true。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    <span class="hljs-attr">abstract</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">props</span>: &#123;<br>        <span class="hljs-attr">include</span>: patternTypes, <span class="hljs-comment">// 缓存白名单</span><br>        <span class="hljs-attr">exclude</span>: patternTypes, <span class="hljs-comment">// 缓存黑名单</span><br>        <span class="hljs-attr">max</span>: [<span class="hljs-title class_">String</span>, <span class="hljs-title class_">Number</span>] <span class="hljs-comment">// 缓存的实例上限</span><br>    &#125;,<br>    <span class="hljs-title function_">created</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">// 用于缓存虚拟DOM</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>);<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">keys</span> = [];<br>    &#125;,<br>    destroyed () &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>) &#123;<span class="hljs-comment">// keep-alive销毁时,循环清空所有的缓存和key</span><br>            <span class="hljs-title function_">pruneCacheEntry</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>, key, <span class="hljs-variable language_">this</span>.<span class="hljs-property">keys</span>)<br>        &#125;<br>    &#125;,<br>     <span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>) &#123;<br>    / 用于监听黑白名单，如果发生调用pruneCache<br>    <span class="hljs-comment">// pruneCache更新vue的cache缓存</span><br>        <span class="hljs-variable language_">this</span>.$watch(<span class="hljs-string">&#x27;include&#x27;</span>, <span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> &#123;<br>            <span class="hljs-title function_">pruneCache</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-function"><span class="hljs-params">name</span> =&gt;</span> <span class="hljs-title function_">matches</span>(val, name))<br>        &#125;)<br>        <span class="hljs-variable language_">this</span>.$watch(<span class="hljs-string">&#x27;exclude&#x27;</span>, <span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> &#123;<br>            <span class="hljs-title function_">pruneCache</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-function"><span class="hljs-params">name</span> =&gt;</span> !<span class="hljs-title function_">matches</span>(val, name))<br>        &#125;)<br>    &#125;<br>    <br>    <br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">const</span> slot = <span class="hljs-variable language_">this</span>.<span class="hljs-property">$slots</span>.<span class="hljs-property">default</span> <span class="hljs-comment">// 获取默认插槽中的第一个组件节点</span><br>        <span class="hljs-keyword">const</span> <span class="hljs-attr">vnode</span>: <span class="hljs-title class_">VNode</span> = <span class="hljs-title function_">getFirstComponentChild</span>(slot)<br> <span class="hljs-comment">// 获取该组件节点的componentOptions（用来挂载部分组件选项，包括Ctor、tag、propsData、listeners、children。非组件的该项为空）</span><br>        <span class="hljs-keyword">const</span> componentOptions = vnode &amp;&amp; vnode.<span class="hljs-property">componentOptions</span><br>        <span class="hljs-keyword">if</span> (componentOptions) &#123;<br>            <span class="hljs-comment">//  获取该组件的名称，优先获取组件的name字段，如果name不存在则获取组件的tag</span><br>            <span class="hljs-keyword">const</span> name = <span class="hljs-title function_">getComponentName</span>(componentOptions)<br>            <span class="hljs-keyword">const</span> &#123; include, exclude &#125; = <span class="hljs-variable language_">this</span><br>            <span class="hljs-keyword">if</span> (  <span class="hljs-comment">// 如果name不在include中或者存在与exclude中则不缓存，直接返回vnode</span><br>                (include &amp;&amp; (!name || !<span class="hljs-title function_">matches</span>(include, name))) || (exclude &amp;&amp; name &amp;&amp; <span class="hljs-title function_">matches</span>(exclude, name))<br>            ) &#123;<br>                <span class="hljs-keyword">return</span> vnode<br>            &#125;<br> <br>            <span class="hljs-comment">// 如果组件没key 就自己通过 组件的标签和key和cid 拼接一个key</span><br>            <span class="hljs-keyword">const</span> &#123; cache, keys &#125; = <span class="hljs-variable language_">this</span><br>            <span class="hljs-keyword">const</span> key = vnode.<span class="hljs-property">key</span> == <span class="hljs-literal">null</span> ? componentOptions.<span class="hljs-property">Ctor</span>.<span class="hljs-property">cid</span> + (componentOptions.<span class="hljs-property">tag</span> ?<span class="hljs-string">`::<span class="hljs-subst">$&#123;componentOptions.tag&#125;</span>`</span> : <span class="hljs-string">&#x27;&#x27;</span>) : vnode.<span class="hljs-property">key</span><br><br>            <span class="hljs-keyword">if</span> (cache[key]) &#123; <span class="hljs-comment">// 如果缓存中有key，直接从缓存中拿vnode的组件实例</span><br>                vnode.<span class="hljs-property">componentInstance</span> = cache[key].<span class="hljs-property">componentInstance</span><br>                <span class="hljs-comment">// 调整该组件key的顺序，将其从原来地方删掉并重新放在最后一个。</span><br>                <span class="hljs-title function_">remove</span>(keys, key) <span class="hljs-comment">// 删除当前的key，用LRU 最近最久未使用法</span><br>                keys.<span class="hljs-title function_">push</span>(key)  <span class="hljs-comment">// 并将key放到缓存的最后面</span><br>            &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//如果没有命中缓存，则将其放入缓存。</span><br>                cache[key] = vnode <span class="hljs-comment">// 缓存vnode</span><br>                keys.<span class="hljs-title function_">push</span>(key) <span class="hljs-comment">// 将key 存入</span><br>        <br>                <span class="hljs-comment">// 如果配置了max且缓存的长度超过了this.max，则从缓存中删除第一个</span><br>                <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">max</span> &amp;&amp; keys.<span class="hljs-property">length</span> &gt; <span class="hljs-built_in">parseInt</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">max</span>)) &#123;<br>                    <span class="hljs-title function_">pruneCacheEntry</span>(cache, keys[<span class="hljs-number">0</span>], keys, <span class="hljs-variable language_">this</span>.<span class="hljs-property">_vnode</span>) <span class="hljs-comment">// 要删除第0个 但是现在渲染的就是第0个</span><br>                &#125;<br>            &#125;<br>            vnode.<span class="hljs-property">data</span>.<span class="hljs-property">keepAlive</span> = <span class="hljs-literal">true</span> <span class="hljs-comment">// 设置keepAlive标记位</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> vnode || (slot &amp;&amp; slot[<span class="hljs-number">0</span>]) <span class="hljs-comment">// 返回当前的虚拟节点</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="14-2-keep-alive首次渲染"><a href="#14-2-keep-alive首次渲染" class="headerlink" title="14.2 keep-alive首次渲染"></a>14.2 keep-alive首次渲染</h2> <img src="/2022/05/12/Vue/keep-alive%E9%A6%96%E6%AC%A1%E6%B8%B2%E6%9F%93.png" srcset="/img/loading.gif" lazyload class=""></li>
</ul>
<p>页面首次渲染的时候，组件的渲染过程是先子组件后父组件，所以这里就能拿到子组件的数据，然后把子组件的vnode信息存到缓存cache中，并把子组件的keepAlive标记为设置为true。<br><strong>Vue会拿到前面生成的Vnode对象执行真实节点创建的过程，就是patch过程</strong>。patch执行阶段会调用createElm创建真实dom，在创建节点途中，<strong>keep-alive的vnode对象会被认定为一个组件Vnode，针对组件Vnode会执行createComponent函数，它会对keep-alive的组件进行初始化和实例化</strong>。<br><strong>keep-alive组件会先调用内部钩子init方法进行初始化操作。</strong>第一次执行时，组件vnode没有componentInstance属性，vnode.data.keepAlive也没有值，此时会调用createComponentInstanceForVnode方法进行组件实例化并将组件实例赋值给vnode的componentInstance属性，最终执行组件实例的$mount方法进行实例挂载。<br>createComponentInstanceForVnode就是组件实例化的过程。</p>
<h2 id="14-3-为什么切换组件后组件内数据仍保留"><a href="#14-3-为什么切换组件后组件内数据仍保留" class="headerlink" title="14.3 为什么切换组件后组件内数据仍保留"></a>14.3 为什么切换组件后组件内数据仍保留</h2><p>在首次渲染时，更改组件coma中input的值，查看当visible的值再次变为true时input是否会记住前面的值，因为更改visible的值后会执行updateComponent，即重新执行keep-alive的render函数。因为首次渲染时已经把数据存入到cache中，所以这次数据直接从cache中获取执行。<br>vnode.componentInstance &#x3D; cache[key].componentInstance<br>在首次渲染的时候，当key值不存在的时候会首先将子组件的vnode缓存起来，首次渲染时componentInstance是undefined，它在patch过程中调用组件的init钩子才生成的。当发生组件切换时，先前的状态信息重新赋值给了组件coma，vnode.componentInstance在keep-alive时已经进行重新赋值，且keepAlive为true，所以只会执行prepatch，不会执行created和mounted钩子。</p>
<h2 id="14-4-keep-alive在首次渲染和patch过程中的差异"><a href="#14-4-keep-alive在首次渲染和patch过程中的差异" class="headerlink" title="14.4 keep-alive在首次渲染和patch过程中的差异"></a>14.4 keep-alive在首次渲染和patch过程中的差异</h2><p><strong>首次渲染</strong>：keep-alive终究是一个组件，会执行组件相应的逻辑，在首次渲染的时候执行patch操作，执行到core&#x2F;vdom&#x2F;patch中。首次渲染时componentInstance并不存在，只执行init钩子，init具体作用就是创建子组件实例。<br><strong>更改数据后patch过程</strong>：当data中的值发生改变时，会触发updateComponent，此时会重新执行keep-alive的render函数，重新执行根组件的patch过程。</p>
<h2 id="14-5-keep-alive是否必须"><a href="#14-5-keep-alive是否必须" class="headerlink" title="14.5 keep-alive是否必须"></a>14.5 keep-alive是否必须</h2><p>keep-alive对于缓存数据有巨大帮助，可以防止组件反复创建。<br><strong>使用场景</strong>：页面中，如果返回上一个页面会刷新数据，需要保留离开页面时的状态，此时需要keep-alive。<br><strong>不使用场景</strong>：如果组件切换不需要保存状态，此时使用keep-alive需要在activated重置这些属性。如果所有变量都进行重置，风险是否可控。所有缓存都放在了cache中，当组件过多的时候内容过多，导致这个对象巨大，不一定能提高性能要求。</p>
<h1 id="十五、slot插槽"><a href="#十五、slot插槽" class="headerlink" title="十五、slot插槽"></a>十五、slot插槽</h1><p>插槽，是<strong>组件的一块HTML模板</strong>，允许开发者在封装组件时把不确定、希望用户指定的部分定义为插槽。核心问题是是否显示和怎样显示。每个插槽都要指定一个name名称，如果省略了则有一个默认的名称叫做default。<br>在组件中放置<slot></slot>，当用户调用组件，并在组件的标签中输入内容时，这些内容会被放到组件的slot标签位置显示，默认在使用组件时提供的内容被填充到名字为default的插槽中。<br>任何一个组件都可以分为非插槽模板和插槽模板两类。非插槽模板指的是html模板，比如div、span，它们的显示与隐藏、怎样显示由组件自身控制。插槽模板是slot，它是一个空壳，显示与隐藏、最后长什么样由父组件控制，但是插槽显示的位置由子组件自身决定，slot写在组件template的什么位置，父组件传过来的模板将来就显示在什么位置。<br><strong>父组件指定内容放到子组件某个插槽</strong>：用v-slot，不能直接使用在元素上，需要套一个盒子，可以简写为#，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;child&gt;<br>    &lt;template v-slot:title&gt;<br>        &lt;p&gt;123&lt;/p&gt;<br>    &lt;/template&gt;<br>&lt;/child&gt;<br></code></pre></td></tr></table></figure>
<p>此处v-slot:子组件插槽名name&#x3D;”给插槽起的新名字”，旧版本中组件名用slot&#x3D;’插槽名’，slot-scope&#x3D;’插槽新名字’<br><strong>指定默认内容（后备内容）</strong>：直接在子组件里放置的slot标签内部放置内容，这些内容就是默认的内容，当用户没有指定的时候就显示默认的内容，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;slot name=&quot;title&quot;&gt;<br>    &lt;p&gt;123&lt;/p&gt;<br>&lt;/slot&gt;<br></code></pre></td></tr></table></figure>
<h4 id="15-1-单个插槽-默认插槽-匿名插槽"><a href="#15-1-单个插槽-默认插槽-匿名插槽" class="headerlink" title="15.1 单个插槽 | 默认插槽 | 匿名插槽"></a>15.1 单个插槽 | 默认插槽 | 匿名插槽</h4><p>不用设置name属性，可以放在组件的任意位置，一个组件中只能有一个该类插槽。具名插槽可以放多个，只要它们的名字不同就可以。</p>
<h4 id="15-2-具名插槽"><a href="#15-2-具名插槽" class="headerlink" title="15.2 具名插槽"></a>15.2 具名插槽</h4><p>给插槽设置name属性，可以在一个组件中出现多次，但每次name值不同。</p>
<h4 id="15-3-作用域插槽"><a href="#15-3-作用域插槽" class="headerlink" title="15.3 作用域插槽"></a>15.3 作用域插槽</h4><p>在封装组件时，为预留的slot提供属性对应的值，在调用组件时，可以使用组件插槽预留的值，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs vue">// 子组件里<br>&lt;slot name=&quot;content&quot; msg=&quot;hello vue.js&quot;&gt;&lt;/slot&gt;<br><br>// 父组件<br>&lt;template #content=&quot;obj&quot;&gt;    <br>    &lt;div&gt;<br>        &lt;p&gt;&#123;&#123; obj.msg &#125;&#125;&lt;/p&gt;<br>    &lt;/div&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure>
<p>也可以不给插槽命名：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;slot name=&quot;content&quot; msg=&quot;hello vue.js&quot; :user=&quot;userinfo&quot;&gt;&lt;/slot&gt;<br><br>&lt;template #content=&quot;&#123;msg,user&#125;&quot;&gt;<br>    &lt;div&gt;<br>        &lt;p&gt;&#123;&#123; msg &#125;&#125;&lt;/p&gt;<br>        &lt;p&gt;&#123;&#123; user.username &#125;&#125;&lt;/p&gt;<br>    &lt;/div&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure>

<h1 id="十六、自定义指令"><a href="#十六、自定义指令" class="headerlink" title="十六、自定义指令"></a>十六、自定义指令</h1><p>分为两类：私有自定义指令和全局自定义指令。<br>VUE2.0中，代码复用和抽象的主要形式是组件，然有需要对DOM元素进行底层操作，这时就需要使用自定义指令。一般需要对DOM元素进行底层操作时使用，尽量只用来操作DOM展示，不修改内部的值，当使用自定义指令直接修改value值时绑定v-model的值也不会同步更新； 如果必须修改可以在自定义指令中使用keydown事件，在vue组件中使用change事件，回调中修改vue数据。</p>
<h4 id="16-1-私有自定义指令"><a href="#16-1-私有自定义指令" class="headerlink" title="16.1 私有自定义指令"></a>16.1 私有自定义指令</h4><p>在每个组件中，在directives节点下声明私有自定义指令，使用时名字前加v-，如v-color。当指令第一次被绑定到元素上时立即触发bind函数，形参中的el表示当前指令所绑定到的那个DOM对象，update函数会在每次DOM更新时被调用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">directives</span>: &#123;<br>    <span class="hljs-attr">color</span>: &#123;<br>        <span class="hljs-comment">// 当指令第一次被绑定到元素时使用</span><br>        <span class="hljs-title function_">bind</span>(<span class="hljs-params">el. binding</span>) &#123;<br>            el.<span class="hljs-property">style</span>.<span class="hljs-property">color</span> = binding.<span class="hljs-property">value</span><br>        &#125;,<br>        <span class="hljs-comment">// 每次DOM更新时被调用</span><br>        <span class="hljs-title function_">update</span>(<span class="hljs-params">el, binding</span>) &#123;<br>            el.<span class="hljs-property">style</span>.<span class="hljs-property">color</span> = binding.<span class="hljs-property">value</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>可以给私有自定义指令传参，此时给bind函数增加一个形参，如binding，传递参数的实际值放在value里了。此时调用该指令，可以传变量值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;h1 v-color=&quot;data&quot;&gt;&lt;/h1&gt;<br></code></pre></td></tr></table></figure>
<p>如果要直接传值，则需要用单引号括起来。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;h1 v-color=&quot;&#x27;red&#x27;&quot;&gt;&lt;/h1&gt;<br></code></pre></td></tr></table></figure>
<h4 id="16-2-全局自定义指令"><a href="#16-2-全局自定义指令" class="headerlink" title="16.2 全局自定义指令"></a>16.2 全局自定义指令</h4><p>需要通过Vue.directive()进行声明，全局自定义指令都必须放到main.js中，里面也可以分为bind和update两个函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vue">Vue.directive(&#x27;color&#x27;, function(el,binding) &#123;<br>    el.style.color = binding.value<br>&#125;）<br></code></pre></td></tr></table></figure>
<h4 id="16-3-指令钩子函数及其参数"><a href="#16-3-指令钩子函数及其参数" class="headerlink" title="16.3 指令钩子函数及其参数"></a>16.3 指令钩子函数及其参数</h4><ul>
<li>bind：只调用一次，指令第一次绑定到元素时调用，在这里可以进行一次性的初始化设置。</li>
<li>inSerted：被绑定元素插入父节点时调用，仅保证父节点存在，但不一定已经被插入文档中。</li>
<li>update：所在组件的vnode更新时调用，但可能发生在其子vnode更新之前调用。指令的值可能发生了改变，也可能没有，可以通过比较更新前后的值来忽略不必要的模板更新。</li>
<li>ComponentUpdate：指令所在组件的vnode及其子vnode全部更新后调用。</li>
<li>unbind：只调用一次，指令与元素解绑时调用。<br><strong>参数</strong>：</li>
<li>el：绑定元素</li>
<li>name、value、oldValue、expression、arg、modifers</li>
<li>vnode：虚拟节点</li>
<li>oldVnode：上一个虚拟节点，只在更新钩子函数中才有。</li>
</ul>
<h4 id="16-4-使用场景"><a href="#16-4-使用场景" class="headerlink" title="16.4 使用场景"></a>16.4 使用场景</h4><ul>
<li>普通DOM元素进行底层操作的时候，可以使用自定义指令。</li>
<li>自定义指令是用来操作DOM的，尽管Vue推崇数据驱动视图的理念，但并非所有情况都适合数据驱动。自定义指令就是一种有效的补充和扩展，不仅可以用于定义任何的DOM操作，并且是可复用的。</li>
</ul>
<h4 id="16-5-使用案例"><a href="#16-5-使用案例" class="headerlink" title="16.5 使用案例"></a>16.5 使用案例</h4><p>鼠标聚焦、下拉菜单、相对时间转换、滚动动画、自定义指令实现图片懒加载、自定义指令集成第三方插件。</p>
<h1 id="★十七、父子组件生命周期函数"><a href="#★十七、父子组件生命周期函数" class="headerlink" title="★十七、父子组件生命周期函数"></a>★十七、父子组件生命周期函数</h1><img src="/2022/05/12/Vue/%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" srcset="/img/loading.gif" lazyload class=""> 

<h1 id="十八、Patch和diff"><a href="#十八、Patch和diff" class="headerlink" title="十八、Patch和diff"></a>十八、Patch和diff</h1><p>diff的过程就是调用名为patch的函数，比较新旧节点，一边比较一边给真实的DOM打补丁。<br>我们<strong>先根据真实DOM生成一颗虚拟dom树，当虚拟dom某个节点的数据改变后会生成一个新的Vnode，然后Vnode和oldVnode作对比，发现有不一样的地方就直接修改在真实的DOM上，然后使oldVnode的值为Vnode</strong>。<br><strong>以新的VNode为基准，改造旧的oldVNode使之成为跟新的VNode一样，这就是patch过程要干的事</strong>。<br><strong>Patch主要干三件事</strong>：</p>
<ul>
<li>创建节点：新的VNode中有而旧的oldVNode中没有，就在旧的oldVNode中创建。</li>
<li>删除节点：新的VNode中没有而旧的oldVNode中有，就从旧的oldVNode中删除。</li>
<li>更新节点：新的VNode和旧的oldVNode中都有，就以新的VNode为准，更新旧的oldVNode。</li>
</ul>
<h2 id="18-1-创建节点"><a href="#18-1-创建节点" class="headerlink" title="18.1 创建节点"></a>18.1 创建节点</h2><p>源码位置: &#x2F;src&#x2F;core&#x2F;vdom&#x2F;patch.js</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createElm</span> (vnode, parentElm, refElm) &#123;<br>    <span class="hljs-keyword">const</span> data = vnode.<span class="hljs-property">data</span><br>    <span class="hljs-keyword">const</span> children = vnode.<span class="hljs-property">children</span><br>    <span class="hljs-keyword">const</span> tag = vnode.<span class="hljs-property">tag</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isDef</span>(tag)) &#123;<span class="hljs-comment">//如果有tag就是元素节点</span><br>        vnode.<span class="hljs-property">elm</span> = nodeOps.<span class="hljs-title function_">createElement</span>(tag, vnode)   <span class="hljs-comment">// 创建元素节点</span><br>        <span class="hljs-title function_">createChildren</span>(vnode, children, insertedVnodeQueue) <span class="hljs-comment">// 创建元素节点的子节点</span><br>        <span class="hljs-title function_">insert</span>(parentElm, vnode.<span class="hljs-property">elm</span>, refElm)       <span class="hljs-comment">// 插入到DOM中</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isTrue</span>(vnode.<span class="hljs-property">isComment</span>)) &#123;<br>      <span class="hljs-comment">//判断是否为注释节点，只需判断VNode的isComment属性是否为true</span><br>      vnode.<span class="hljs-property">elm</span> = nodeOps.<span class="hljs-title function_">createComment</span>(vnode.<span class="hljs-property">text</span>)  <span class="hljs-comment">// 创建注释节点</span><br>      <span class="hljs-title function_">insert</span>(parentElm, vnode.<span class="hljs-property">elm</span>, refElm)           <span class="hljs-comment">// 插入到DOM中</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//既不是元素节点，也不是注释节点，那就认为是文本节点</span><br>      vnode.<span class="hljs-property">elm</span> = nodeOps.<span class="hljs-title function_">createTextNode</span>(vnode.<span class="hljs-property">text</span>)  <span class="hljs-comment">// 创建文本节点</span><br>      <span class="hljs-title function_">insert</span>(parentElm, vnode.<span class="hljs-property">elm</span>, refElm)           <span class="hljs-comment">// 插入到DOM中</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="18-2-删除节点"><a href="#18-2-删除节点" class="headerlink" title="18.2 删除节点"></a>18.2 删除节点</h2><p>如果某些节点再新的VNode中没有而在旧的oldVNode中有，那么就需要把这些节点从旧的oldVNode中删除。删除节点非常简单，只需在要删除节点的父元素上调用removeChild方法即可。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> removeNode (el) &#123;<br>    const parent = nodeOps.parent<span class="hljs-constructor">Node(<span class="hljs-params">el</span>)</span>  <span class="hljs-comment">// 获取父节点</span><br>    <span class="hljs-keyword">if</span> (is<span class="hljs-constructor">Def(<span class="hljs-params">parent</span>)</span>) &#123;<br>      nodeOps.remove<span class="hljs-constructor">Child(<span class="hljs-params">parent</span>, <span class="hljs-params">el</span>)</span>  <span class="hljs-comment">// 调用父节点的removeChild方法</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="18-3-更新节点"><a href="#18-3-更新节点" class="headerlink" title="18.3 更新节点"></a>18.3 更新节点</h2><h3 id="更新子节点"><a href="#更新子节点" class="headerlink" title="更新子节点"></a>更新子节点</h3><p>更新节点过程中，新旧VNode可能都包含有子节点，对于子节点的对比更新会有额外的一些逻辑。以下四种情况：</p>
<ul>
<li>创建子节点<br>如果newChildren里面的某个子节点在oldChildren里找不到与之相同的子节点，那么说明newChildren里面的这个子节点是之前没有的，是需要此次新增的节点，那么就创建子节点。</li>
<li>删除子节点<br>如果把newChildren里面的每一个子节点都循环完毕后，发现在oldChildren还有未处理的子节点，那就说明这些未处理的子节点是需要被废弃的，那么就将这些节点删除。</li>
<li>移动子节点<br>如果newChildren里面的某个子节点在oldChildren里找到了与之相同的子节点，但是所处的位置不同，这说明此次变化需要调整该子节点的位置，那就以newChildren里子节点的位置为基准，调整oldChildren里该节点的位置，使之与在newChildren里的位置相同。</li>
<li>更新节点<br>如果newChildren里面的某个子节点在oldChildren里找到了与之相同的子节点，并且所处的位置也相同，那么就更新oldChildren里该节点，使之与newChildren里的该节点相同。</li>
</ul>
<h3 id="优化更新"><a href="#优化更新" class="headerlink" title="优化更新"></a>优化更新</h3><p><img src="https://vue-js.com/learn-vue/assets/img/8.e4c85c40.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<ol>
<li>新前等于旧前，无需进行节点移动操作</li>
<li>新后&#x3D;旧后，把newChildren数组里所有未处理子节点的最后一个子节点和oldChildren数组里所有未处理子节点的最后一个子节点做比对，如果相同，那就直接进入更新节点的操作并且由于新后与旧后两个节点的位置也相同，无需进行节点移动操作；如果不同，继续往后尝试。</li>
<li>新后&#x3D;旧前<br>相同，那就直接进入更新节点的操作，更新完后再将oldChildren数组里的该节点移动到与newChildren数组里节点相同的位置； <img src="https://vue-js.com/learn-vue/assets/img/11.2ddb5ee5.png" srcset="/img/loading.gif" lazyload alt="img"><br>此时，出现了移动节点的操作，移动节点最关键的地方在于找准要移动的位置。我们一再强调，<strong>更新节点要以新VNode为基准，然后操作旧的oldVNode，使之最后旧的oldVNode与新的VNode相同</strong>。那么现在的情况是：newChildren数组里的最后一个子节点与oldChildren数组里的第一个子节点相同，那么我们就应该在oldChildren数组里把第一个子节点移动到最后一个子节点的位置，如下图：<br><img src="https://vue-js.com/learn-vue/assets/img/12.bace2f7f.png" srcset="/img/loading.gif" lazyload alt="img"><br>从图中不难看出，我们要把oldChildren数组里把第一个子节点移动到数组中<strong>所有未处理节点之后</strong>。<br>如果对比之后发现这两个节点仍不是同一个节点，那就继续尝试最后一种情况。</li>
<li>新前&#x3D;旧后，把newChildren数组里所有未处理子节点的第一个子节点和oldChildren数组里所有未处理子节点的最后一个子节点做比对，如果相同，那就直接进入更新节点的操作，更新完后再将oldChildren数组里的该节点移动到与newChildren数组里节点相同的位置；<br><img src="https://vue-js.com/learn-vue/assets/img/13.98dbc208.png" srcset="/img/loading.gif" lazyload alt="img"><br>同样，这种情况的节点移动位置逻辑与“新后与旧前”的逻辑类似，那就是newChildren数组里的第一个子节点与oldChildren数组里的最后一个子节点相同，那么我们就应该在oldChildren数组里把最后一个子节点移动到第一个子节点的位置，如下图：<br><img src="https://vue-js.com/learn-vue/assets/img/14.18c1c6dd.png" srcset="/img/loading.gif" lazyload alt="img"><br>从图中不难看出，我们要把oldChildren数组里把最后一个子节点移动到数组中<strong>所有未处理节点之前</strong>。<br>准备4个变量：</li>
</ol>
<ul>
<li>**newStartIdx:**newChildren数组里开始位置的下标；</li>
<li>**newEndIdx:**newChildren数组里结束位置的下标；</li>
<li>**oldStartIdx:**oldChildren数组里开始位置的下标；</li>
<li>**oldEndIdx:**oldChildren数组里结束位置的下标；</li>
</ul>
<p>在循环的时候，每处理一个节点，就将下标向图中箭头所指的方向移动一个位置，开始位置所表示的节点被处理后，就向后移动一个位置；结束位置所表示的节点被处理后，就向前移动一个位置；由于我们的优化策略都是新旧节点两两更新的，所以一次更新将会移动两个节点。说的再直白一点就是：newStartIdx和oldStartIdx只能往后移动（只会加），newEndIdx和oldEndIdx只能往前移动（只会减）。<br>当开始位置大于结束位置时，表示所有节点都已经遍历过了。</p>
<h1 id="十九、Vue中key的作用"><a href="#十九、Vue中key的作用" class="headerlink" title="十九、Vue中key的作用"></a>十九、Vue中key的作用</h1><p>vue 中 key 值的作用可以分为两种情况来考虑：</p>
<ul>
<li>第一种情况是 v-if 中使用 key。由于 Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。因此当使用 v-if 来实现元素切换的时候，如果切换前后含有相同类型的元素，那么这个元素就会被复用。如果是相同的 input 元素，那么切换前后用户的输入不会被清除掉，这样是不符合需求的。因此可以通过使用 key 来唯一的标识一个元素，这个情况下，使用 key 的元素不会被复用。这个时候 key 的作用是用来标识一个独立的元素。</li>
<li>第二种情况是 v-for 中使用 key。用 v-for 更新已渲染过的元素列表时，它默认使用“就地复用”的策略。如果数据项的顺序发生了改变，Vue 不会移动 DOM 元素来匹配数据项的顺序，而是简单复用此处的每个元素。因此通过为每个列表项提供一个 key 值，来以便 Vue 跟踪元素的身份，从而高效的实现复用。这个时候 key 的作用是为了高效的更新渲染虚拟 DOM。<br>key 是为 Vue 中 vnode 的唯一标记，通过这个 key，diff 操作可以更准确、更快速</li>
<li>更准确：因为带 key 就不是就地复用了，在 sameNode 函数a.key &#x3D;&#x3D;&#x3D; b.key对比中可以避免就地复用的情况。所以会更加准确。</li>
<li>更快速：利用 key 的唯一性生成 map 对象来获取对应节点，比遍历方式更快</li>
</ul>
<h3 id="为什么不建议用index作为key"><a href="#为什么不建议用index作为key" class="headerlink" title="为什么不建议用index作为key"></a>为什么不建议用index作为key</h3><p>使用index 作为key和没写基本上没区别，因为不管数组的顺序怎么颠倒，index 都是 0, 1, 2…这样排列，导致 Vue 会复用错误的旧子节点，做很多额外的工作。</p>
<h1 id="二十、VUE异步事件队列-nextTick"><a href="#二十、VUE异步事件队列-nextTick" class="headerlink" title="二十、VUE异步事件队列(nextTick)"></a>二十、VUE异步事件队列(nextTick)</h1><p>当Vue侦听到数据变化时，如果同一个watcher被触发多次，只会被推入到队列 中一次，这种在缓冲时去除重复数据对于避免不必要的计算和DOM操作非常重要。在下一次<strong>事件循环tick</strong>时，Vue刷新队列并执行已经去重的工作。<br>nextick的<strong>核心</strong>是利用了Promise、MutationOberserver（监视DOM变动，实现异步触发，DOM变动后不会立刻触发，而是等到当前所有DOM操作都结束才去触发）和setImmediate（在浏览器完成其它语句后立刻执行其中回调函数，一般是执行时间比较长的）、setTimeout。<strong>本质是</strong>为了利用 JavaScript 的这些异步回调任务队列来实现 Vue 框架中自己的异步回调队列。</p>
<h2 id="引入异步更新队列机制的原因"><a href="#引入异步更新队列机制的原因" class="headerlink" title="引入异步更新队列机制的原因"></a>引入异步更新队列机制的原因</h2><p>①如果是同步更新，多次对一个或多个属性赋值，会频繁触发UI&#x2F;DOM的渲染，可以减少一些无用渲染。<br>②由于 VirtualDOM 的引入，每一次状态发生变化后，状态变化的信号会发送给组件，组件内部使用 VirtualDOM 进行计算得出需要更新的具体的 DOM 节点，然后对 DOM 进行更新操作，每次更新状态后的渲染过程需要更多的计算，而这种无用功也将浪费更多的性能，所以异步渲染变得更加至关重要。</p>
<p>Vue采用了数据驱动视图的思想，但是在一些情况下，仍然需要操作DOM。有时候，可能遇到这样的情况，DOM1的数据发生了变化，而DOM2需要从DOM1中获取数据，那这时就会发现DOM2的视图并没有更新，这时就需要用到了nextTick了。由于Vue的DOM操作是异步的，所以，在上面的情况中，就要将DOM2获取数据的操作写在$nextTick中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">this</span>.$nextTick(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-comment">// 获取数据的操作</span><br>    <span class="hljs-keyword">var</span> text = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;div&quot;</span>).<span class="hljs-property">innerHTML</span>;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(text);<br>&#125;&#125;<br></code></pre></td></tr></table></figure>
<h2 id="使用nextTick的情况"><a href="#使用nextTick的情况" class="headerlink" title="使用nextTick的情况"></a>使用nextTick的情况</h2><ol>
<li>在Vue生命周期的created()钩子函数进行的DOM操作一定要放在Vue.nextTick()的回调函数中。<br>因为在created()钩子函数执行的时候 DOM 其实并未进行任何渲染，而此时进行DOM操作无异于徒劳，所以此处一定要将DOM操作的js代码放进Vue.nextTick()的回调函数中。与之对应的就是mounted()钩子函数，因为该钩子函数执行时所有的DOM挂载和渲染都已完成，此时在该钩子函数中进行任何DOM操作都不会有问题 。</li>
<li>在数据变化后要执行的某个操作，而这个操作需要使用随数据改变而改变的DOM结构的时候，这个操作都应该放进Vue.nextTick()的回调函数中。</li>
</ol>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E5%8E%9F%E5%88%9B/">原创</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/05/12/JavaScript/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">JavaScript</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/05/12/%E5%89%8D%E7%AB%AF%E6%9D%82%E9%A1%B9/">
                        <span class="hidden-mobile">前端杂项</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/valine@1/dist/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"sOHs1UX9yhu45mOPqVuIjOkh-gzGzoHsz","appKey":"JlU9ppAdc6X2IEPeXLgdlFGc","path":"window.location.pathname","placeholder":null,"avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          Fluid.plugins.initFancyBox('#valine .vcontent img:not(.vemoji)');
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- LeanCloud 统计PV -->
        <span id="leancloud-site-pv-container" style="display: none">
            总访问量 
            <span id="leancloud-site-pv"></span>
             次
          </span>
      
      
        <!-- LeanCloud 统计UV -->
        <span id="leancloud-site-uv-container" style="display: none">
            总访客数 
            <span id="leancloud-site-uv"></span>
             人
          </span>
      

    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  




  <script defer src="/js/leancloud.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>












  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
